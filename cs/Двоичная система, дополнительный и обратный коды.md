# Двоичная система

На примере восьми разрядов:

| Биты числа        | 0           | 1          | 1          | 0          | 0         | 1         | 0         | 0         |
| ----------------- | ----------- | ---------- | ---------- | ---------- | --------- | --------- | --------- | --------- |
| Старшинство битов | Старший     |            |            |            |           |           |           | Младший   |
| Номер бита        | 8           | 7          | 6          | 5          | 4         | 3         | 2         | 1         |
| Разряд            | 7           | 6          | 5          | 4          | 3         | 2         | 1         | 0         |
| Вес               | $2^{7}=128$ | $2^{6}=64$ | $2^{5}=32$ | $2^{4}=16$ | $2^{3}=8$ | $2^{2}=4$ | $2^{1}=2$ | $2^{0}=1$ |
| Значение          | $0*128=0$   | $1*64=64$  | $1*32=32$  | $0*16=0$   | $0*8=0$   | $1*4=4$   | $0*2=0$   | $0*1=0$   |

Итого, `0110_0100` в двоичной это $4 + 32 + 64 = 100$ в десятичной

# Положительные и отрицательные числа

Для хранения знака числа обычно используется старший бит. Актуально для всех видов кодов:

| Старший бит | Какое число   |
| ----------- | ------------- |
| 0           | Положительное |
| 1           | Отрицательное |

# Прямой код

Прямой код - это способ записи

это обычное двоичное число безо всяких заморочек, как есть. Например, $100_{10}$ это $01100100_{2}$.

# Обратный и дополнительный коды

Не вникая в детали: в прямом коде трудно выполнить операцию вычитания, т.к. нужно реализовывать именно логику вычитания. С помощью обратного и дополнительного кодов *можно выполнять вычитание через сложение*. В этом и заключается их преимущество - конструктивно операция одна, а логически реализует две.

> ОК и ДК для положительных чисел выглядят так же как и ПК

А вот для отрицательных - формируются по определенным правилам. Результат также интерпретируется по определенным правилам в зависимости от получившегося знака. Разберемся.

## Обратный код

ОК для отрицательного числа: 

* Составляем ПК отрицательного числа
* Знаковый бит не трогаем
* Остальные биты инвертируем

> Сразу надо сказать, что на практике для арифметики используется дополнительный код, потому что обратный требует больше операций. Но для примера стоит разобраться

### Трактовка положительного и отрицательного результата

Выполним $100 - 25$ и $100 - 112$, чтобы в первом случае у нас был положительный результат, а во втором отрицательный и посмотрим, чем эти случаи отличаются. Пусть у нас только 8 разрядов, из которых старший - под знак:

| Число         | Код    | Переполнение | Знак (~~128~~) | 64    | 32    | 16    | 8     | 4     | 2     | 1     | Комментарий                           |
| ------------- | ------ | ------------ | -------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------------------------------------- |
| **+100**      | **ПК** |              | **0**          | **1** | **1** | **0** | **0** | **1** | **0** | **0** |                                       |
| +25           | ПК     |              | 0              | 0     | 0     | 1     | 1     | 0     | 0     | 1     |                                       |
| **+100**      | **ОК** |              | **0**          | **1** | **1** | **0** | **0** | **1** | **0** | **0** | == ПК +100                            |
| -25           | ОК     |              | 1              | 1     | 1     | 0     | 0     | 1     | 1     | 0     | Инвертируем +25                       |
| +100 + (-25)  | ПК!    | 1            | 0              | 1     | 0     | 0     | 1     | 0     | 1     | 0     | if переполнение, то +1 к результату   |
|               |        |              | 0              | 1     | 0     | 0     | 1     | 0     | 1     | 1     | == 75                                 |
| +112          | ПК     |              | 0              | 1     | 1     | 1     | 0     | 0     | 0     | 0     |                                       |
| **-112**      | **ОК** |              | **1**          | **0** | **0** | **0** | **1** | **1** | **1** | **1** |                                       |
| +100 + (-112) | ОК!    |              | 1              | 1     | 1     | 1     | 0     | 0     | 1     | 1     | if знак "-", то инвертируем результат |
|               | ПК!    |              | 1              | 0     | 0     | 0     | 1     | 1     | 0     | 0     | == -12 (знак не инвертируем)          |

Итак, сложение в ОК подразумевает *2 шага*:

* Собственно сложение
* Дополнительное действие, в зависимости от знака результата сложения:
  * Если получился "+", то считается, что результат уже находится в ПК, и к нему надо прибавить единицу (ту самую, которая ушла в переполнение)
  * Если получился "-", то считается, что результат находится в ОК, и мы переводим его в ПК путем инвертирования всех битов (кроме знакового), чтобы узнать, что же это за число

## Дополнительный код

ДК для отрицательного числа:

* Составляем ОК отрицательного числа
* Прибавляем к нему 1

Выполним $10 - 5$ и $5 - 10$:

| Число      | Код             | Переполнение | Знак (~~128~~) | 64    | 32    | 16    | 8     | 4     | 2     | 1     | Комментарий      |
| ---------- | --------------- | ------------ | -------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---------------- |
| **+10**    | **ПК (ОК, ДК)** |              | **0**          | **0** | **0** | **0** | **1** | **0** | **1** | **0** |                  |
| -10        | ПК              |              | 1              | 0     | 0     | 0     | 1     | 0     | 1     | 0     |                  |
| -10        | ОК              |              | 1              | 1     | 1     | 1     | 0     | 1     | 0     | 1     | Инверт -10 ПК    |
| -10        | ДК              |              | 1              | 1     | 1     | 1     | 0     | 1     | 1     | 0     | -10 ОК  +1       |
| **+5**     | **ПК (ОК, ДК)** |              | **0**          | **0** | **0** | **0** | **0** | **1** | **0** | **1** |                  |
| -5         | ПК              |              | 1              | 0     | 0     | 0     | 0     | 1     | 0     | 1     |                  |
| -5         | ОК              |              | 1              | 1     | 1     | 1     | 1     | 0     | 1     | 0     | Инверт -5 ПК     |
| -5         | ДК              |              | 1              | 1     | 1     | 1     | 1     | 0     | 1     | 1     | -5 ОК +1         |
| +10 + (-5) | ПК              | 1            | 0              | 0     | 0     | 0     | 0     | 1     | 0     | 1     | "+" => рез is ПК |
| +5 + (-10) | ДК              |              | 1              | 1     | 1     | 1     | 1     | 0     | 1     | 1     | "-" => рез is ДК |
|            | ДК ↔ ПК (шаг 1) |              | 1              | 0     | 0     | 0     | 0     | 1     | 0     | 0     | и еще +1         |
|            | ДК ↔ ПК (шаг 2) |              | 1              | 0     | 0     | 0     | 0     | 1     | 0     | 1     | оконч рез == -5  |



# Резюме



# Непонятки

- [ ] Почему в дополнительном коде нет +0 и -0?