# Классическая реализация (Хоара)

## Идея

Классическая реализация называется `реализация Хоара`. 

Ее особенности:

* В качестве опорного элемента берется центральный элемент массива.
* Для сравнения элементов используются два указателя. Они двигаются от краев массива к центральному элементу.
* Используется рекурсия.

Описание:

* Выбираем "опорную" ячейку. В классической реализации - это центральная ячейка массива.
* Основная идея: 
  * После этапа сортировки должно оказаться так, что слева от опорной ячейки лежат элементы меньше ее, а справа - больше.
  * Т.о. получится частично отсортированный массив: элемент, лежащий в опоре, гарантировано занимает правильное место, а слева и справа от него - неотсортированные части.
    * Т.е. здесь задача - не найти правильную позицию для элемента, который изначально был в опоре, а именно чтобы в самой опоре оказался нужный элемент.
  * Алгоритм запускается рекурсивно для левой и правой части.
  * Т.о. постепенно массив сортируется.
* Движение по массиву реализуется через два указателя.
  * Левый - это начало массива.
  * Правый - конец массива.
  * Указатели двигаются к опоре.
    * Как только на пути левого указателя попадается элемент, который больше опоры, т.е. должен находиться справа, указатель останавливается.
    * Начинает двигаться правый указатель до тех пор, пока не встретится элемент, который меньше опоры.
  * Т.о. мы находим два элемента, которые надо поменять местами.
  * Меняем их.
  * Продолжаем движение указателей до тех пор, пока указатели не пересекутся. Это означает, что опора на своем месте и можно начинать сортировать боковые части.

## Реализация

"Правильная":

```javascript
const short7 = [3, 7, 10, 5, 12, 0, 19];
const long10 = [2, 8, 15, 4, 11, 6, 17, 1, 9, 20];

function quick(arr, left = 0, right = arr.length - 1) {
  if (left >= right) return;

  const pivot = arr[Math.floor((left + right) / 2)];
  let L = left;
  let R = right;

  while (L <= R) {
    while (arr[L] < pivot) L++;
    while (arr[R] > pivot) R--;
    if (L <= R) {
      [arr[R], arr[L]] = [arr[L], arr[R]];
      L++;
      R--;
    }
  }
  quick(arr, left, R);
  quick(arr, L, right);
}

console.log(short7);
quick(short7);
console.log(short7);

console.log(long10);
quick(long10);
console.log(long10);
```

Моя: я искренне не понимаю условий в классике. Может быть они универсальны для случаев, когда опора не обязательно центральный элемент. Но когда центральный, по-моему вот так выглядит логичнее:

```javascript
// let arr = [ 3, 7, 8, 1, 5, 6, 0, 4, 9];
// let arr = [ 10, 7, 8, 9, 1, 5 ];
// let arr = [ 1, 2, 3, 4, 5 ];
// let arr = [ 5, 4, 3, 2, 1 ];
// let arr = [ 3, 1, 4, 1, 5, 9, 2, 6, 5, 3 ];
// let arr = [ 42 ];  // ???
// let arr = [ -5, 0, 3, -1, 2 ];
// let arr = [ 7, 7, 7, 7, 7 ];
let arr = [ 0, 1, 2, 4, 8, 16, 9, 7, 15 ];


function qsort(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  const p = arr[Math.floor((left + right) / 2)];

  let l = left;
  let r = right;

  while (l < r) {   // <--
    while (arr[l] < p) l++;
    while (arr[r] > p) r--;

    if (l !== r) {  // <--
      [arr[r], arr[l]] = [arr[l], arr[r]];
      l++;  // Для случая, когда два элемента равны. Если не двинуть после свапа, то указатели зависнут.
      r--;
    }
  }
  qsort(arr, left, l-1);  // <--
  qsort(arr, r+1, right);  // <--
}

console.log(arr);
qsort(arr);
console.log(arr);
```



