# $O(1)$ константная

Время выполнения не зависит от количества данных.

Примеры:

- Извлечение элемента из массива:

  ```java
  int[] arr = { 1, 6, 3, 4 };
  int item = arr[2];  // <-- O(1)
  ```





# $O(log_2n)$ логарифмическая

Связана с бинарным поиском, поэтому основание логарифма всегда 2. Это алгоритмы, где на каждой итерации обрабатывается только половина элементов от предыдущей итерации.





# $O(n)$ линейная

Время выполнения равномерно увеличивается при увеличении количества элементов.

Примеры: 

* Обход любой коллекции.

```java
private static void n() {
    int[] arr = { 1, 6, 3, 4 };
    int sum = 0;
    int steps = 0;

    for (int i = 0; i < arr.length; i++) {  // <-- O(n)
        sum += arr[i];
        steps++;
    }

    System.out.println("Элементов:" + arr.length);
    System.out.println("Шагов:" + steps);
}

// Вывод
Элементов:4
Шагов:4
```





# $O(n * log_n)$ линейно-логарифмическая





# $O(n^2)$ квадратическая

Частный случай *полиномиальной* сложности $n^m$. В квадратичной время выполнения увеличивается вдвойне по отношению к количеству элементов. Пример - вложенный цикл по той же самой коллекции.



# $O(2^n)$ экспоненциальная





# $O(n!)$ факториальная



