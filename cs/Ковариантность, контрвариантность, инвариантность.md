# Предисловие

Термины ковариантность, контрвариантность и инвариантность относятся к производным типам. Производные типы - это не потомки, а, например, дженерики. Кроме дженериков примеров я не знаю, но и этого вполне достаточно.

![proizvodnie_types.drawio](img/proizvodnie_types.drawio.svg)

`Set<Parent>` является производным типом от `Parent`, а `Set<Child>` - производным от `Child`. Объяснения формулировок, названия типов и примеры для объяснений следует воспринимать в отрыве от конкретного языка и компилятора.

# Формулировки

* Совместимость присваивания (*assignment compatibility*, Эрик Липперт) - когда потомка можно присвоить переменной родителя. Например:

  ```java
  Child c = new Child();
  Parent p = c;
  ```

* Вариантность - сохранение совместимости присваивания у производных типов.

  * ***Ко***вариантность - сохранение совместимости так же, как у оригинальных типов.
  * ***Контра***вариантность - сохранение совместимости в обратном порядке относительно оригинальных типов.

* Инвариантность - отсутствие совместимости присваивания у производных типов.

Вариантность нужна для того, чтобы и в производных типах можно было пользоваться преимуществами полиморфизма.

Чтобы не сломать голову, важно думать о вариантности именно в контексте производных типов.

# Объяснения

Классы на псевдоязыке:

```java
class Device {
    private String name;

    public Device(String name) {
        this.name = name;
    }

    public void plug() {
        System.out.println("Устройство " + name + "подклчено.");
    }
}
```

```java
class Mouse extends Device {
    public Mouse(String name) {
        super(name);
    }

    public void scroll() {
        System.out.println("Крутим колесико мыши.");
    }
}
```

## Ковариантность

![kovariance.drawio](img/kovariance.drawio.svg)

Совместимость присваивания между производными типами выглядит так же, как между оригинальными:

```
Device d = Mouse;  // Совместимость оригинальных типов
Set<Device> sd = Set<Mouse>;  // // Совместимость производных типов такая же
```

Пример:

```java
void koDemo(Set<Device> devices) {
    devices.forEach(d -> d.plug);
}
...
var mice = new Set<Mouse>;
koDemo(mice);
```

Если мы можем работать с одним потомком как с родителем, то значит должны иметь возможность работать и с коллекцией потомков как с коллекцией родителей. В том смысле, что мы должны иметь возможность передать коллекцию мышей в метод, который ожидает коллекцию устройств, и работать там с каждой мышкой из коллекции как с устройством.

## Контравариантность

![kontravariance.drawio](img/kontravariance.drawio.svg)

Совместимость присваивания между производными типами направлена в обратную сторону:

```
Device d = Mouse;  // Совместимость оригинальных типов
Action<Mouse> am = Action<Device>;  // Совместимость производных типов - "инвертирована"
```

Пример:

```java
void kovarDemo(Action<Mouse> mfunc) {
    var mouse = new Mouse("Logitech");
    mfunc.invoke(mouse);  // Вызываем на мышке метод plug. Он у нее есть, все в порядке.
}

Action<Device> func = d -> d.plug();
kovarDemo(func);
```

Если мы можем выполнить какую-то функцию над устройством, значит эта же функция должна работать над мышью, потому что мышь тоже является устройством. Соответственно, если метод принимает функцию, рассчитанную на мышь, то обязан также принимать функцию, рассчитанную на устройство.

Однако передать "мышиную функцию" на место "девайсовой функции" нельзя, потому что она может вызвать мышиную функциональность, которой у устройства нет:

```java
// Невозможно
void kovarWrongDemo(Action<Device> dfunc) {
    var device = new Device("Plug'n'play device");
    dfunc.invoke(device);  // Попытка вызвать на Device метод scroll, которого у него нет.
}

Action<Mouse> func = m -> m.scroll();
kovarWrongDemo(func);
```



TODO: Приделать сюда примеры на нормальной джаве, а не только на псевдоязыке. Тут понадобится знания вайлдкардов, так что вернуться к этому можно при добивании дженериков.



# Использованная литература

```
https://habr.com/ru/articles/218753/
```

