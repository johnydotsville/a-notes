# Объявление сущности

> Хотел заменить пример с актером на другой, т.к. стратегия генерации IDENTITY пока для меня не актуальна, но другой не подходил под демонстрацию @AttributeOverride, так что актера оставил, а другой пример привел в конце

Пример на классе актёра:

* Поля, которые должны сохраняться в одну таблицу, размазаны по двум классам: базовая абстрактная сущность имеет id, а имя и фамилия находятся в классе актера
* Не все поля требуется сохранять - некоторые надо игнорировать
* Поле Id в разных таблицах называется по-разному

Базовая сущность: в ней мы зададим поле идентификатора, укажем стратегию генерации идентификатора, но не будем указывать, на какой столбец таблицы это поле должно проецироваться, т.к. у каждой конкретной сущности есть своя таблица и там id-поле называется по-разному:

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Transient;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;

@MappedSuperclass
public abstract class AbstractEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Transient  // Значит не должно сохраняться
    private LocalDate createdAt;
    @Transient  // Значит не должно сохраняться
    private LocalDate modifiedAt;

    public AbstractEntity() {
        createdAt = LocalDate.now();
        modifiedAt = LocalDate.now();
    }
    ...
}
```

Класс актера:

```java
import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Entity;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import javax.validation.constraints.Size;

@Entity
@Table(name = "actor", schema = "bl")
@AttributeOverride(name = "id", column = @Column(name = "actor_id"))
public class Actor extends AbstractEntity {
    @Column(name = "first_name", length = 45)
    @Size(min = 2, max = 45)
    private String firstName;
    @Column(name = "last_name", length = 45)
    @Size(min = 2, max = 45)
    private String lastName;

    public Actor() {
        super();
    }
    ...
}
```

# Объяснения

* @Entity - с помощью этой аннотации мы сообщаем, что класс участвует в хранении.

* @Id - каждая сущность, сохраняемая в БД, обязана иметь идентификатор. Обычно это суррогатный ключ, который генерирует или приложение, или СУБД.

  После сохранения объекта, в свойстве id появляется идентификатор, который сгенерировала БД. Ничего дополнительно для этого делать не надо.

* @GeneratedValue - для генерации этого суррогатного ключа есть несколько стратегий. На момент написания я детально в них не разбирался. Знаю, что можно использовать отдельные созданные в БД последовательности, но в моем случае заработал обычный автоинкремент.

  UPD. Заработал он только благодаря тому, что в БД была создана последовательность для генерации. Как хибер ее отыскал, я не знаю. В этом буду разбираться потом.

  UPD2. Identity вообще не понятно почему работает. Теоретически, оно должно работать, если таблица создана с identity-столбцом. Но эти таблицы все созданы без него - id можно в них вставлять руками. Так что самый логичный способ, который я пока вижу, - это руками создавать sequence'ы и назначать их явно через аннотации.

* @Table - с помощью этой аннотации явно задаем, с какой таблицей мы сопоставляем сущность (и в какой схеме находится эта таблица, если это не дефолтная public схема).

  В postgres понятие схемы - это что-то вроде "папки" для таблиц. Если одни таблицы относятся в бизнес-логике, а другие вспомогательные, например, для авторизации, то для большей наглядности можно поместить их в отдельную схему. И чтобы указать хиберу, в какой схеме лежит таблица, мы пользуемся параметром schema.

* @Column - через эту аннотацию можно задать несколько параметров. В данном случае я использовал два: к какому столбцу мы хотим привязать поле и какой максимальный размер поля. Причем максимальный размер в данном случае не выполняет валидацию в том смысле, что он просто даст ошибку при попытке сохранить что-то длинное, но в самом процессе валидации не участвует.

* @Size - валидирующая аннотация. Вот она как раз заполнит ошибки валидации при валидировании объекта.

Комбинация @MappedSuperclass, @Transient и @AttributeOverride:

* @MappedSuperclass

  При наследовании поля суперкласса не подлежат сохранению. Да и вообще для суперкласса не положено иметь отдельную таблицу. Но поскольку мы конечно хотим сохранять поле Id для каждой сущности-наследника, то должны аннотировать родителя @MappedSuperclass - так хибер поймет, что поля родителя участвуют в хранении.

* @Transient - позволяет игнорировать поле при сохранении. Поскольку на момент написания у меня в БД было поле last_update и СУБД заполняла его автоматически, а поля под дату создания вообще нигде не было, но при этом поля в классах хотелось оставить, т.к. их идея мне нравится, то я просто поставил их игнорирование. Двойная польза.

* @AttributeOverride - поскольку у каждой таблицы под сущности в БД поле идентификатора называется по-разному (actor_id, country_id и т.д.), но при этом свойство Id находится в базовом классе сущности, то с помощью этой аннотации мы можем переопределить, к какой колонке каждая конкретная сущность должна привязывать свой id. А вот стратегия генерации ключа для всех сущностей одинаковая - она как написана в базовой сущности, так мы ее в потомках и оставляем.

# Генерация @Id и базовая сущность

В итоге пока что делаю вывод, что размещать id в базовой сущности - это плохо. Потому что, во-первых, приходится в каждой сущности переопределять столбец, с которым этот id сопоставляется. А, во-вторых, похоже, если захочется переопределить стратегию генерации id, то сделать это будет непросто. Через @AttributeOverride, похоже, это вообще не делается, а делается через файл orm.xml и у меня не заработало.

В общем, из базовой сущности id убираем и, например, id в Actor получается такой:

```java
@Entity
@Table(name = "city", schema = "bl")
@Getter @Setter  // аннотации библиотеки lombok
public class City extends AbstractEntity {
    @Id
    @Column(name = "id")
    @SequenceGenerator(name = "city_id_gen", schema = "bl", sequenceName = "city_id_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "city_id_gen")
    private long id;
```

* @SequenceGenerator
  * name - имя генератора для обращения внутри java-программы
  * sequenceName - имя последовательности на стороне СУБД
  * allocationSize - там что-то про резервирование, но на практике, похоже, это просто приращение. Даже если оно указано на стороне СУБД, здесь тоже надо указывать почему-то, иначе ошибка
* @GeneratedValue
  * strategy - на этот раз указываем явно, что надо использовать последовательность
  * generator - name из @SequenceGenerator. Ссылаемся на последовательность, описанную через @SequenceGenerator, по имени внутри java-программы