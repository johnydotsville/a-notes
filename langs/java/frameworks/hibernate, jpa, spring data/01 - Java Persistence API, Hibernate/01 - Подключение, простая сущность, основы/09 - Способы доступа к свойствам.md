# Способы доступа к свойствам

> Тема скорее для расширения кругозора, на практике вряд ли понадобится.

Хибер может обращаться к полям класса двумя способами:

* Прямой (через рефлексию, еще называется field-access)
* Через геттеры\сеттеры (еще называется property-access)

То, как он это будет делать, определяется положением аннотации @Id:

* Если она над полем, то используется прямой доступ
* Если она над геттером, то для доступа к полю используются геттеры\сеттеры (над сеттером аннотации никогда не ставятся)

Кроме того, есть возможность с помощью аннотации `@Access` явно указать, какой способ нужно использовать. Синтаксис:

```java
import jakarta.persistence.Access;
import jakarta.persistence.AccessType;

@Access(AccessType.FIELD | PROPERTY)
```

Аннотацию можно применить к классу, тогда правило распространится на все свойства, а можно к конкретному свойству. Если она на уровне класса, тогда все остальные аннотации, вроде @Id, @Column и т.д. должны располагаться соответствующим образом, т.е. если в @Access задали .FIELD, все аннотации располагаем над полями.

Стратегия доступа распространяется на родителя сущности и на embeddable-классы.

Преимущества прямого доступа:

* Выглядит симпатичнее

* Прямой доступ позволяет избежать создания геттеров\сеттеров, если они нам вообще-то в программе и не нужны вовсе (например, какое-нибудь поле мы хотим сделать только для чтения, соответственно, сеттер бы только мешал, но был бы необходим хиберу в случае использования AccessType.Property)

* Если использовать property-access, тогда хибер наложил бы на геттеры\сеттеры дополнительные ограничения. Например, хибер не знает ничего про тип Optional и написать геттер вот так было бы невозможно:

  ```java
  public Optional<Publisher> getPublisher() {
      return Optional<Publisher>.ofNullable(this.publisher);
  }
  ```

  А используя field-access мы можем реализовывать геттеры\сеттеры как хотим.

* Класс может содержать не только геттеры и сеттеры, но и другие методы, например бизнес-логику или просто какие-то утилитарные вещи. В случае использования property-access нам бы пришлось все эти методы помечать аннотацией @Transient, чтобы хибер их игнорировал.

* property-access потенциально создает проблемы при использовании ленивой загрузки. Ленивая загрузка предполагает, что данные подгружаются только в момент обращения к ним. Значит, если мы используем property-access стратегию, то они будут подгружаться только если мы обратимся к геттеру. А если обратимся просто к полю, то они не подгрузятся и это может создать проблемы.

  Например в методах equals и hashCode обычно мы обращаемся напрямую к полям, а не через геттеры\сеттеры, т.к. поля доступны нам напрямую внутри класса. Соответственно, эти поля запросто могут оказаться пустыми в случае ленивой загрузки.