Здесь собраны мини-темы, которые выделять в отдельные файлы не хочется, потому что получится много "шума". Логика такая - если какой-то темы нету в отдельном файле, значит ее нужно поискать здесь. Поэтому она идет последней.

# Мапинг полей

По умолчанию хибер расценивает все поля сущности как хранимые, даже если они не отмечены никакой аннотацией. Правила такие:

* Если поле примитивное или обертка (int, Integer и т.д.), то хибер ищет в таблице колонку с таким же именем как у поля и подходящим типом.
* Если поле сложного типа и этот тип или само свойство отмечено как `@Embeddable`, то сохраняется по правилам @Embeddable (об этом отдельный раздел).
* Если поле является Serializable, то оно сохраняется в двоичной форме.
* Если ни одно из условий не выполнено, хибер выбрасывает исключение о том, что не смог понять тип.



# Настройки

## @Table

### Указать схему, в которой находится таблица

В некоторых СУБД есть понятие схемы и каталога - это дополнительные способы группировать таблицы. Например, таблицы относящиеся к технической стороне (Пользователи, Разрешения) могут находиться в одной схеме, а таблицы относящиеся к бизнесу (Товары, Клиенты, Заказы) - в другой схеме.

В случае, если таблица располагается не в схеме по умолчанию, мы можем задать ее явно через параметр `schema`:

```java
@Entity
@Table(name = "empl", schema = "domain")  // <-- В БД таблица называется empl и находится в схеме domain
public class Employee {
    ...
}
```



## @Transient

### Исключение поля из хранения

Если поле не нужно сохранять в БД, нужно отметить его аннотацией `@Transient` или ключевым словом джавы transient:

```java
@Transient  // <-- Так
private Name fullname;

private transient Name fullname;  // <-- Или так
```

## @Column и @Basic

С помощью аннотации `@Column` можно сделать несколько вещей. Еще есть аннотация `@Basic`, в которой есть аналогичная функциональность, но в меньшем количестве, поэтому она в общем-то и не нужна, все можно сделать через @Column.

### Отметить поле как обязательное \ необязательное

По умолчанию хибер предполагает, что поле может быть сохранено как null. Можно переопределить это с помощью параметра `optional`:

```java
@Column(nullable = false)
private String name;
```

Теперь хибер будет проверять поле name на null еще до попытки сохранения сущности в БД и выбросит исключение, если поле будет null. А если используется code-first подход и по коду генерируется БД, то на поле name в таблице на уровне БД будет добавлено ограничение NOT NULL.

### Настройка выборки - жадная \ ленивая

Делается с помощью параметра `fetch`, но связана с более сложной темой, поэтому рассматривается в отдельном конспекте.



