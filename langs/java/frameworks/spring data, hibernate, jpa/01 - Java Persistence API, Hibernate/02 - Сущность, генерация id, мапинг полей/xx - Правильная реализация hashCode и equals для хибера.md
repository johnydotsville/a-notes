Этот конспект можно разместить после разбора раздела мапинга наследования.

# Важность hashCode и equals

Для сущностей принципиально важно реализовывать эти методы, потому что их может использовать хибер для своих целей. В базовом классе можно реализовать "проверку на дурака", а в самих сущностях дополнить проверками специфичных полей.

Детальнее про эти методы сами по себе см. конспект *java-core/Уникальность и сравнение объектов/Методы equals и hashCode*.

Для хибера есть несколько важных особенностей по реализации этих методов ввиду того, что хибер часто работает с прокси-объектами, а не самими сущностями:

* Доступ к свойствам нужно делать через геттеры, потому что сравниваемый объект может быть прокси-объектом (о проксях - отдельный конспект). В этом случае, если обратиться напрямую к полю, то там не будет никакого значения, потому что хибер не заполняет проксю данными, пока к ним не происходит реального обращения. А это самое реальное обращение он может обнаружить только если они производится через геттер. Соответственно, обращаясь к свойствам через геттер, мы получаем гарантию, что хибер инициализирует объект.
* Проверку на соответствие типов нужно делать через instanceof, т.к. в рантайме "другим" объектом может оказаться сгенерированный хибером прокси-класс, который является потомком City. Следовательно, проверка через *.getClass* не пройдет. Поэтому используем *instanceof*.
* В качестве полей, по которым проверять на равенство, можно выбрать натуральный ключ. Т.е. то поле или комбинацию полей, которое могло бы быть первичным ключом, если бы мы не использовали суррогатный ключ. Например, имя пользователя.

Базовый класс:

```java
@MappedSuperclass
@Getter @Setter
public abstract class AbstractEntity {
    ...

    @Override
    public boolean equals(Object obj) {  // Проверки на дурака
        if (this == obj) return true;
        if (obj == null) return false;
        // Проверку на совпадение типов здесь не делаем, почему - объяснено ниже
        return true;
    }
}
```

Класс сущности:

```java
@Entity
@Table(name = "city", schema = "bl")
@Getter @Setter
public class City extends AbstractEntity {
    @Id
    @Column(name = "id")
    @SequenceGenerator(name = "city_id_gen", schema = "bl", sequenceName = "city_id_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "city_id_gen")
    private long id;

    @Column(name = "name")
    private String name;

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), getId(), getName());
    }

    @Override
    public boolean equals(Object obj) {
        if (!super.equals(obj)) return false;  // Проверка "на дурака" из базовой сущности
        // Специфические для сущности проверки
        if (!(obj instance of City)) return false;  // <-- Обязательно instanceof, а не getClass()
        var city = (City) obj;
        return Objects.equals(getFoobar(), city.getFoobar()) &&
            Objects.equals(getName(), city.getName());  // <-- Доступ обязательно через геттеры.
    }
}
```

Проверку на дурака, не зависящую от конкретной сущности, можно сделать в базовом классе, чтобы не дублировать в сущностях, а все остальные проверки - уже в конкретных сущностях.

