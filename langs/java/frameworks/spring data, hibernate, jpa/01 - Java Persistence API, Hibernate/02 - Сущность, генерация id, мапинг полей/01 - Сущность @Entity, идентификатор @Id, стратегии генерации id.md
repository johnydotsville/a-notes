# Сущность

Чтобы хибер трактовал класс как сущность, мы снабжаем его аннотацией `@Entity`. Каждая сущность должна обладать идентификатором, его мы задаем через аннотацию `@Id`. Пример:

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.SequenceGenerator;

@Entity  // <-- Указываем, что класс описывает сущность
@Table(name = "actor")
public class Actor {

    @Id  // <-- Отмечаем поле класса, которое служит идентификатором сущности
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "city_id_gen")
    @SequenceGenerator(name = "city_id_gen", sequenceName = "city_id_seq", allocationSize = 1)
    private long id;
    
    @Column(name = "first_name")
    private String firstName;
    
    @Column(name = "last_name")
    private String lastName;
    
}
```

Про аннотации @Table, @Column планируется отдельный конспект. Здесь же предполагается, что эти аннотации в их минимальном виде довольно очевидны и не нуждаются в объяснениях.

# Стратегии генерации id

Формировать идентификатор можно разными способами:

* Ручное назначение - не требует никаких аннотаций. Может быть полезно для legacy-БД или в случае натуральных ключей, когда автогенерация невозможна. Перед сохранением сущности нужно вручную присвоить значение идентификатору.
* Автоматическое назначение - указывает хиберу, что значение генерируется на стороне БД. В этом случае нужна аннотация `@GeneratedValue` и через  ее параметр `strategy` мы указываем, какую *стратегию* генерации хотим использовать.

## Стратегии генерации

### AUTO

Не рекомендуется использовать, потому что не дает никаких средств настройки.

### IDENTITY

Чтобы эта стратегия работала, на стороне БД поле должно быть объявлено как первичный ключ и чтобы СУБД знала, откуда брать значение ключа по умолчанию.

Например, в Postresql можно сделать так:

* При создании поля дать ему тип `serial`, тогда СУБД автоматически создаст sequence и поставит его в default-значение поля. Sequence она по умолчанию назовет как `имятаблицы_id_seq`, этот sequence будет видно в разделе последовательностей вместе с остальными, созданными вручную.
* Создать sequence самостоятельно и указать его значением по умолчанию для некоторого поля.

Тогда идентификатор можно будет замапить вот так:

```java
@Id
@Column(name = "id")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long id;
```

### SEQUENCE

Sequence - это специальный объект в БД, который нужен для генерации последовательных значений. При каждом обращении он возвращает новое увеличенное значение. 1, 2, 3, 4, 5 и т.д., шаг приращения можно настраивать.

При такой стратегии мы дополнительно пользуемся аннотацией `@SequenceGenerator` и явно должны указать, какой sequence отвечает за генерацию значения идентификатора. Если sequence находится не в дефолтной схеме, то к имени нужно добавить и схему, через `.`. На стороне БД для поля первичного ключа не требуется никаких особенных настроек.

```java
@Id
@Column(name = "id")
@GeneratedValue(
    strategy = GenerationType.SEQUENCE, 
    generator = "employee_id_gen" // <-- Имя генератора, который мы создаем через @SequenceGenerator
)  
@SequenceGenerator(  // <-- При такой стратегии генератор задается аннотацией @SequenceGenerator
    name = "employee_id_gen", // <-- Имя генератора, чтобы сослаться на него из @GeneratedValue
    sequenceName = "ast.employee_id_seq", // <-- Имя sequence на стороне БД (со схемой ast)
    allocationSize = 1  // <-- Шаг приращения, должен совпадать с установленным на стороне БД
)  
private long id;
```

Из личных размышлений: это может быть полезно, если вдруг нужно явно задать, какой sequence надо использовать. Например, по умолчанию в БД на поле стоит emp_id_seq, а мы хотим программно переназначить employee_id_seq.

### TABLE

Для этого способа используется аннотация `@TableGenerator` и он подразумевает, что в БД есть специальная таблица, в которой для каждой сущности полагается собственная строка со следующим значением для идентификатора. Эту таблицу нужно создать вручную. В ней должно быть два столбца: под имя генератора (строка) и под его значение (число). Имена полей произвольные.

```java
@Id
@Column(name = "id")
@GeneratedValue(
    strategy = GenerationType.TABLE, 
    generator = "employee_id_gen"  // <-- Имя генератора, который мы создаем через @TableGenerator
)
@TableGenerator(  // <-- При такой стратегии генератор задается аннотацией @TableGenerator
    name = "employee_id_gen",  // <-- Имя генератора, чтобы сослаться на него из @GeneratedValue
    table = "ids_generator",  // <-- Таблица, которая хранит значения идентификаторов
    pkColumnName = "key",  // <-- Имя столбца под название идентификатора
    valueColumnName = "value",  // <-- Имя столбца под значение идентификатора
    pkColumnValue = "employee_id",  // <-- Имя, которое сохранится в поле, обозначенное через pkColumnName
    allocationSize = 1  // <-- Шаг приращения идентификатора
)
private long id;
```

В итоге мы можем хранить все значения для идентификаторов в одной таблице. Сколько будет сущностей, столько и строк в этой таблице. Для наглядности, она будет выглядеть примерно так:

| key (имя столбца, заданное через pkColumnName)               | value (имя столбца, заданное через valueColumnName) |
| ------------------------------------------------------------ | --------------------------------------------------- |
| `employee_id` (название идентификатора, заданное через pkColumnValue) | 5                                                   |
| `country_id`                                                 | 100                                                 |

Название идентификатора - это просто произвольная строка. Для удобства использован паттерн `имяСущности_id`.

# TODO

На стр.70 в книге Java persistence with Hibernate - Christian Bauer, Gavin King, Gary Gregory (2016) рассказывается про нативные аннотации хибера, которые позволяют сделать все то же самое, что я уже описал, но с еще дополнительными удобностями. Пока что возиться не хочется, пойду дальше. Эту же запись оставляю просто для того, чтобы знать, что такая инфа есть.







