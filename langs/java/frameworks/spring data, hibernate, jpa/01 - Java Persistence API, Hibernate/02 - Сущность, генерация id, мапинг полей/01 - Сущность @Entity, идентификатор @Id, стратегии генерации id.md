# Сущность

Чтобы хибер трактовал класс как сущность, мы снабжаем его аннотацией `@Entity`. Каждая сущность должна обладать идентификатором, его мы задаем через аннотацию `@Id`. Пример:

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.SequenceGenerator;

@Entity  // <-- Указываем, что класс описывает сущность
@Table(name = "actor")
public class Actor {

    @Id  // <-- Отмечаем поле класса, которое служит идентификатором сущности
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "city_id_gen")
    @SequenceGenerator(name = "city_id_gen", sequenceName = "city_id_seq", allocationSize = 1)
    private long id;
    
    @Column(name = "first_name")
    private String firstName;
    
    @Column(name = "last_name")
    private String lastName;
    
}
```

Про аннотации @Table, @Column планируется отдельный конспект. Здесь же предполагается, что эти аннотации в их минимальном виде довольно очевидны и не нуждаются в объяснениях.

# Стратегии генерации id

Формировать идентификатор можно разными способами:

* Ручное назначение - не требует никаких аннотаций. Может быть полезно для legacy-БД или в случае натуральных ключей, когда автогенерация невозможна. Перед сохранением сущности нужно вручную присвоить значение идентификатору.
* Автоматическое назначение - указывает хиберу, что значение генерируется на стороне БД. В этом случае используется пара аннотаций `@GeneratedValue` + `@SequenceGenerator` \ `@TableGenerator`:
  * `@GeneratedValue` - в ней два параметра:
    * `strategy` - указываем стратегию генерации. Возможные значения: `GenerationType.AUTO`, `GenerationType.IDENTITY`, `GenerationType.SEQUENCE`, `GenerationType.TABLE`.
    * `generator` - указываем имя генератора, обозначенного второй аннотацией, которая уже зависит от выбранной стратегии.
  * `@SequenceGenerator`, `@TableGenerator` - вторая аннотация, в которой через параметры указываем хиберу, как в БД найти нужный генератор, чтобы запросить у него значение для идентификатора.

## Стратегии генерации

### AUTO

Не рекомендуется использовать, потому что не дает никаких средств настройки.

### IDENTITY

Чтобы эта стратегия работала, на стороне БД поле должно быть объявлено как первичный ключ и чтобы СУБД знала, откуда брать значение ключа по умолчанию. Например, в Postresql для этого нужно при создании поля дать ему тип `serial`, тогда СУБД автоматически создаст sequence и поставит его в default-значение поля. Тогда идентификатор можно будет замапить вот так:

```java
@Id
@Column(name = "id")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long id;
```

### SEQUENCE

Sequence - это специальный объект в БД, который нужен для генерации последовательных значений. При каждом обращении он возвращает новое увеличенное значение. 1, 2, 3, 4, 5 и т.д., шаг приращения можно настраивать.

При такой стратегии мы пользуемся аннотацией `@SequenceGenerator` и явно должны указать, какой sequence отвечает за генерацию значения идентификатора. На стороне БД для поля первичного ключа не требуется никаких особенных настроек.

```java
@Id
@Column(name = "id")
@GeneratedValue(
    strategy = GenerationType.SEQUENCE, 
    generator = "employee_id_gen" // <-- Имя генератора, который мы создаем через @SequenceGenerator
)  
@SequenceGenerator(  // <-- При такой стратегии генератор задается аннотацией @SequenceGenerator
    name = "employee_id_gen", // <-- Имя генератора, чтобы сослаться на него из @GeneratedValue
    sequenceName = "employee_id_seq", // <-- Имя sequence на стороне БД
    allocationSize = 1  // <-- Шаг приращения, должен совпадать с установленным на стороне БД
)  
private long id;
```

### TABLE

Для этого способа используется аннотация `@TableGenerator` и он подразумевает, что в БД есть специальная таблица, в которой для каждой сущности полагается собственная строка со следующим значением для идентификатора. Эту таблицу нужно создать вручную. В ней должно быть два столбца: под имя генератора (строка) и под его значение (число). Имена полей произвольные.

```java
@Id
@Column(name = "id")
@GeneratedValue(
    strategy = GenerationType.TABLE, 
    generator = "employee_id_gen"  // <-- Имя генератора, который мы создаем через @TableGenerator
)
@TableGenerator(  // <-- При такой стратегии генератор задается аннотацией @TableGenerator
    name = "employee_id_gen",  // <-- Имя генератора, чтобы сослаться на него из @GeneratedValue
    table = "ids_generator",  // <-- Таблица, которая хранит значения идентификаторов
    pkColumnName = "key",  // <-- Имя столбца под название идентификатора
    valueColumnName = "value",  // <-- Имя столбца под значение идентификатора
    pkColumnValue = "employee_id",  // <-- Имя, которое сохранится в поле, обозначенное через pkColumnName
    allocationSize = 1  // <-- Шаг приращения идентификатора
)
private long id;
```

В итоге мы можем хранить все значения для идентификаторов в одной таблице. Сколько будет сущностей, столько и строк в этой таблице. Для наглядности, она будет выглядеть примерно так:

| key (имя столбца, заданное через pkColumnName)               | value (имя столбца, заданное через valueColumnName) |
| ------------------------------------------------------------ | --------------------------------------------------- |
| `employee_id` (название идентификатора, заданное через pkColumnValue) | 5                                                   |
| `country_id`                                                 | 100                                                 |

Название идентификатора - это просто произвольная строка. Для удобства использован паттерн `имяСущности_id`.

# TODO

На стр.70 в книге Java persistence with Hibernate - Christian Bauer, Gavin King, Gary Gregory (2016) рассказывается про нативные аннотации хибера, которые позволяют сделать все то же самое, что я уже описал, но с еще дополнительными удобностями. Пока что возиться не хочется, пойду дальше. Эту же запись оставляю просто для того, чтобы знать, что такая инфа есть.







