Книга хорошая, стоит ее проработать полностью и использовать этот материал как основу, а дальше уже добивать статьями. Сюда нужно писать отчет по каждому разделу, чтобы знать, что проработано полностью, что не до конца, а что вообще нет, чтобы не возвращаться к одному и тому же по нескольку раз.

Возможно, изначально стоит писать вещи в папку с этим файлов, а уже потом думать, куда их прицеплять, т.к. у меня уже есть весьма большой конспект.

* :o: - раздел на момент чтения не воспринимается как ценный. Можно вернуться к нему позже.
* :red_circle: - чтобы понять раздел, нужно вернуться в него после прохождения другого раздела \ темы.
* :ballot_box_with_check: - раздел проработан, но есть вещи, которые можно разобрать дополнительно (альтернативные способы сделать то же самое, либо детальнее почитать про разобранное).
* :white_check_mark: раздел проработан полностью, больше из него взять нечего.



# Part 1. Getting started with ORM.

## 2 Starting a project

### 2.2 Hello world with JPA :ballot_box_with_check:

- [x] Куда класть persistence.xml и его формат.
- [x] Что такое persistence unit.
- [ ] Стр. 22 Как включить отображение запросов и логирование.





# Part 2.  Mapping strategies

## 4 Mapping persistent classes

### 4.1 Understanding entities and value types :o:

Здесь пробуют объяснить, чем отличается сущность от VO, рассказывается, что хибер имеет богатую функциональность для работы с fine-grained доменной моделью, т.е. когда классов больше чем таблиц. В целом раздел выглядит довольно запутанным и в нем нет технических деталей, только попытки объяснить на примере Покупателя, Предмета и Ставки как эти понятия можно выразить через сущности и VO.

Вывод: конспектировать особо нечего в плане технических деталей. Можно иногда перечитывать, и размышлять над примером.

### 4.2 Mapping entities with identity :ballot_box_with_check:

Рассказывается про то, как правильно выбрать первичный ключ для таблиц, про натуральные, суррогатные ключи. В целом можно конкректно об этом почитать специализированные статьи. Ценность раздела в том, что показано как замапить поле на первичный ключ и перечислены стратегии генерации значения PK. Рассказывается на примере JPA и на примере нативных аннотаций хибера.

Вывод: про основные стратегии через JPA опробовал и законспектировал. Про нативные хиберовские разбираться не стал.

### 4.3  Entity-mapping options :ballot_box_with_check:

- [ ] Стр. 76: Автоматическое квотирование всех имен, заданных через параметр name аннотаций @Table, чтобы хибер воспринимал эти имена буквально, т.е. с учетом регистра и т.д.
- [ ] Стр. 76: Настройка конвенций имен, как автоматически добавить именам префиксы и т.д.
- [x] Стр. 76: Дать сущности альтернативное имя, если в программе есть класс, имя которого совпадает с классом сущности.
- [ ] Стр. 77. Хибер-фича. Включить динамическую генерацию SQL-запросов, чтобы они подготавливались не на старте приложения, а только когда нужны. Говорят, что подробнее об этом будет в главе 17.
- [ ] Стр. 78 Хибер-фича. Иммутабельные сущности.
- [ ] Стр. 79. Хибер-фича. Сущность-представление, которая связана не с таблицей в БД, а просто заполняется в соответствии с прикрепленным запросом.

## 5 Mapping Value types

### 5.1 Mapping basic properties :ballot_box_with_check:

- [x] Стр.82: Как хибер по умолчанию трактует поля без аннотаций.
- [x] Стр.83: @Transient, сказать хиберу, что поле не надо сохранять.
- [x] Стр.83. @Column и @Basic, сказать хиберу, обязательное ли поле или нет и как его выбирать - жадно или лениво.
- [ ] Стр.84: Упоминается @MappedSuperclass и @Embedded в контексте управления способом доступа хибера к полям (field-, property-style), но говорится, что потом будет рассмотрено в отдельном разделе.
- [x] Стр.84: @Access и способы field-, property-access доступа к свойствам сущности со стороны хибера
- [ ] Стр.85: noop property accessor. Обращение к "виртуальному свойству", которое есть в таблице БД, но нет в классе сущности. Нативная хиберовская фича.
- [ ] Стр.86: @Formula, нативная хиберовская аннотация для вычисления значения какого-то столбца при загрузке сущности. Например, среднее значение чего-либо или выделить из описания предмета первое предложение и положить в сущность.
- [ ] Стр.87: @ColumnTransformer, нативная хиберовская. Позволяет при чтении из БД и перед записью трансформировать значение. Например, в БД значение лежит в милях, а в программе используются километры и поле в сущности - под километры. Так вот можно при чтении из БД сразу переводить в км и в сущности окажется значение в км. А при записи в БД км будут сначала переведены в мили. И все с помощью этой аннотации.
- [ ] Стр.88-89: @Generated и @Temporal аннотации. Показано как заставить хибер вытянуть значения, сгенерированные на стороне БД при создании \ обновлении сущности. (Значения не id, простых полей, вроде даты создания объекта). Показывается как мапить поле-дату. Чтобы законспектировать, надо дополнительно разобраться как делать функцию или тригер, которые записывали бы текущую дату в поле БД, и как их на это поле привязать. Поэтому оставил на потом.
- [x] Стр.90: @Enumerated - как замапить перечисление.

### 5.2 Mapping embeddable components :white_check_mark:

- [x] Стр.91: @Embeddable - как замапить "встроенный" класс. Допустим, в таблице клиентов есть несколько полей, отвечающих за адрес. В программе мы можем эти поля собрать в отдельный класс для удобства. Хибер при загрузке сущности "Клиент" возьмет поля БД, касающиеся адреса, и сформирует объект "Адрес", который и будет называться встроенным.
- [x] Стр.94: как переопределить значения свойств встроенного класса. Например, если в одной таблице хранится адрес домашний и адрес рабочий, и оба они используют один и тот же встроенный класс для своего представления, то для одного из них придется переопределить поля таблицы БД, на которые надо мапиться.
- [x] Стр.95: Вложенные встроенные классы. В целом законспектировал нормально, но не понял как их переопределять. Мой пример был немного не очень в целом, но тем не менее худо-бедно получилось воспроизвести фичу.

### 5.3 Mapping Java and SQL types with converters :ballot_box_with_check:

- [ ] Стр.97: Рассказывается, на основе каких критериев хибер сопоставляет Java и SQL типы. Объяснено для основных типов. Пока кажется будто нет смысла конспектировать.
- [ ] Стр.97: Примитивные и числовые типы.
- [ ] Стр.98: Char.
- [ ] Стр.99: Даты.
- [ ] Стр.100: BLOB и CLOB, работа с ними через стримы.
- [ ] Стр.103: Указание хиберу явным образом, какой стандартный адаптер использовать для поля.
- [x] Стр.103: Создание собственного конвертера.
- [x] Стр.107: Конвертирование отдельных свойств типа.
- [ ] Стр.109: Конвертирование ключей \ значений в Map.
- [ ] Стр.109: Конвертеры и @Temporal, @Enumerated, ограничения когда дело касается дат и перечислений.
- [ ] Стр.109:  Продвинутое конвертирование нативными средствами хибера.

## 6 Mapping inheritance

### Стратегии маппинга наследования :ballot_box_with_check:

- [ ] Стр.118: Подход "Table per concrete class with implicit polymorphism". @MappedSuperclass, подход "Таблица-на-класс" с неявным полиморфизмом. Возникли сложности с написанием запроса, как в книге - не работает. Нагуглить - не удалось.
- [ ] Стр.120: Подход "Table per concrete class with unions".
- [ ] Стр.122: Подход "Table per class hierarchy".
  - [ ] Стр.124: Как хибер трактует значение дискриминатора, если оно не указано.
  - [ ] Стр.125: Хибер-фича: как определить вид строки по формуле на случай, когда нет отдельного столбца под дискриминатор.
- [ ] Стр.125: Подход "Table per subclass with joins".
  - [ ] Стр.128: Эта стратегия и DiscriminatorColumn.

### 6.5 Mixing inheritance strategies :o:

todo

### 6.6. Inheritance of embeddable classes :o:

Стр.130: Хибер-фича.

### 6.7 Choosing a strategy :o:

Стр.133: Дается несколько советов как выбрать вид наследования в зависимости от типа задач, но как и во всех подобных случаев, пока не столкнешься сам, не поймешь.

### 6.8 Polymorphic associations :red_circle:

Стр.135: Сюда нужно вернуться после прохождения \ повторения раздела про связи между сущностями вроде MantyToOne, OneToMany и т.д., потому что здесь используются эти аннотации.

## 7 Mapping collections and entity assosiations

### 7.1 Sets, bags, lists, and maps of value types :ballot_box_with_check:

- [x] Стр.141: Приведен пример "Лот аукциона - Картинка" и объяснено, какие плюсы есть от мапинга коллекций.
- [x] Стр.142: Какой интерфейс и какую реализацию коллекции можно выбрать, их характеристики.
- [ ] Стр.144: Хибер-фича, создание кастомной хранимой коллекции через PersistentCollection-интерфейс. Рекомендуется только для опытных пользователей хибера.
- [x] Стр.145: Пример на мапинг Set. Показано как сделать мапинг на одно поле таблицы. В сущности Товар есть коллекция `Set<String>`, в которую выбирается из таблицы картинок только название картинки. Ценность не понятна, потому что фишка с зависимым жизненным циклом очевидно здесь не будет работать. UPD. В том-то и дело, что будет.
- [ ] Стр.146: Хибер-фича, показан "bag" - список без гарантии порядка элементов.
- [x] Стр.147: Мапинг List'а на том же примере Товар - Картинка.
- [x] Стр.148: Мапинг Map'a.
- [ ] Стр.149: Хибер-фича: сортированные коллекции.

### 7.2 Collections of components :ballot_box_with_check:

- [ ] Стр.152: Важность переопределения equals и hashCode.
- [ ] Стр.154: Set из Embedded-класса.

Забил хрен на этот раздел, нудно и не очень как будто бы и нужно.

### 7.3 Mapping entity associations :red_circle:

Этот параграф просто затравка перед следующей главой, где связи между сущностями разбираются более подробно.

Стоит прочитать этот раздел после крупного, чтобы понять, есть ли в нем что-то уникальное.

- [ ] Стр.162: Связь MtO (many-to-one) между Ставкой и Лотом, однонаправленная.
- [ ] Стр.163: Делаем связь двунаправленной. Объяснено, а нужно ли вообще делать связь двунаправленной.

## 8 Advanced entity assosiation mappings

### 8.1 One-to-one assosiations

- [ ] Стр.173: Sharing-primary-key способ организации связи, когда одна сущность генерирует id, а вторая просто берет его себе. Есть нюансы, при ленивой загрузке полученный объект как будто бы пустой, пока не начнешь обращаться к его полям. Возможно это связано с понятием прокси (но это не точно). В интернете еще как будто упоминается в этом контексте кэш первого и второго уровня хибер. Так что сюда надо вернуться и после прохождения 3 части книги :red_circle:

- [ ] Стр.176: The foreign primary key generator стратегия. Не понял вообще чем отличается от shared-key, кроме того что они попробовали сделать каскадное сохранение и двунаправленную связь. У меня не заработало. Возможно это только хибер-фича. Опять же, сюда надо вернуться после более хорошего понимания как формируется двунаправленная связь и каскадность :red_circle:

  UPD. Вроде понял. Там показывается, как с помощью хибер-фичи заставить работать каскадность для шаред-ки-стратегии. Без этой хибер-фичи каскадности добиться нельзя.

- [x] Стр.180: 11 через третью промежуточную таблицу. В целом здесь все гладко прошло, никаких тонкостей нет и все работает как ожидается.

### 8.2 One-to-many assosiations

- [x] Стр.183: 1M bag (collection + arraylist).
- [ ] Стр.184: Используется List, есть какой-то странный мапинг, не понял в чем прикол. Что-то связанное с тем, что в каком-то случае коллекция является read-only. В общем, вернуться потом сюда надо.

# Part 4. Writing queries

## 14 Creating and executing queries

По ощущениям как будто бы полностью проработано. Поскольку идея вести отчет возникла уже после проработки этого раздела, наверняка не скажу, но скорее всего оттуда все вытащено в конспект, так что если пересматривать этот раздел, то скорее всего бегло.

## 15 The query languages

Criteria API пропускал, разбирал только примеры на JPQL. Дошел до 400 страницы, дальше бросил, потому что как будто бы были ссылки на предыдущие части книги, которые я не читал и собственно поэтому и решил "начать с начала" проработку.







# Other

- [ ] @AttributeOverride - встречалось в тексте, но не встречалось отдельное объяснение. Мб поискать.