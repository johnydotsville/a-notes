Книга хорошая, стоит ее проработать полностью и использовать этот материал как основу, а дальше уже добивать статьями. Сюда нужно писать отчет по каждому разделу, чтобы знать, что проработано полностью, что не до конца, а что вообще нет, чтобы не возвращаться к одному и тому же по нескольку раз.

Возможно, изначально стоит писать вещи в папку с этим файлов, а уже потом думать, куда их прицеплять, т.к. у меня уже есть весьма большой конспект.

* :o: - раздел на момент чтения не воспринимается как ценный. Можно вернуться к нему позже.
* :ballot_box_with_check: - раздел проработан, но есть вещи, которые можно разобрать дополнительно (альтернативные способы сделать то же самое, либо детальнее почитать про разобранное).
* :white_check_mark: раздел проработан полностью, больше из него взять нечего.



# Part 1. Getting started with ORM.

## 2 Starting a project

### 2.2 Hello world with JPA :ballot_box_with_check:

- [x] Куда класть persistence.xml и его формат.
- [x] Что такое persistence unit.
- [ ] Стр. 22 Как включить отображение запросов и логирование.





# Part 2.  Mapping strategies

## 4 Mapping persistent classes

### 4.1 Understanding entities and value types :o:

Здесь пробуют объяснить, чем отличается сущность от VO, рассказывается, что хибер имеет богатую функциональность для работы с fine-grained доменной моделью, т.е. когда классов больше чем таблиц. В целом раздел выглядит довольно запутанным и в нем нет технических деталей, только попытки объяснить на примере Покупателя, Предмета и Ставки как эти понятия можно выразить через сущности и VO.

Вывод: конспектировать особо нечего в плане технических деталей. Можно иногда перечитывать, и размышлять над примером.

### 4.2 Mapping entities with identity :ballot_box_with_check:

Рассказывается про то, как правильно выбрать первичный ключ для таблиц, про натуральные, суррогатные ключи. В целом можно конкректно об этом почитать специализированные статьи. Ценность раздела в том, что показано как замапить поле на первичный ключ и перечислены стратегии генерации значения PK. Рассказывается на примере JPA и на примере нативных аннотаций хибера.

Вывод: про основные стратегии через JPA опробовал и законспектировал. Про нативные хиберовские разбираться не стал.

### 4.3  Entity-mapping options :ballot_box_with_check:

- [ ] Стр. 76: Автоматическое квотирование всех имен, заданных через параметр name аннотаций @Table, чтобы хибер воспринимал эти имена буквально, т.е. с учетом регистра и т.д.
- [ ] Стр. 76: Настройка конвенций имен, как автоматически добавить именам префиксы и т.д.
- [x] Стр. 76: Дать сущности альтернативное имя, если в программе есть класс, имя которого совпадает с классом сущности.
- [ ] Стр. 77. Хибер-фича. Включить динамическую генерацию SQL-запросов, чтобы они подготавливались не на старте приложения, а только когда нужны. Говорят, что подробнее об этом будет в главе 17.
- [ ] Стр. 78 Хибер-фича. Иммутабельные сущности.
- [ ] Стр. 79. Хибер-фича. Сущность-представление, которая связана не с таблицей в БД, а просто заполняется в соответствии с прикрепленным запросом.

## 5 Mapping Value types

### 5.1 Mapping basic properties :ballot_box_with_check:

- [x] Стр.82: Как хибер по умолчанию трактует поля без аннотаций.
- [x] Стр.83: @Transient, сказать хиберу, что поле не надо сохранять.
- [x] Стр.83. @Column и @Basic, сказать хиберу, обязательное ли поле или нет и как его выбирать - жадно или лениво.
- [ ] Стр.84: Упоминается @MappedSuperclass и @Embedded в контексте управления способом доступа хибера к полям (field-, property-style), но говорится, что потом будет рассмотрено в отдельном разделе.
- [x] Стр.84: @Access и способы field-, property-access доступа к свойствам сущности со стороны хибера
- [ ] Стр.85: noop property accessor. Обращение к "виртуальному свойству", которое есть в таблице БД, но нет в классе сущности. Нативная хиберовская фича.
- [ ] Стр.86: @Formula, нативная хиберовская аннотация для вычисления значения какого-то столбца при загрузке сущности. Например, среднее значение чего-либо или выделить из описания предмета первое предложение и положить в сущность.
- [ ] Стр.87: @ColumnTransformer, нативная хиберовская. Позволяет при чтении из БД и перед записью трансформировать значение. Например, в БД значение лежит в милях, а в программе используются километры и поле в сущности - под километры. Так вот можно при чтении из БД сразу переводить в км и в сущности окажется значение в км. А при записи в БД км будут сначала переведены в мили. И все с помощью этой аннотации.
- [ ] Стр.88-89: @Generated и @Temporal аннотации. Показано как заставить хибер вытянуть значения, сгенерированные на стороне БД при создании \ обновлении сущности. (Значения не id, простых полей, вроде даты создания объекта). Показывается как мапить поле-дату. Чтобы законспектировать, надо дополнительно разобраться как делать функцию или тригер, которые записывали бы текущую дату в поле БД, и как их на это поле привязать. Поэтому оставил на потом.
- [x] Стр.90: @Enumerated - как замапить перечисление.

### 5.2 Mapping embeddable components :white_check_mark:

- [x] Стр.91: @Embeddable - как замапить "встроенный" класс. Допустим, в таблице клиентов есть несколько полей, отвечающих за адрес. В программе мы можем эти поля собрать в отдельный класс для удобства. Хибер при загрузке сущности "Клиент" возьмет поля БД, касающиеся адреса, и сформирует объект "Адрес", который и будет называться встроенным.
- [x] Стр.94: как переопределить значения свойств встроенного класса. Например, если в одной таблице хранится адрес домашний и адрес рабочий, и оба они используют один и тот же встроенный класс для своего представления, то для одного из них придется переопределить поля таблицы БД, на которые надо мапиться.
- [x] Стр.95: Вложенные встроенные классы. В целом законспектировал нормально, но не понял как их переопределять. Мой пример был немного не очень в целом, но тем не менее худо-бедно получилось воспроизвести фичу.

### 5.3 Mapping Java and SQL types with converters :ballot_box_with_check:

- [ ] Стр.97: Рассказывается, на основе каких критериев хибер сопоставляет Java и SQL типы. Объяснено для основных типов. Пока кажется будто нет смысла конспектировать.
- [ ] Стр.97: Примитивные и числовые типы.
- [ ] Стр.98: Char.
- [ ] Стр.99: Даты.
- [ ] Стр.100: BLOB и CLOB, работа с ними через стримы.
- [ ] Стр.103: Указание хиберу явным образом, какой стандартный адаптер использовать для поля.
- [x] Стр.103: Создание собственного конвертера.
- [x] Стр.107: Конвертирование отдельных свойств типа.
- [ ] Стр.109: Конвертирование ключей \ значений в Map.
- [ ] Стр.109: Конвертеры и @Temporal, @Enumerated, ограничения когда дело касается дат и перечислений.
- [ ] Стр.109:  Продвинутое конвертирование нативными средствами хибера.

## 6 Mapping inheritance

### Стратегии маппинга наследования :ballot_box_with_check:

- [ ] Стр.118: Подход "Table per concrete class with implicit polymorphism". @MappedSuperclass, подход "Таблица-на-класс" с неявным полиморфизмом. Возникли сложности с написанием запроса, как в книге - не работает. Нагуглить - не удалось.
- [ ] Стр.120: Подход "Table per concrete class with unions".
- [ ] Стр.122: Подход "Table per class hierarchy".
  - [ ] Стр.124: Как хибер трактует значение дискриминатора, если оно не указано.
  - [ ] Стр.125: Хибер-фича: как определить вид строки по формуле на случай, когда нет отдельного столбца под дискриминатор.
- [ ] Стр.125: Подход "Table per subclass with joins".
  - [ ] Стр.128: Эта стратегия и DiscriminatorColumn.

### 6.5 Mixing inheritance strategies

todo

### 6.6. Inheritance of embeddable classes

todo

### 6.7 Choosing a strategy

todo

### 6.8 Polymorphic associations







# Part 4. Writing queries

## 14 Creating and executing queries

По ощущениям как будто бы полностью проработано. Поскольку идея вести отчет возникла уже после проработки этого раздела, наверняка не скажу, но скорее всего оттуда все вытащено в конспект, так что если пересматривать этот раздел, то скорее всего бегло.

## 15 The query languages

Criteria API пропускал, разбирал только примеры на JPQL. Дошел до 400 страницы, дальше бросил, потому что как будто бы были ссылки на предыдущие части книги, которые я не читал и собственно поэтому и решил "начать с начала" проработку.







# Other

- [ ] @AttributeOverride - встречалось в тексте, но не встречалось отдельное объяснение. Мб поискать.