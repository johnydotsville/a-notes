



# inner join

Делается немного нетипично - при соединении указывается не вторая сущность, а поле первой сущности, которое на нее указывает, а on вообще не нужен (команда on есть, но используется, с виду, как where, поэтому не пишу ее сюда):

```xml
<named-query name="get_country_cities">
    <query>
        select ct City
        from johny.dotsville.domain.entities.City ct
            inner join ct.country cr  <!-- Здесь имя поля, а не класса -->
        where cr.name = :name
    </query>
</named-query>
```

```java
public class City {
    ...
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)
    @JoinColumn(name = "country_id", nullable = false)
    private Country country;
    ...
}
```

## Соединение нескольких сущностей

Задача "Выбрать все жанры, в которых снимался заданный актер":

```xml
<named-query name="get_actor_genres" >
    <query>
        select fc.category from johny.dotsville.domain.entities.FilmCategory fc
        inner join fc.film f
        inner join f.filmActor fa
        where fa.id.actorId = :actorId
        order by fc.category.name
    </query>
</named-query>
```

```java
public void printActorsGenres(long actorId) {
    TypedQuery<Category> tqry = manager
        .createNamedQuery("get_actor_genres", Category.class)
        .setParameter("actorId", actorId);
    List<Category> categories = tqry.getResultList();
    for (Category cat : categories) {
        System.out.println(cat.getName());
    }
}
```

Cуть такова, что мэпинг у нас уже есть - в сущностях, и там уже указано, по каким полям БД они друг с другом соединяются. Поэтому в inner join мы просто указываем *поле* одной сущности, которое содержит объект (или коллекцию объектов) второй сущности, с которой мы хотим соединиться. Фрагменты классов для наглядности:

```java
public class FilmCategory {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", insertable = false, updatable = false)
    private Category category;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "film_id", insertable = false, updatable = false)
    private Film film;
...
public class Film {
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "film")
    private Set<FilmActor> filmActor = new HashSet<>();
...
public class FilmActor {
    @EmbeddedId
    private Id id = new Id();
    ...
    @Setter @Getter
    public static class Id implements Serializable {
        @Column(name = "actor_id")
        private long actorId;
```

Использовать JPQL для составления сложных запросов с соединениями на данных момент мне кажется извращением. Для этого куда удобнее использовать нативные запросы.