# Встроенные классы

Встроенные (embeddable) классы используются, когда, например, два Java-класса хранятся в БД в одной таблице. Обычно это речь про Value-Object'ы. Например, адрес, имя - все это можно представить отдельным объектом на стороне ООП, но при этом бывает нет смысла хранить это в отдельной таблице. Разберем на примере сущности актера и его имени:

* Встроенный класс отмечаем аннотацией @Embeddable, поля мапим как обычно через @Column.
* Таблицу указываем только в "содержащем" классе и для пользования встроенным классом надо всего лишь объявить поле этого типа, дальше все происходит автоматически.
* Встроенный класс существует столько же, сколько и содержащий, не имеет собственного id и в общем не является самостоятельным.
* Важно переопределить методы equals и hashCode у встроенного класса.
* Можно делать встроенные классы во встроенных классах и т.д. Степень вложения не ограничена.

Имя, встроенный класс:

```java
@Embeddable  // <-- Основное
public class Name {
    @Column(name = "first_name", nullable = false)
    private String firstName;
    @Column(name = "last_name", nullable = false)
    private String lastName;

    protected Name() {
    }

    public Name(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() ...
    public void setFirstName(String firstName) ...
    public String getLastName() ...
    public void setLastName(String lastName) ...

    @Override
    public boolean equals(Object o) {
        Name name = (Name) o;
        return Objects.equals(firstName, name.firstName) && Objects.equals(lastName, name.lastName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(firstName, lastName);
    }
}
```

Актер, содержит имя:

```java
@Entity
@Table(name = "actor")
@AttributeOverride(name = "id", column = @Column(name = "actor_id"))
public class Actor extends AbstractEntity {
    private Name name;  // <-- Всего-то объявляем поле типа embedded-класса

    public Actor() {
        super();
    }

    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object that) {
        if (!super.equals(that)) return false;

        Actor actor = (Actor) that;
        return Objects.equals(name, actor.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), name);
    }
}
```

```java
Actor actor = new Actor();
actor.setName(new Name(firstName, lastName));

System.out.println("Пытаемся сохранить актера");
manager.getTransaction().begin();
manager.persist(actor);
manager.getTransaction().commit();
...
Actor actor = manager.find(Actor.class, actorId);
System.out.println(String.format("%s %s", actor.getName().getFirstName(), actor.getName().getLastName()));
```

# null'ы во встроенном объекте

Если у встроенного объекта поля равны null и мы его сохраняем, то если БД допускает null в соответствующих столбцах, хибер сохранит объект нормально. Но при загрузке встроенного объекта, если в полях БД лежат null'ы, хибер не создаст объект, а вернет null. На примере имени актера: можно сохранить актера, у которого в Name поля имени и фамилии равны null, но если мы попробуем потом загрузить этого актера, то объект Name создан не будет, хибер вернет вместо него null. Т.е. имеется ввиду, что вместо объекта Name с полями имя, фамилия == null, мы получим null вместо самого объекта Name.