# Уточнение имен

Если не указывать имена сущностей, таблиц, колонок, тогда хибер делает предположения об их именах автоматически. Для явного управления именами существуют специальные аннотации с параметрами.

# @Entity

Этой аннотацией помечается класс, который представляет сущность. Хибер использует имя класса, чтобы можно было в JPQL-запросах писать короткое имя вместо полного, например:

```sql
select e from Employee e  -- Короткое
select e from com.example.domain.Employee e  -- Полное, с пакетом
```

Если в программе будет другой класс с таким же именем, они могут конфликтовать. Поэтому с помощью параметра `name` аннотации `@Entity` можно задать имя сущности, которое хибер будет использовать для запросов:

```java
@Entity(name = "sotr")  // <-- Явно даем сущности имя для использования в JPQL
public class Employee {
    ...
}
```

Теперь в запросах вместо Employee можно использовать уникальное имя sotr:

```sql
select e from sotr e
```

Регистр имеет значение.

# @Table

Это аннотация уровня класса, которая явно указывает хиберу, к какой таблице БД привязан класс. Имеет несколько параметров:

* `name` - для явного указания имени связанной таблицы.
* `schema` - если таблица находится не в дефолтной схеме, можно явно указать, в какой именно.
* `catalog` - TODO

Если аннотацию не указывать, то по умолчанию хибер предполагает, что таблица называется так же как и класс, без учета регистра. Если класс называется Employee, хибер будет искать таблицу employee. Явно укажем таблицу и схему:

```java
@Entity
@Table(name = "empl", schema = "domain")  // <-- В БД таблица называется empl и находится в схеме domain
public class Employee {
    ...
}
```

# @Column

Это аннотация уровня поля, которая явно указывает хиберу, с какой колонкой таблицы связано поле класса. Имеет несколько параметров:

* `name` - для явного указания колонки.
* TODO там еще много параметров, похожи на ограничения, вроде длины, уникальности и т.д.

```java
...
public class Employee {
    @Column(name = "sal")  // <-- В БД колонка называется sal
    private int salary;
}
```

# Учет регистра в именах

По умолчанию регистр в именах, указанных в аннотациях @Table, @Column не учитывается. Т.е., если написать `@Table(name = "Employee")`, то хибер будет искать в БД таблицу employee, а не Employee. Соответственно, если таблица в БД действительно начинается с большой буквы, хибер ее не найдет.

Для указания точного имени с учетом регистра, пробелов и т.д. используется квотирование:

* ``@Table(name = `Employee`)`` - апостроф это для хибера нативный способ указать точное имя.
* `@Table(name = "\"Employee\"")` - кавычки это JPA-совместимый способ, предпочтительно использовать именно его.

```java
@Entity(name = "sotr")
@Table(name = "\"Employee\"")  // <-- Теперь хибер будет искать таблицу Employee, а не employee
public class Employee {
    ...
}
```

В разных СУБД используются разные символы для квотирования, `[]` в SQL Server, `''` в MySQL, `""` в H2 и т.д. Но хибер об этом знает и при генерации запросов автоматически подставит нужные символы.

TODO: c76 - показано, как включить автоматическое квотирование на все сущности через xml-настройку. Там сказано, надо положить настройку в файл orm.xml, тогда хибер должен найти ее автоматически. А можно написать ее в отдельном файле и подключить в PU. В общем, пока это не выглядит как киллер-фича, так что оставлю на потом. Дописать сюда, когда оформлю конспект по файлу persistence-unit.