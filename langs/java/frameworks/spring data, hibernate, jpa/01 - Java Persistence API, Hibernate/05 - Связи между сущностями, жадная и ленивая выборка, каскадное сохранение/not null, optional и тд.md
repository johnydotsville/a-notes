### Двунаправленная

```java
@Table(name = "city")
public class City {
    @ManyToOne
    @JoinColumn(name = "country_id", nullable = false)  // <-- nullable = false
    private Country country;
}
```

Через параметр nullable обозначили, что поле country обязательно должно быть заполнено. Тут надо понимать, что это ограничение работает именно на программной стороне, а не на стороне БД и они взаимно не связаны.

Например, если в БД стоит ограничение not null на это поле, а в программе - не стоит, то программа попытается сохранить город с пустым полем country и мы получим ошибку от СУБД. А если в БД такого ограничения нет, а в программе - есть, то уже программа не позволит нам сохранить город с незаполненной страной, хотя в БД это будет вполне законно.

```java
@Table(name = "country")
public class Country {
    @OneToMany(mappedBy = "country")
    private Set<City> cities = new HashSet<>();
}
```

Начинаем думать аналогично как в однонаправленной, а когда мапим класс Country, думаем так:

* С одной страной может быть связано много городов
* Значит, между country - city связь 1М => используем аннотацию @OneToMany
* В таблице БД country нет столбца, который бы указывал на город
* Значит, мы не можем пользоваться @JoinColumn'ом и указать столбец, по которому надо связаться с парной таблицей
* => нужно использовать параметр mappedBy аннотации @OneToMany и указать в нем *поле класса* парной таблицы, которое содержит мэппинг

Двунаправленную связь М1 можно тоже делать через промежуточную таблицу в случае, если в столбце со ссылкой нежелателен null. Например, если мы проектируем аукцион, то у Лота будет ссылка на Владельца. Но пока Лот не купили, он будет лежать в БД с null'ом в этой ссылке. Если же мы сделаем через промежуточную таблицу, то null не будет, поскольку поле Владельца уйдет из таблицы Лота в эту промежуточную таблицу.