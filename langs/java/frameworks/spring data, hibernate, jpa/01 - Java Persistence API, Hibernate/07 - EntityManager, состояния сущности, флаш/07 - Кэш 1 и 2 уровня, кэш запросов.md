# Кэш первого уровня

## Как выглядит технически

Кэш первого уровня представляет собой мапу `Map<EntityUniqueKey, Object>`, где ключ выглядит примерно так:

```java
public class EntityUniqueKey implements Serializable {
 
    private final String entityName;     
    private final String uniqueKeyName;
    private final Object key;   
    private final Type keyType;
    ...
}
```

Эта мапа хранится в контексте. Т.о., кэш первого уровня всегда привязан к конкретному экземпляру контекста. Закрываем контекст - исчезает и кэш.

## Как работает

Кэш работает следующим образом: когда мы выбираем какую-то сущность, хибер сначала проверяет, нет ли ее в кэше. Если есть, он возвращает объект из кэша. Если нету, тогда он делает запрос в БД, формирует на основе пришедших данных объект сущности и помещает его в кэш.

Независимо от способа выборки сущности (например через метод `.find` или `.createQuery`) хибер делает проверку в кэше. Как это выглядит?

Например, через метод *.find*:

```java
var lang = new Lang();
lang.setName("Вьентамский");

EntityTransaction tx = em.getTransaction();
tx.begin();

em.persist(lang);  // <-- Новая сущность добавлена в кэш 1 уровня, но в БД ее пока нет.

var l = em.find(Lang.class, lang.getId());  // <-- Хибер найдет ее в кэше, без обращения к БД.

tx.commit();  // <-- Вот теперь новая сущность улетела в БД.
```

Через метод *.createQuery*:

```java
var l = em.find(Lang.class, 32);
var allLangs = em.createQuery("select l from Lang l", Lang.class).getResultList();
```

Когда мы в первой строке ищем сущность, она загружается из БД и попадает в кэш. Допустим, мы нашли вьетнамский язык по id 32. Во втором запросе, когда мы выбираем все языки (пусть там будут русский, английский и вьетнамский), происходит следующее:

* Хибер выбирает все записи из БД из таблицы языков.
* Он обходит полученные строки, из каждой формирует сущность и помещает ее в кэш.
  * Однако перед тем как создать новый объект, он проверяет, а нет ли уже такого объекта в кэше.
  * Если есть, то новый объект не создается, а возвращается уже существующий.
  * Т.о. во втором запросе реально будут созданы только два объекта - для русского и английского языков, а для вьетнамского - нет.

Механизм кэширования отключить нельзя. Он гарантирует следующее:

* В пределах одного unit of work одна и та же строка БД будет выглядеть одинаково, т.е. контекст дает repeatable read гарантию (guaranteed scope of object identity). Как раз за счет того, что как бы мы ни добывали сущности, хибер всегда проверит, нет ли их в кэше.
* Любые изменения, внесенные в сущность в пределах одного unit of work, видны всем операциям, которые работают в этом же unit of work.

# Кэш второго уровня

Кэш второго уровня - это кэш уровня фабрики. По умолчанию отключен и хибер не реализует его. Чтобы пользоваться, нужно подключать и настраивать стороннюю реализацию.

# Кэш запросов

По умолчанию тоже отключен, работает совместно с кэшем второго уровня вроде бы.

TODO: вернуться к темам кэширования позже, https://habr.com/ru/articles/135176/