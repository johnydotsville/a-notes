# Зачем мапить коллекции

Мапинг коллекций - это дополнительная возможность, имеющая некоторые удобства. Но при этом она не является обязательной. Все, что можно сделать с помощью мапинга коллекций, можно сделать через запрос. Например, вытянуть все изображения товара.

Удобства от мапинга коллекций:

* Автоматическое вытягивание связанных записей из БД при обращении к полю-коллекции.
* Жизненный цикл связанных записей связан с основной записью:
  * Если добавить в поле-коллекцию Изображение и сохранить Товар, то изображения тоже сохранятся в БД. Без мапинга коллекции пришлось бы отдельно сохранять изображения.
  * При удалении Товара также удаляются и все связанные с ним Изображения. Без маппинга коллекции пришлось бы удалять изображения отдельно.

Личные замечания (могут быть неверными, правильность не гарантирую):

* Такое ощущение, что в разделе *7 Mapping collections and entity assosiations* книги *Java persistence with Hibernate - Christian Bauer, Gavin King, Gary Gregory (2016)* речь идет маппинге коллекций не-сущностей. Т.е. мапинг, разобранный в этом разделе может быть полезен, когда с сущностью связан какой-то набор данных, элементы которого сами не являются сущностями. Вот тут https://itsobes.ru/JavaSobes/kakaia-raznitsa-mezhdu-elementcollection-onetomany-i-manytomany/ как будто схожая мысль.

  Например, `Товар` и `Изображение товара`. Изображение - это таблица БД с двумя полями - id товара и имя файла изображения. Теоретически, можно было бы оформить Изображение как отдельную сущность. Тогда пришлось бы давать ей id, создавать для нее генератор, отдельный класс в программе, мапить его. С другой стороны, если воспользоваться знаниями из этой самой главы 7, можно сделать проще - добавить в сущность Товар коллекцию вроде `Set<String>` и просто загрузить названия файлов в множество. При добавлении \ удалении в множество имени файла и сохранении Товара, эти имена тоже будут сохраняться в таблицу Изображения товара. Т.е. мы получаем желаемое поведение, не вводя в программу лишний класс сущности.

  Пока применимость "мапинга коллекций" мне видится именно так. Все в этом разделе будет написано, исходя из этой мысли. Коллекции, в которых находятся сущности, работают как будто похожим образом, но подробнее об этом будет в конспекте по мапингу связей.

# Хранимые коллекции

Хибер имеет обертки для всех популярных Java-коллекций. Нам нужно только правильно выбрать пару "интерфейс-реализация" стандартных Java-коллекций, в зависимости от нужных нам свойств, а дальше хибер сделает все автоматически - подменит реализацию своей или обернет.

Пара рекомендаций:

* Рекомендуется инициализировать коллекции сразу, т.е. объявили поле и тут же выделили память.
* Лучше пользоваться generic-коллекциями.

Характеристики стандартных коллекций (формат `интерфейс : реализация`, все они лежат в пакете `java.util`):

* Set
  * HashSet
    * Порядок элементов не гарантирован.
    * Дублирующихся элементов нет.
    * Поддерживают все JPA-провайдеры.
* SortedSet
  * TreeSet
    * Порядок элементов гарантирован. Сортировка происходит в памяти, после того как хибер загрузил данные из БД.
    * Дублирующих элементов нет.
    * Хибер-фича, другие провайдеры могут игнорировать требование сортировки.
* List
  * ArrayList
    * Позиция элементов защищена (с помощью дополнительного столбца индекса в БД). TODO: вероятно имеется ввиду, что элементы оказываются в списке в том же порядке, в котором они сохранены в БД.
    * Поддерживают все провайдеры.
* Collection
  * ArrayList
    * Дублирующиеся элементы возможны.
    * Порядок элементов не гарантирован.
    * Поддерживают все провайдеры.
    * Еще носит название "bag". Имеет наилучшую производительность, потому что ей не нужно следить ни за отсутствием дубликатов, ни за порядком элементов.
      * Когда мы добавляем элемент в bag, хиберу не обязательно загружать коллекцию из БД.
* Map
  * HashMap
    * The key and value pairs of a map can be preserved in the database. TODO: не понятна такая формулировка вообще.
    * Поддерживают все провайдеры.
* SortedMap
  * TreeMap
    * Порядок элементов гарантирован. Сортировка происходит в памяти, уже после загрузки данных из БД.
    * Хибер-фича, другие провайдеры могут игнорировать требование сортировки.
* Хранимые массивы
  * Хибер поддерживает persistent array, однако это отдельная тема и в целом ими пользуются редко.

P.S. Если пользоваться лобком, то только для геттеров и сеттеров. Лучше не полагаться на его реализацию хэша и равенства, иначе косяки могут вылезти на ровном месте. Например, я использовал в примерах HashSet для хранения коллекций и из-за кривой лобковой реализации у меня список городов в стране не заполнялся и я далеко не сразу понял, в чем дело.