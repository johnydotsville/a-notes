Вообще там оказалось довольно много настроек и всяких штук. Я сначала пытался разобраться по-полной, но потом понял, что это слишком дорого и поэтому для начала решил ограничиться минимальным функционалом, который мне нужен уже сейчас. Поэтому в начале будет практичная эссенция, а дальше уже отрывки из документации, которые удалось понять. Пусть будут на всякий случай, если вдруг придется когда-нибудь копать дальше.

TODO:

- [ ] Настройка расположения файла с логами. Чтобы он появлялся, например, в той же папке, откуда запущена jar-программа.

# Log4j2 зависимости

Нам понадобятся две зависимости (сценарий без использования спринга):

* log4j-api - содержит интерфейсы логгера
* log4j-core - содержит реализацию

```xml
<properties>
    <log4jversion>2.17.2</log4jversion>
</properties>

<dependencies>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>${log4jversion}</version>
        <scope>compile</scope>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>${log4jversion}</version>
    </dependency>
</dependencies>
```

# Способы конфигурации

Конфигурировать логгер можно двумя способами: через файл конфигурации (предпочтительный способ, согласно документации) и программно. В простом случае конфиг можно положить в папку resources.

Файл конфигурации может быть в четырех форматах (в скобках указано имя, которое требуется дать файлу конфига, чтобы фреймворк смог его найти):

* property-стиль (log4j2.properties)

* yaml (log4j2.yaml)

* json (log4j2.json)

* xml (log4j2.xml)

Фреймворк отдает приоритеты соответствуют перечисленному порядку, т.е. если он найдет .properties-файл, дальше уже не будет искать.

Конфигурация обычно происходит на старте приложения. Если фреймворк не сможет найти файл с конфигурацией, он примет конфигурацию по умолчанию и логирование будет только в консоль, а уровень событий только ERROR и FATAL.

# Пример конфигурации

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <!-- Секция свойств -->
    <!-- Секция аппендеров -->
    <!-- Секция логгеров -->
</Configuration>
```

`Configuration status="WARN"` - это настройка для отображения внутренних сообщений фреймворка. Если выставить debug или trace, тогда в консоль будут выводиться эти самые внутренние сообщения. Может пригодиться, когда фреймворк не работает так как надо.

Пример таких сообщений:

```
2022-05-23 11:39:02,682 main DEBUG PluginManager 'Core' found 127 plugins
2022-05-23 11:39:02,684 main DEBUG PluginManager 'Level' found 0 plugins
2022-05-23 11:39:02,715 main DEBUG PluginManager 'TypeConverter' found 26 plugins
2022-05-23 11:39:02,725 main DEBUG createProperty(name="logfilename", value="E:/tmp/test.log", value="E:/tmp/test.log")
```

## Секция свойств

В секции свойств мы можем объявить какие-нибудь переменные, задать им значения, а потом использовать эти переменные в конфиге. Удобно задавать различные константы вроде путей сохранения логов:

```xml
<Properties>
    <Property name="logfilename">E:/tmp/test.log</Property>
</Properties>
```

Использование: `${propName}`

## Секция аппендеров

```xml
<Appenders>
    <Console name="KonsoleLog" target="SYSTEM_OUT">
        <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
    <File name="FileLog" filename="${logfilename}">  <!-- Используем переменную из секции свойств -->
        <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </File>
</Appenders>
```

Аппендеры непосредственно занимаются добавлением события в конечную точку - консоль, файл, сеть, БД и т.д. Видов аппендеров довольно много, здесь показаны два самых простых - консольный и файловый. Тип аппендера определяется самим элементом `<Console>` - консольный, `<File>` - файловый и т.д.

Можно описать столько аппендеров, сколько нужно. Например, объявить несколько аппендеров, пишущих в разные файлы. Потом эти аппендеры можно использовать в конкретных логгерах.

Через `<PatternLayout>` задается форматирование для каждой записи в логе. Про синтаксис форматирования есть отдельный раздел.

## Секция логгеров

```xml
<Loggers>
    <Logger name="johny.dotsville" level="trace" additivity="false">
        <AppenderRef ref="FileLog"/>
    </Logger>
    <Logger name="johny.dotsville.bar" level="trace" additivity="true">
        <AppenderRef ref="KonsoleLog"/>
    </Logger>
    <Root level="error">
        <AppenderRef ref="KonsoleLog"/>
    </Root>
</Loggers>
```

На самом деле здесь описываются не логгеры, а объекты типа LoggerConfig, о которых можно почитать в разделе про архитектуру. Но для простоты можно думать о них как о конкретных логерах.

Настройки:

* `<AppendersRef ref="appenderName"/>`

  Указывает, какие аппендеры будут срабатывать при поступлении запроса на логирование от этого логгера. Можно в один логгер добавить несколько аппендеров, чтобы логирование разом происходило в несколько конечных точек.

* `name="johny.dotsville.bar"`

  Имя логера имеет важное значение, потому что позволяет фреймворку найти настройки для создаваемого объекта логера. Когда в каком-то классе мы запрашиваем логгер, то фреймворк смотрит на пакет этого класса и ищет ближайшее подходящее имя логгера. Например:

  ```java
  package johny.dotsville.bar;  // <-- Пакет, в котором лежит наш класс, пользующийся логированием
  
  import org.apache.logging.log4j.Logger;
  import org.apache.logging.log4j.LogManager;
  
  public class SomeClass {
      private static final Logger logger = LogManager.getLogger(SomeClass.class);  // <-- Требуем логгер
      
      public static void main(String[] args) {
          logger.info("Сообщение уровня info");
      }
  }
  ```

  Класс SomeClass находится в пакете johny.dotsville.bar, значит его полное имя johny.dotsville.bar.SomeClass и в конфиге у нас описан логгер с именем johny.dotsville.bar. Значит, когда мы в SomeClass запросим логгер, он получит эти настройки. 

  Имя ищется не точь-в-точь, а максимально похожее. Т.е. если мы запросим логгер в пакете johny.dotsville.bar.need.more, то он тоже получит настройки johny.dotsville.bar (если мы конечно не напишем дополнительные настройки для, например, johny.dotsville.bar.need)

  Логгер с конкретным именем создается единожды и потом используется повторно.

  Как правило, логгер помещается в static final поле. Когда мы запрашиваем логгер, мы должны указать его имя. Стандартной практикой является имя такое же как полное имя класса, который пользуется логгером. Во-первых, так в лог можно легко залогировать для наглядности имя класса, который породил запись, а во-вторых, такое имя делает удобным персональную настройку логгеров. Можно просто написать `LogManager.getLogger();` и фреймворк автоматически возьмет полное имя класса, но для наглядности я все же написал полностью.

* `level="trace"`

  Через level задаем уровень событий, которые хотим логировать. Уровни логирования по возрастанию "степени важности": `ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL`. Это значит, если задать уровень логгирования DEBUG, то будут записываться логи DEBUG и более важные, т.е. INFO, WARN, ERROR, FATAL.

* `additivity` - важный и интересный параметр. Дело в том, что логгеры образуют иерархию в зависимости от своих имен. И additivity true означает фактически "залогировать полученное сообщение текущим логгером, и логгерами, которые выше него по иерархии". Так что при такой конфигурации:

  ```xml
  <Logger name="johny.dotsville" level="trace" additivity="false">
      <AppenderRef ref="FileLog"/>
  </Logger>
  <Logger name="johny.dotsville.bar" level="trace" additivity="true">
      <AppenderRef ref="KonsoleLog"/>
  </Logger>
  ```

  если мы воспользуемся логгером johny.dotsville.bar, то фактически получим две записи - в консоль и в файл. Если же поставим additivity false, тогда залогируется только в консоль.

  Тут важно понимать, что этот параметр не блокирует работу логгеров, находящихся выше, а именно определяет, пойдет ли сообщение, полученное текущим логгером, также и в логгеры выше. Все сообщения, которые мы будем писать непосредственно с помощью johny.dotsville будут появляться в файле. 

* `Root` - корневой логгер. Он должен присутствовать обязательно. Фактически, если не нужны разные логгеры с отдельными настройками, то можно указать только корневой логгер, и написать туда все точки, в которые нужно логгировать.

# Паттерн записи лога

Дефолтный формат лога:

```
%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n
15:07:36.280 [main] ERROR johny.dotsville.App - Ошибок нет, но в лог запишем
```

* `%d` - дата.
* `%t` - имя потока.
* `%-5level` - метка уровня логгирования. 5 означает сколько символов отводится под нее. Например, при значении 10, после ERROR получится еще 6 пробелов и потом уже будет johny.dotsville.App, потому что ERROR это 5 позиций, +еще 5 до 10, и потом еще 1 обязательный пробел.
* `%logger{36}` - имя логгера, а 36 - ограничение длины имени до 36 символов (правда у меня не получилось на практике увидеть отличия при изменении этого параметра).
* `%msg` - сообщение.
* `%n` - перевод строки.

# Параметризация сообщений

В зависимости от настроек не все сообщения попадают в лог. Если в сообщении есть параметры, их много и они сложные (например, какие-нибудь манипуляции с датами), тогда мы потратим время на вычисление конечного сообщения, а оно в итоге может даже не пройти фильтры и не попасть в лог.

Поэтому имеет смысл параметризировать сообщения. В этом случае фреймворк выполняет фактическое вычисление сообщения только тогда, когда достоверно известно, что оно должно попасть в лог:

```java
public static void main(String[] args) {
    String name = "JohNy";
    logger.info("Сообщение уровня info: {}", name);
}
```

# Термины (log4j)

Многое взято отсюда https://logging.apache.org/log4j/2.x/manual/architecture.html

<img src="img/image-20220520154525979.png" alt="image-20220520154525979" style="zoom:80%;" />

* Appender - событие может быть записано в файл, выведено в консоль или еще как-то обработано. Вот за эти конкретные способы, что делать с событием, и отвечают аппендеры. Один аппендер может выводить в консоль, другой аппендер - писать в файл. Два аппендера могут работать одновременно, чтобы событие у нас и выводилось в консоль, и писалось в файл. Аппендеры, насколько я понял???, связаны с LoggerConfig, а LoggerConfig'и могут образовывать наследственные цепочки и событие уходит не только в аппендер, так сказать, "текущего" LoggerConfig'а, то но и в аппендеры, которые указаны в родительском LoggerConfig'е текущего LoggerConfig'а.

* LoggerContext - это опорная точка системы логирования. ??? В зависимости от обстоятельств может быть несколько контекстов, но наверное это нечастое явление. Хотя вот цитата из доки "Every LoggerContext has an active Configuration", т.е. получается их как будто реально несколько.

  ??? Контекст содержит (maintains) список всех логгеров, запрошенных приложением, а также имеет ссылку на конфигурацию (Configuration, и похоже это не то же самое что LoggerConfig).

* Configuration - содержит фильтры (Filter 0..*, что бы это ни было), аппендеры, ну на картинке видно что там есть вообще. Как видно, похоже, объект конфигурации всегда один. Видать тот, который из xml генерируется. Пишут, что когда происходит реконфигурация, то существует два объекта Configuration - старый и новый. И только когда все логгеры переключатся на новую конфигурацию, только тогда удаляется старый объект конфигурации. Еще бы знать, что такое реконфигурация? Это когда просто поменяли какие-то настройки или что?

* Logger - сам по себе напрямую действий не выполняет. ??? Хотя не понятно, как так не выполняет? У него есть методы debug и прочие. Он имеет имя и связан с LoggerConfig.

* LoggerConfig - создается, когда в Configuration объявляются логгеры. Т.е. насколько я понял, если в конфигурационном файле мы объявим несколько логгеров (там вроде ведь было что-то такое???), то у нас будет такое же количество и LoggerConfig'ов. В LoggerConfig содержит набор фильтров, те самые, которые пропускают или не пропускают сообщения разных уровней (DEBUG, INFO, WARN, ERROR и т.д.) к собственно аппендерам.

* Filter - это дополнительное средство, позволяющее пропустить\запретить записать событие в лог. Надо смотреть на практике, но суть в том, что грубо говоря событие проверяется на разных этапах. Например, согласно уровню логгирования в LoggerConfig - тут оно может не пройти по уровню. Потом оно может попасть в аппендер и насколько я понял ??? там тоже может быть заблокировано. А фильтры - это еще дополнительные к этим методы проверки. Есть фильтры, которые выполняются до того как событие попадет к проверке в LoggerConfig; есть фильтры, которые срабатывают после LoggerConfig, но до попадания ко всем аппендерам; есть которые срабатывают после LoggerConfig, но до конкретного аппендера; после LoggerConfig и во время каждого аппендера. Что-то такое короче. Ну и каждый фильтр может вернуть одно из трех решений: Accept, значит событие считается нормальным и другие фильтры не должны его проверять (??? ну допустим фильтры не должны, а LoggerConfig например должен?). Deny - значит событие считается заблокированным. Neutral - значит фильтр не решил, блокировать или разрешать событие, и его должны проверить другие фильтры.



# Некоторые факты

* ConfigurationFactory - ??? это плагины, предназначенные для чтения конфигурации. Log4j комплектуется четырьмя: для чтения из XML, JSON, YAML и Property-стиля.

  Каждый вариант ведет к созданию объекта конфигурации. Когда происходит автоконфигурация, log4j вызывает каждую фабрику и она пытается найти конфигурационный файл соответствующего себе формата в classpath. И если находит, то создает по нему объект конфигурации. Порядок поиска и как должен называться файл конфига: log4j2.properties, log4j2.yaml, log4j2.json, log4j2.xml

* Плюсы логирования над обычным sout в том, что можно переключаться между уровнями логирования и таким образом логировать только то, что нужно, а не все подряд. При этом исходных код изменять не приходится. Например, раскидываем по коду logger.debug, logger.error и пока разрабатываем, ставим уровень debug и получаем подробное логирование. Когда все написали, проверили и выложили например на прод, выставили в опциях уровень логирования error и у нас уже строчки logger.debug не срабатывают.

  Такой механизм включения\отключения в Log4j версий 1.х реализовывался через отношения между объектами Logger. А в версиях 2.х - через отношения между объектами LoggerConfig. Это позволяет отвязать конкретный объект логгера от настройки того, какой уровень он должен логгировать. В итоге несколько логгеров могут использовать один LoggerConfig. ??? Ну тут прикол скорее всего в какой-то автоматизации, т.е. LoggerConfig по каким-то правилам заполнится и сразу несколько логгеров получат эти настройки

  

