

# JWT

## Состав токена

JWT (Json Web Token) выглядит примерно так:

```java
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJKV1Qgc3R1ZHlpbmciLCJuYW1lIjoiSm9oTnkgRG90c3ZpbGxlIiwiaWF0IjoxNTE2MjM5MDIyfQ.jTvIgjvPJtbJ1h17GCFhzFecNv882nS0dlhZKbr1Xp4
// Сгенерировано на https://jwt.io/
```

В нем три элемента, разделенных точками:

* Заголовок (header)
* Нагрузка (payload)
* Подпись (signature)

Заголовок и нагрузка - это строки в формате JSON, закодированные через Base64.

> Base64 использует для кодирования любой информации набор из 64 символов - латинские буквы, цифры и два дополнительных символа. Так что даже "странные" символы в итоге превращаются во вполне съедобные.

*Кодирование* - это не *шифрование*. Кодирование подразумевает просто перевод информации из одного вида в другой. Соответственно, закодированную инфу можно легко раскодировать обратно. Например, заголовок и нагрузку из этого токена можно отдать любому кодировщику (нарпимер https://base64-encode.online/) и посмотреть, что в них лежит:

```json
// Заголовок: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
{
  "alg":"HS256",
  "typ":"JWT"
}
```

```json
// Нагрузка: eyJzdWIiOiJKV1Qgc3R1ZHlpbmciLCJuYW1lIjoiSm9oTnkgRG90c3ZpbGxlIiwiaWF0IjoxNTE2MjM5MDIyfQ
{
  "sub": "JWT studying",
  "name": "JohNy Dotsville",
  "iat": 1516239022
}
```

В токенах не передают никаких секретных данных, поэтому шифровать эти данные смысла нет. Шифруется (точнее не шифруется, а *хэшируется*) только подпись и за счет нее приложения могут отличить настоящий токен от поддельного.

## Формирование токена

* Заголовок и нагрузка кодируются через Base64.
* Потом они конкатенируются, разделитель - точка `.`
* Полученная строка *хэшируется* тем же алгоритмом, что указан в хедере, и так получается подпись.
* Все три компонента соединяются через `.` в одну строку и получается токен.

При хэшировании используется *секрет* - строка, известная только сервису, выдающему токены, и сервисам, которые токенами пользуются (TODO: ??? уточнить потом, так ли это). Вызов функции хэширования выглядит примерно так:

```java
HMACSHA256(  // <-- Криптофункция
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  "QeShVmYq3t6w9z$C&F)J@NcRfUjWnZr4"  // <-- Секрет
)
// На выходе получается подпись:
// jTvIgjvPJtbJ1h17GCFhzFecNv882nS0dlhZKbr1Xp4
```

Секрет генерировался тут: https://allkeysgenerator.com/Random/Security-Encryption-Key-Generator.aspx

# Механика работы токенов

## Access и Refresh токены

TODO: ??? отредактировать этот раздел, когда точнее узнаю что к чему.

В механизме авторизации через токены обычно используется два вида токенов:

* access token

  Многоразовый, живет мало (от нескольких минут до нескольких дней). Используется непосредственно для получения *доступа* к защищенным ресурсам.

* refresh token

  Одноразовый, живет долго (например, неделю, месяц), должен надежно храниться. Используется для получения новой пары access token + refresh token ("обновления" AT).

Пользователь отправляет запрос со своим логином и паролем сервису аутентификации. Тот генерирует два токена - AT и RT. AT отправляет клиенту, а RT например сохраняет у себя (возможны детали, но об этом не сейчас). Теперь клиент может посылать AT в сервисы с защищенными ресурсами, эти сервисы будут извлекать из AT права пользователя и понимать, можно давать ему доступ или нет. Т-о AT "многоразовый" - используется при каждом запросе.

Допустим, AT живет 10 минут. Значит после этого времени он приходит в негодность и пользователю нужен новый, а значит надо снова обращаться к сервису аутентификации. В обычной ситуации пользователю снова пришлось бы ввести логин и пароль, но за счет RT (??? вот тут заполнить пробел, как именно за счет RT, где он хранится, как проверяется и т.д.) он может их не вводить, а просто получить новый AT и работать дальше. Т-о RT "одноразовый" - он используется только после истечения AT для получения новой пары AT + RT.

В случае, если AT будет украден, вор сможет пользоваться им только до тех пор, пока не истечет срок действия AT. Поэтому срок действия AT делают коротким - от нескольких минут до нескольких дней, в зависимости от необходимости баланса между нагрузкой на сервис аутентификации и критичностью безопасности.

Если же и RT украдут, то когда вор воспользуется им и получит новую пару AT + RT, то можно при этом инвалидировать предыдущую пару (как один из вариантов) и тогда легальный пользователь со своими токенами будет вынужден повторно пройти аутентификацию. Соответственно, он снова введет логин \ пароль, получит AT + RT и тогда уже пара вора перестанет работать.



