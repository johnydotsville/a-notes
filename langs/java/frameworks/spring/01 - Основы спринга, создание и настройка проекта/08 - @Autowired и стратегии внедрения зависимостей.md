# @Autowired и стратегии внедрения зависимостей

Поскольку CityService пользуется MarriageService'ом, нам нужно отметить, что свойство с этим объектом спринг должен заполнить сам. Для этого воспользуемся аннотацией `@Autowired`. Сам класс не будем аннотировать через @Service, поскольку решили, что зарегистрируем его явно:

```java
// Нет аннотации, так что спринг не найдет этот класс сам. Мы зарегим его явно потом
public class CityService {
    private final MarriageService marriageService;

    @Autowired
    public CityService(MarriageService marriageService) {
        this.marriageService = marriageService;
    }

    public MarriageCertificate marry(Person man, Person woman) {
        return marriageService.marry(man, woman);
    }
}
```

Аннотакция `@Autowired` может применяться к свойствам класса, методам или конструктору. Эта аннотация означает, что спринг должен самостоятельно заполнить аннотированное поле.

## @Autowired и конструкторы

Часто является основным способом в программах, не являющихся фреймворками, когда состав объектов весьма жесток и не подразумевает возможностей по широкой кастомизации.

Этот способ гарантирует, что все зависимости будут установлены, потому что нельзя не передать в конструктор параметр, который он требует. Через конструктор нужно внедрять *обязательные* зависимости класса. При этом все зависимости должны быть бинами. Если кто-то не будет бином, программа скомпилируется, но не запустится - спринг на старте сообщит, что-то вроде "Parameter of constructor in TopService required a bean of type 'SubServiceB' that could not be found."

Применить ее можно только к одному конструктору, потому что если применить к нескольким, спринг не поймет, какой ему использовать.

## @Autowired и сеттеры

Часто используется в фреймворках или программах, подразумевающих возможности по широкой кастомизации поведения. :question: TODO: Каким образом - похоже вопрос широкий, и следует вернуться к нему позже, а пока есть более актуальные вещи.

## @Autowired и поля

Применение @Autowired непосредственно к полю считается плохой практикой. Тому есть несколько причин:

1. Основная, с которой идут все остальные: отпадает необходимость объявлять конструкторы. Это ведет к тому, что зависимости класса "размываются", становится труднее понимать, от чего он зависит, потому что обычно зависимости передаются именно через конструктор для наглядности. Становится очень легко напичкать класс десятками зависимостей и это будет плохо заметно - а конструктор с десятью параметрами быстро вызвал бы подозрение.
2. Если мы игнорируем конструкторы, то не сможем создавать иммутабельные объекты: не получится объявить в классе final-поле, потому что оно требует заполнения либо в конструкторе, либо тут же при объявлении. Но поскольку спринг создает бины автоматически уже после запуска программы, то до компиляции поле будет пустым, а значит программа даже не скомпилируется.
3. Получаем сильную привязку к DI-контейнеру (касается не только спринга, а вообще). Если конструкторы мы игнорируем, то заполнять поля без DI-контейнера сможем только через рефлексию, а это не удобно.

## @Autowired и static поля

Применять @Autowired к статическим полям нельзя, спринг так не умеет.

## Выводы

* Внедрение через конструктор подходит в большинстве случаев
* Внедрение через свойства - лучше вообще не использовать
* Внедрение через сеттеры - если понимаешь, зачем тебе это нужно
* Смешивать способы технически возможно, но логически смысла в этом мало



