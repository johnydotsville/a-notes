# Терминология

* Старший бит (*наиболее значимый*) - `1`001

* Сдвиг влево `<<` и вправо `>>` - каждый бит сдвигается на указанное количество позиций влево\вправо

  Операция сдвига влево аналогична умножению исходного числа на $2^n$, где n - количество битов сдвига, а сдвиг вправо аналогичен делению на $2^n$

  ```
  [0000] 1001 << 3 == 0100 1000  // влево, 9 * 2^3 = 72
  1001 >> 3 == 0001  // вправо, 9 : 2^3 = 1, есть нюанс
  ```

  Нюанс в том, что сдвиг вправо через оператор >> является *знаковым*, т.е. учитывает знак числа. У отрицательных чисел старший бит всегда является `1`. Поэтому если сдвигать знаковое число вправо оператором >>, то после сдвига старший бит останется `1`:

  ```
  1100 >> 1 == 1010 // -4 : 2^1 = -2
  ```

  В этом примере число 1100 представляет собой знаковое -4, следовательно старший бит кодирует знак. Поэтому оператор >> знак сохраняет и получается 1010 вместо 0110, как можно было бы ожидать без знания этого нюанса 

* Сдвиг вправо беззнаковый `>>>` - сдвигает биты вправо без разбора, знаковое число или беззнаковое

  ```
  1100 >>> 1 == 0110
  ```

  -4 из предыдущего примера превращается в +6

Такая вот история.

# Битовые операции

| Операция | Пример               | Комментарий                           | Java op |
| -------- | -------------------- | ------------------------------------- | ------- |
| xor      | 1100 xor 1010 = 0110 | Как обычный or, только при 1-1 дает 0 | ^       |
| and      | 1100 and 1010 = 1000 |                                       | &       |
| or       | 1100 or 1010 = 1110  |                                       | \|      |

