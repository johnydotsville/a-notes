# Сравнение java.io и java.nio

В джаве есть два пакета для работы с вводом-выводом (IO):

* java.io (появился первым)
* java.nio (появился вторым, new IO)

NIO еще называют Non-blocking IO, но это не совсем корректно. Например, работа с файлами в NIO все равно всегда происходит в блокирующем стиле, а работа с сокетами - по умолчанию тоже, но может быть переведена в неблокирующий режим.

Сравнение двух пакетов:

|                  | java.IO     | java.NIO                    |
| ---------------- | ----------- | --------------------------- |
| Тип IO операций  | Блокирующие | Неблокирующие + блокирующие |
| С чем работаем?  | Потоки      | Каналы, буферы              |
| Доп. возможности | -           | Селекторы                   |

О таких вещах как каналы, буферы и селекторы написано в разделе про NIO, но в целом выбор того или иного пакета зависит от типа задач, требований к производительности и характера самой обработки ввода-вывода.

Что за типы задач? Есть задачи с "тяжелым" IO, т.е. задачи, где IO используется интенсивно и занимает важную роль среди всех операций, например, веб-сервер. Он интенсивно работает с IO, потому что должен постоянно принимать соединения и обрабатывать данные. А что за характер обработки? Сама обработка может быть разная. Может быть это простое сохранение данных или пересылка куда-то еще, т.е. без необходимости анализировать сами данные. Тогда это одно дело. А может быть наоборот - эти данные подвергаются сложной обработке. Что насчет требований производительности? Есть разница, обрабатывать 10 соединений в секунду или 10_000.

В общем, суть понятна - без конкретных задач и ограничений нет из разговора о том, что лучше - IO или NIO. Пара паттернов, которые могли бы склонить выбор туда или сюда:

* Соединений мало - тогда можно создавать на каждое соединение отдельный поток и проводить обработку в нем, используя java.IO. Дополнительные потоки - это дополнительный расход памяти и время на переключение контекста. Но за счет того, что соединений мало, это не сильно влияет на производительность.
* Соединений много - расход памяти и времени на переключение между потоками может стать критичным. Поэтому нужно искать способы как обрабатывать несколько соединений в одном потоке. Для этого подходит java.NIO - инициируем подряд несколько IO операций и пока инициировали последнюю, уже завершилась первая и можно ее обрабатывать. Меньше переключений контекста, меньше памяти на дополнительные потоки.
* Данные сложные и проверки на их готовность могут быть менее выгодными, чем дождаться окончания блокирующего IO - используем java.IO



# Блокирующий и неблокирующий IO

Некоторые утверждения:

* При неблокирующем IO нужно меньше тредов на обслуживание такого же количества запросов IO

  Из этого я делаю вывод, что при блокирующем на каждый запрос IO выделяется тред?

* Большинство неблокирующих фреймворков используют бесконечный цикл (называется event loop) для проверки, готовы ли данные и когда готовы, то вызываются "заинтересованные" в этих данных процессы. Чтобы этот бесконечный цикл был эффективным и не тратил попусту процессорное время, то все серьезные операционные системы предоставляют специализированный API для создания таких циклов, где все оптимизировано и продумано.

* Неблокирующий IO может быть реализован в синхронном и асинхронном стиле.

  Т.е. сам по себе "неблокирующий" не означает "параллельный" или вроде того. Что это значит, пока не понимаю.

  Но важно то, что "блокирующий" означает, что он блокирует тред. Если в текущем треде мы вызвали "неблокирующую" операцию, которая при этом просто создала второй тред и заблокировала его для ожидания IO, то эту операцию можно назвать неблокирующей действительно разве что только в кавычках.

* NIO позволяет не плодить потоки и следовательно не требует накладных расходов на синхронизацию

* Java NIO из-за необходимости быть мультиплатформенным не использует всех сильных возможностей каждой ОС. Но благодаря библиотекам вроде Netty можно использовать преимущества каждой конкретной платформы.

* Каждый поток имеет свой программный счетчик и регистры

* Есть два способа организовать IO: блокирующий и неблокирующий.

  И есть два типа IO операций: синхронные и асинхронные.

  Пока я не понимаю такого разделения. В данный момент у меня в голове синхронный=блокирующий, асинхронный=неблокирующий и я не понимаю, что значит "способ организовать IO" и "тип IO операции", это вроде одно и то же.

  UPD. ??? синхронный подразумевает, что IO-метод делает запрос на операцию IO и блокирует тред, пока операция не завершится. Асинхронный подразумевает, что IO-метод отправляет запрос на IO и сразу же делает возврат, а дальше уже мы с помощью какого-либо механизма опроса понимаем, закончен IO или нет, можем ли мы получить результат или нет.

* Под любой "блокирующей" или "неблокирующей" операцией IO лежит блокирующий системный вызов. Процессор после выполнение каждой команды проверяет, не поступило ли прерывание. Если поступило, он сохраняет стек и переходит на обработку прерывания.

* Теперь, обычно, ОС не нужно постоянно опрашивать устройство в стиле "Ну что, есть результат? А теперь? А теперь?". Она просто отдает команду на выполнение IO, а когда команда завершается, устройство вызывает прерывание и таким образом ОС пониманет, что все говото и можно передать данные нужному процессу.

* Асинхронность в программировании - это модель, когда компоненты отправляют друг другу сообщения, не ожидая получить ответ немедленно.

* Что такое мультиплексирование? Это "уплотнение канала связи за счет передачи нескольких потоков данных по одному каналу связи". При этом конечно скорость каждого потока падает, т.к. приходится делиться полосой. К чему это объяснение? А к тому, что IO в современных ОС тоже можно организовать за счет своеобразного мультиплексирования: сделать единственный поток, который будет в цикле (событийный поток, event loop) опрашивать готовность операций IO и оповещать интересующиеся программы.



Некоторые процессы:

* Вот как я понял процесс отправки данных: клиентская программа вызывает IO операцию, которая должна отсылать некоторые данные. Эти данные записываются в буфер сокета (этот буфер находится в RAM) и когда буфер заполняется, тред блокируется и управление уходит ОС. Она начинает этот буфер читать и отправлять по сети (вероятно, перемещая данные из RAM-буфера сокета в буфер сетевой карты). Когда все из буфера прочитано, он опустошается и ОС снова запускает процесс, чтобы он докинул оставшиеся данные в буфер.

  Соответственно на стороне сервера

