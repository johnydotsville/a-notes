# Вопросы

- [ ] Как расшифровывается NIO?
- [ ] Все ли операции в NIO являются неблокирующими? Какими являются, например, api для работы с файлами, сокетами?
- [ ] В стандартном IO мы работаем с *потоками* байтов или символов напрямую. А как происходит работа в NIO?
  - [ ] Что такое канал, буфер и селектор? Как это связано с потоками ввода-вывода?

# NIO

NIO означает New IO, а не Non-blocking IO. Например, API для работы с файлами в NIO использует блокирующую модель.

В стандартном IO мы работаем с *потоками* байтов или символов напрямую. В NIO мы с потоками непосредственно не работаем, а присоединяем к потоку *канал*, который пишет и читает информацию из потока в *буфер*. И главное, что пока он это делает, наша программа может выполняться дальше.

*Селекторы* - это объекты, которые могут следить за несколькими каналами на предмет наступления *событий*, например, соединение открыто, пришли данные и т.д. Т.о. можно организовать одновременную обработку нескольких источников данных в одном потоке.

# Черновик по java nio

> Канал мы получаем, например, на объекте файла. А можно ли канал "приделать" к любому потоку?

## Буфер

Буфер - это просто область памяти, которую мы выделяем под данные при работе с каналом, ведь он должен куда-то писать и читать то, что добывает из потока. Буфер может находиться в двух режимах: чтения и записи.

В nio есть несколько типов буферов. Условно их можно разделить на два вида:

* ByteBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer - по буферу на каждый примитивный тип
* MappedByteBuffer

Каждый из этих классов имеет статический метод *.allocate()* для выделения памяти под буфер:

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
```

У буфера есть 3 характеристики:

* capacity - емкость. Это все время одно и то же, максимальный размер буфера, который мы ему выделили при создании.
* position - позиция. При чтении и записи позиция каждый раз смещается и указывает соответственно на последний элемент, который мы прочитали или записали.
* limit - лимит. При записи лимит равен емкости буфера, а при чтении лимит указывает, сколько элементов мы можем прочитать из буфера, поскольку буфера может быть заполнен не до конца.

Работа с буфером обычно заключается в выполнении 4 шагов:

* Прочитать из канала и поместить прочитанное в буфер.

  Можно сделать это через канал. Логика "читаем из канала и кладем прочитанное в буфер":

  ```java
  int bytesWritten = someChannel.read(buffer);
  ```

  Или через метод самого буфера:

  ```java
  buffer.put(127);
  ```

* Перевести буфер в режим чтения методом .flip()

  При этом limit становится равен значению position, а сам position потом обнуляется, чтобы начать чтение с начала буфера.

* Прочитать данные из буфера.

  Тоже можно либо пользуясь методом канала (логика "Пишем в канал то, что находится в буфере"):

  ```java
  byte bytesRead = someChannel.write(buffer);
  ```

  Или методом самого буфера:

  ```java
  byte data = buffer.get();  // Читает один элемент
  ```

* Очистить буфер методом .clear() или .compact()

  Метод .clear() полностью очищает буфер. Метод .compact() удаляет из буфера только те данные, которые мы прочитали. Непрочитаенные он перемещает в начало буфера и последующая запись в буфер будет происходить в позицию после этих данных.

Дополнительные методы буфера:

* rewind() - переместить position в 0, чтобы можно было перечитать буфер с начала
* mark() + reset() - mark помечает текущую позицию в буфере, а reset сбрасывает текущую позицию до отмеченной.

