# Вступление

Потокобезопасность - это, по сути, о доступе к совместному состоянию, и особенно к совместному мутируемому состоянию (shared mutable state).

Состояние объекта - это данные объекта, хранящиеся в экземплярных полях или статических полях класса, и  любые другие данные, которые могут повлиять на его поведение.

Всякий раз, когда к состоянию обращаются более одного потока и какой-то, возможно, пишет в состояние, необходима синхронизация доступа к состоянию.

Три способа сделать класс потокобезопасным:

* Не использовать общее состояние
* Сделать общее состояние немутируемым
* При каждом доступе к общему состоянию использовать синхронизацию

Инкапсуляция, немутируемость и четкая формулировка инвариантов - помогают проектировать потокобезопасные классы. Инварианты - это условия, которые ограничивают состояние, чтобы его значения всегда были корректными.

Базовая практика - сделать код сначала правильным, а потом - быстрым.

# 2.1 Что такое потокобезопасность?

Класс является потокобезопасным, если он ведет себя правильно во время доступа из нескольких потоков, независимо от их количества и того, как они планируются и перемешиваются планировщиком потоков, а также без дополнительных усилий по синхронизации со стороны вызывающего кода.

Потокобезопасные классы инкапсулируют всю необходимую синхронизацию и не требуют от клиента дополнительных усилий для этого.

## 2.2.1 Сервлет без поддержки внутреннего состояния

Объекты без поддержки внутреннего состояния всегда являются потокобезопасными. Например, сервлет по расчету факториала:

```java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
    
}
```

# 2.2 Атомарность

Если мы захотим добавить в сервлет расчета факториала счетчик вызовов без синхронизации, вот так:

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    
    private long count = 0;
    
    public long getCount() { return count; }
    
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }
    
}
```

То столкнемся с проблемой *потерянных обновлений (lost updates)*, потому что операция ++count не является атомарной и состоит из трех частей:

* Считать текущее значение
* Вычислить новое значение
* Записать новое значение

И при неудачной временной координации несколько потоков могут считать исходное значение, увеличить его и после записи чья-то работа окажется потерянной.

TODO: далее показывается как сделать этот класс потокобезопасным. Что лучше - сохранить оригинальную структуру или поместить решение сюда, чтобы оно было сразу рядом с проблемой?

## 2.2.1 Состояние гонки

Состояние гонки - это когда результат зависит от [относительной] временнОй координации событий.

Распространенным типом СГ является ситуация "проверить, а затем действовать". Например, ленивое создание тяжелого объекта:

```java
@NotThreadSafe
public class LazyInitRace {

    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
    
}
```

При неудачном стечении обстоятельств два потока могут увидеть null в instance и создать новые объекты. Тут может получиться две проблемы:

* Один объект перезапишет другой, но оба потока вернут один и тот же объект (TODO: как это возможно? и откуда я вообще это взял? Ни в анг, ни в рус книге про это не сказано)
* Один объект перезапишет другой, и потоки вернут два разных объекта

## 2.2.3 Составные действия

Составные действия (compound actions) - это последовательность действий, которые должны выполняться атомарно, чтобы быть потокобезопасными.

Операции А и В являются атомарными, если с точки зрения потока, выполняющего операцию А, операция В выполняемая другим потоком была либо выполнена полностью, либо не выполнена вообще.

Звучит немного непривычно, но на примере понятнее:

* Составное действие "прочитать, изменить, записать" - чтение, изменение и запись являются атомарными, если поток выполняет их все три, не прерываясь, либо не выполняет ни одну из них.
* Составное действие "проверить, а затем действовать" - проверка на null, создание нового объекта и запись его в поле являются атомарными, если поток выполняет их не прерываясь, либо не выполняет вообще.

Пример как можно сделать класс UnsafeCountingFactorizer потокобезопасным, используя специальный Atomic-тип:

```java
@ThreadSafe
public class CountingFactorizer implements Servlet {

    private final AtomicLong count = new AtomicLong(0);  // <-- Используем спец. тип
    
    public long getCount() { return count.get(); }
    
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();  // <-- атомики позволяют делать такое атомарно
        encodeIntoResponse(resp, factors);
    }
    
}
```

# 2.3 Блокировка

Допустим, мы хотим добавить в сервлет вычисления факториала кэширование, чтобы если два клиента подряд запросят фактириал одного и того же числа, мы могли вернуть уже вычисленное значение. Пример плохой реализации:

```java
@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {

    private final AtomicReference<BigInteger> lastNumber = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors = new AtomicReference<BigInteger[]>();

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }
    
}
```

Она демонстрирует ситуацию, когда две переменные состояния по-отдельности потокобезопасные, но вместе - не являются таковыми. Все потому, что они зависят друг от друга. Изменение одного должно быть синхронизировано с изменением другого, но в коде эти два действия никак не связаны в общий блок. Поэтому один поток может успеть установить новое число и прерваться, не успев установить его множители.

## 2.3.1 Внутренние замки

В Java есть встроенный механизм замков - синхронизированный блок, принимающий ссылку на объект-замок:

```java
syncronized (lock) {
    // Код, который нужно исполнить атомарно
}
```

В качестве замка может использоваться любой объект, т.к. у каждого объекта есть специальная внутренняя структура данных для этих целей. Если слово syncronized применить к методу класса, то замком послужит объект, на котором этот метод вызывается. А если применить к статическому методу, тогда замком будет объект Class, который JVM загружает в память, когда дело доходит до использования какого-то класса.

Поток захватывает замок при входе в синхронизированный блок и отпускает при выходе из него, или если вылетает из него с исключением (даже если оно не обработано). syncronized действует как мьютекс, т.е. только один поток может выполнять защищенный блок, а другие дойдя до защищенного блока будут заблокированы до тех пор, пока замок не освободится. Если он не освободится никогда, значит остальные потоки тоже будут заблокированы навечно.

Пример как с помощью замка можно сделать сервлет с кэшем факториала потокобезопасным (но при этом производительность будет плохая):

```java
@ThreadSafe
public class SynchronizedFactorizer implements Servlet {

    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;

    public synchronized void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }
    
}
```

Теперь метод расчет синхронизированный, поэтому несколько потоков не смогут одновременно рассчитывать факториал. Потокобезопасность обеспечена, но производительность стала околонулевая.

## 2.3.2 Повторная входимость

Один и тот же поток может повторно приобретать замок. На замке есть счетчик. Замок считается свободным, если счетчик равен нулю. Когда поток приобретает замок, JVM регистрирует текущего владельца замка и если владелец запрашивает замок повторно, счетчик увеличивается. Это позволяет потоку, например, вызывать синхронизированный метод из другого синхронизированного метода. Без reentrant механизма это вызвало бы самоблокировку потока.

Повторная входимость "наследуется", поэтому наследники могут спокойно вызывать синхронизированные методы родителей:

```java
// Суперкласс
public class Widget {
    
    public synchronized void doSomething() {
    ...
    }    
}

// Подкласс
public class LoggingWidget extends Widget {

    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();  // <-- Это норма за счет reentrancy-механизма
    }
}
```

# 2.4 Защита состояния с помощью замков

Распространенная ошибка - думать, что синхронизация нужна только при записи в разделяемую переменную. А на самом деле она нужна везде, где есть доступ к переменной. И осуществляться синхронизация доступа к одной и той же переменной во всех местах должна с помощью одного и того же замка (и только одного, а не двух, трех, и т.д.)

Приобретение замка на объекте не препятствует обращению к этому объекту. Т.е. приобретение замка означает лишь то, что другой поток не сможет приобрести замок на этом же объекте, а просто поработать с объектом - пожалуйста.

Не все данные должны быть защищены замками, а только мутируемые и запрашиваемые несколькими потоками. 

TODO: интересно, а если эти данные только для чтения, все равно надо защищать? UPD. Вероятно имеются ввиду вот такие ситуации:

```java
public synchronized long getHits() { return hits; }
public synchronized double getCacheHitRatio() {
    return (double) cacheHits / (double) hits;
}
```

Здесь метод может начать выполняться, но не успеть вернуть значение и к моменту возобновления работы значение уже будет другое. Хотя в данном случае выглядит так, будто это как раз нормально и даже хорошо, т.к. вернется актуальное значение, но вероятно идейно это не очень. Хз пока что.

UPD. Про visibility-гарантии-то я и забыл. Без синхронизации значение может быть взято из кэша, а не из оперативки.

# 2.5 Живучесть и производительность

Вариант улучшения класса SynchronizedFactorizer, в котором вместо синхронизации целого метода используется синхронизация только блоков, в которых она действительно нужна:

```java
@ThreadSafe
public class CachedFactorizer implements Servlet {

    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;

    public synchronized long getHits() { return hits; }
    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }
    
}
```

hits и cacheHits это те же "счетчики обращений". Сюда они введены как бонус, для демонстрации того, что все действия, требующие синхронизации, лучше располагать рядом друг с другом по возможности, т.к. захват замка требует времени и если что-то можно сделать в одном sync-блоке, то надо именно так и делать.

TODO: почему он на строке 21 сразу не вернул результат? Вероятно потому что это было бы медленнее, чем просто склонировать кэш в итоговую переменную. Поток мог бы прерваться при выполнении encodeIntoResponse и мы бы остались в sync-блоке, поэтому другим потокам пришлось бы ждать. А так мы быстро склонировали, отпустили замок и даже если тут же прервались, то другой поток сможет работать. В 24 строке появляется проверка на null в итоговой переменной по сравнению с оригиналом, где было else. Такая проверка позволяет нам развести операции по двум sync-блокам, т.к. с else в данном случае получился бы только один блок.

Пара правил:

* Не пренебрегайте простотой в угоду производительности, т.к. сложный код может поставить под угрозу безопасность
* Не удерживайте блокировку во время долгих вычислений и операций ввода-вывода (сеть, консоль)

