# Вопрос

- [ ] Если два объекта равны, могут ли у них быть разные хэш-коды? А если у двух объектов одинаковые хэш-коды, могут ли объекты быть не равны? Почему?
- [ ] Обязательные свойства метода equals:
  - [ ] Сопоставьте правильно названия и формулы свойств функции equals: рефлексивность, транзитивность, симметричность, `a = b; b = c; => a = c `, `a.equals(a) == true`, `a = b; b = a;`
  - [ ] Что означает свойство "неравенство null"? Какое правило должен соблюдать equals при сравнении с null?
  - [ ] Что означает свойство "постоянность"? Может ли equals выдать разные результаты, если объекты не менялись?
- [ ] Как по умолчанию реализован метод equals в классе Object? Что сравнивается?
- [ ] С каких трех проверок можно начать базовую проверку на равенство? Проверка "на дурака"
- [ ] Что представляет собой хэш-код в Java?
  - [ ] Как по умолчанию в классе Object генерируется хэш-код? Как это связано с положением объекта в памяти? Будет ли ХК отличаться у одного и того же объекта при последовательных запусках программы? А в течение непрерывной работы программы?
  - [ ] Что возвращает метод `System.identityHashCode(person);`? Влияет ли как-то на него переопределение метода .hashCode?
  - [ ] Допускается ли отрицательный хэш-код?
  - [ ] Почему для некоторых структур данных вроде HashSet особенно важна реализация hashCode?

# Характеристики методов

Пара базовых свойств, касающихся equals и hashCode:

* Если два объекта равны, то и хэш-коды у них равны, всегда.
* Если у двух объектов хэш-коды равны, это не всегда означает, что объекты равны. Потому что количество хэш-кодов в зависимости от реализации может быть меньше, чем количество объектов.

Обязательные свойства для функции equals:

1. Рефлексивность

   Т.е. сравнение с самим собой обязательно дает true:

   ```java
   a.equals(a) == true
   ```

   Как запомнить: reflection - это отражение. Отражение в зеркале - видишь самого себя, значит рефлексивность - это сравнение объекта с самим собой.

2. Транзитивность

   Она же косвенность: если `a = b` и `b = c`, тогда `a = c`

   ```java
   a.equals(b) == true;
   b.equals(c) == true;
   => a.equals(c) == true;
   ```

   Как запомнить: **ТР**анзитивность - в правиле участвуют три объекта. Транзит переводится как "переход, перенос", т.е. перенос факта равенства на третью пару.

3. Симметричность: если `a = b`, то и `b = a`

   ```java
   a.equals(b) == true;
   => b.equals(a) == true;
   ```

4. Неравенство null: при сравнении объекта с null, equals всегда должен давать false

5. Постоянность (согласованность): если сравниваемые объекты не менялись, equals должен выдавать одинаковый результат

# Реализация

## equals

Дефолтная реализация equals в Object состоит из сравнения указателей на объекты. Если два указателя указывают на один и тот же объект, тогда объекты считаются равными. Но у нас может быть два "логически" равных объекта и тогда такая проверка не подходит.

Рассмотрим способ реализации equals на примере класса и его подкласса. В суперклассе выполним, во-первых, "проверку на дурака" (сравнение с null, две одинаковые ссылки и на тип данных), а, во-вторых, сравним общие свойства (id):

```java
public abstract class AbstractEntity {
    ...
	@Override
    public boolean equals(Object that) {
        if (this == that) return true;
        if (that == null || this.getClass() != that.getClass()) return false;

        AbstractEntity entity = (AbstractEntity) that;
        return Objects.equals(id, entity.id);
    }
}
```

А в подклассе воспользуемся проверкой из суперкласса и добавим проверку личных полей подкласса (имя и фамилия):

```java
public class Actor extends AbstractEntity {
    ...
	@Override
    public boolean equals(Object that) {
        if (!super.equals(that)) return false;

        Actor actor = (Actor) that;
        return Objects.equals(firstName, actor.firstName)
            && Objects.equals(lastName, actor.lastName);
    }
}
```

## hashCode

### Как представлен хэш-код в Java

Сам по себе хэш-код в Java является целым числом (int), значит максимальное количество уникальных хэш-кодов равно $2^{32}$. Метод hashCode может использоваться сторонними типами. Например, реализациями HashMap, HashSet и т.д., поэтому не надо недооценивать его важность.

В классе Object реализация по умолчанию зависит от самой реализации JVM. В OpenJDK это один способ, в другой - по другому. Интересная исследовательская [статья](https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html) на эту тему. Несколько вариантов:

* Преобразование адреса объекта в целое число. Несмотря на то, что объекты могут менять свое положение в памяти (после сборки мусора), на протяжении всей работы программы у объекта гарантированно будет один и тот же хэш.
* Обычная генерация случайного числа
* Генерация на основании состояния потока

Несмотря на конкретную реализацию, важно только одно - хэш-код у объекта будет одинаковый на протяжении всей работы программы.

### Дефолтный хэш-код

После переопределения метода .hashCode мы все еще можем получить *identity* ("дефолтный") хэш:

```java
Person person = new Person();
System.identityHashCode(person);  // <-- Если вдруг нужно узнать "исходный" хэш

// overriden hash: -1956363043
// identity hash: 249515771
```

### Способы переопределения хэш-кода

Я видел вот такой способ переопределения метода hashCode:

```java
@Override
public int hashCode() {
    int hash = super.hashCode();
    hash = 89 * hash + (firstName != null ? firstName.hashCode() : 0);
    hash = 89 * hash + (lastName != null ? lastName.hashCode() : 0);
    return hash;
}
```

Но потом встретил вот такой. Он кажется мне более правильным:

```java
public abstract class AbstractEntity {
    ...
	@Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

и теперь подкласс:

```java
@Override
public int hashCode() {
    return Objects.hash(super.hashCode(), firstName, lastName);
}
```

Objects.hash(...) удобен для случаев, когда для вычисления хэш-кода используется несколько полей. Для вычисления хэш-кода для одного элемента есть специальные методы, например:

```java
@Override public int hashCode() {
    return Objects.hash(name)
        + Integer.hashCode(salary);
}
```

У них есть преимущества. Например, если name будет null, то вызов name.hashCode() даст исключение, в то время как Objects.hash(null) безопасно даст 0. Если среди полей есть массив, то на этот случай есть `Arrays.hashCode()` и т.д.

# Согласованность equals и hashCode

Правило, которое обязано соблюдаться:

> Если `equals == true`, тогда у объектов *обязан* быть одинаковый хэш-код.

Однако, если у объектов одинаковый хэш, это еще не значит, что они равны.

Какие поля объекта использовать в этих методах, чтобы правило соблюдалось? Я сделал такой вывод:

> В обоих методах нужно использовать идентичный набор полей. Или, как минимум, поля в hashCode() это подмножество полей из equals().
>
> Как запомнить: equals это гарантированное сравнение объектов, хэш - "быстрое". Т.о. хэш "меньше" equals'а, значит его поля - подмножество equals'а.

Допустим, есть такой класс:

```java
public class Person {
    private String surname;
    private String name;
    private String patronymic;
    private int age;
}
```

И два объекта:

```
Иванов Иван Иванович, 50
Иванов Иван Иванович, 60
```

Допустим, в equals мы используем *ФИО*, а в hashCode - *ФИО + возраст*:

```
Множество полей equals:   { фамилия, имя, отчество }
Множество полей hashCode: { фамилия, имя, отчество, возраст }
```

Поля hashCode не являются подмножеством equals.

Тогда equals нам скажет, что оба объекта равны, потому что они оба Ивановы Иваны Ивановичи, но при этом хэши будут разные, потому что, несмотря на одинаковые имена, одному 50 лет, а другому 60. Правило нарушено, equals дал true, а хэши разные.

Если же мы в equals используем *ФИО + возраст*, а в hashCode только *ФИО*, тогда equals даст false, а хэши будут одинаковые и, хотя правило тогда не нарушится (одинаковые хэши не всегда означают одинаковые объекты), это довольно бессмысленно и выглядит больше как логическая ошибка.

Отсюда я сделал вывод, что в equals и hashCode нужно использовать идентичный набор полей.

# TODO

Почитать соответствующий раздел в новой книге Хорстмана, на стр. 350