# Стирание

Дженерики появились в Java 5. До них использовался тип Object с приведением. Т.е. например класс ArrayList существовал уже тогда, просто у него внутри для элементов использовался тип Object.

После компиляции никаких дженериков не существует. Вместо обобщенного типа создается "сырой" (raw) тип, в котором вместо дженерик-типа подставляется Object, если нет ограничителей типа. Если они есть, тогда в качестве типа ставится *первый* ограничитель.

Грубо говоря:

```java
// Вот такой дженерик-класс, без ограничителей типа
class Foo<T> {
    public T field;
}
// при компиляции после стирания превращается вот в такой:
class Foo {
    public Object field;
}
```

```java
// А вот такой дженерик-класс, с ограничителями типа
class Foo<T extends IA, IB> {
    public T field;
}
// при компиляции после стирания превращается вот в такой:
class Foo {
    public IA field;  // Используется ПЕРВЫЙ ограничитель
}
```

В местах использования дженериков компилятор сам производит нужное приведение типов, например:

```java
// Допустим, есть такой дженерик-класс,
class Foo<T> {
    public T getSome(T value) {
        T tmp = value;
        return tmp;
    }
}
// который после компиляции превратится вот в такой:
class Foo {
    public Object getSome(Object value) {
        Object tmp = value;
        return tmp;
    }
}

// При использовании мы закрываем дженерик типом Person:
var foo = new Foo<Person>();
Person pers = new Person();

// Компилятор автоматически допишет приведение к нужному типу,
// в данном случае к Person, нам этого делать не нужно
Person result = (Person)foo.getSome(pers);
```

# Влияние стирания на дженерики

У дженериков есть несколько ограничений, которые в основном вызваны именно механикой стирания. Рассмотрим эти ограничения.

## Примитивные типы и дженерики

Примитивные типы не могут быть использованы в дженериках именно из-за стирания, потому что нельзя положить условный double или int в переменную типа Object.

## Выяснение типа дженерика

После компиляции уже не существует никаких дженериков, есть только сырые типы, которые из них получаются. Поэтому подобные попытки являются ошибочными:

```java
if (a instanceof Pair<String>);  // Ошибка
if (a instanceof Pair<T>);  // Ошибка
```

```java
// Предупреждение, что проверка может показать только, что тип является Pair, 
// но не именно Pair<String>
Pair<String> p = (Pair<String>) a;
```

```java
Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
// true, т.к. после стирания оба они просто Pair
if (stringPair.getClass() == employeePair.getClass());
```

## Дженерик-массив

```java
var table = new Pair<String>[10];  // Ошибка
```

Компилятор не позволит такую конструкцию и вот почему. Представим вот такой код:

```java
var iarr = new Integer[10];
Object[] oarr = iarr;
oarr[5] = 47;
System.out.println(oarr[5]);  // 47
oarr[6] = "hello";  // Скомпилируется, но в рантайме будет ошибка
```

В примере выше будет ошибка, потому что массив запоминает типы элементов и поэтому в `Object[]` здесь нельзя положить строку, т.к. там уже лежат Integer. Поскольку при стирании дженерики становятся идентичными, независимо от того, каким типом они закрыты, то массив бы не смог распознать, когда в него пытаются положить неправильный тип, например:

```java
var arr = new SomeGen<Person>[10];  // Запрещено, но представим, что можно
Object[] oarr = arr;  // Из-за стирания oarr понимает только, что в нем лежит SomeGen, а не SomeGen<Person>
oarr[5] = new SomeGen<Person>();  // Нормально
oarr[5] = new SomeGen<String>();  // Ошибка, но массив этого не поймет
```

Поэтому массив дженериков создать невозможно. По этой же причине невозможно использовать дженерик в синтаксисе передачи нескольких значений в метод:

```java
public static <T> void addAll(Collection<T> coll, T... ts) {  // Ошибка
    for (T t : ts) coll.add(t);
}
```



TODO: остатки ограничений (Стр. 668 - 682) можно было бы разобрать после вайлдкардов 

