# Анонимные классы

> Вообще об анонимных классах по логике стоило бы, вероятно, написать до лямбд. Но скорее всего было бы не особо понятно. Более удачным вариантом мне показалось сначала рассмотреть "сахарный" синтаксис, т.к. его проще воспринимать, а уж потом спуститься до анонимных классов и показать во что этот сахар превращается после растворения.

Анонимные классы, в свою очередь, это тоже сахар для сокращения объема кода. Поэтому начнем с рассмотрения самого горького варианта, вообще без сахара. Рассматривать будем на примере имеющегося в стандартной библиотеке функционального интерфейса `Function<Integer, Integer>`. В конечном итоге должны понять, каким образом реализуется концепция передачи функции в функцию.

Пусть у нас будет простой метод, выполняющий над указанным числом математическую операцию, которая тоже передается в метод вместе с самим числом:

```java
public class Math {
    public static void doMath(int number, Function<Integer, Integer> func) {
        int result = func.apply(number);
        System.out.println("Результат операции: " + result);
    }
}
```

## Без сахара

Если не пользоваться сахаром, нам придется честно написать несколько классов, реализующих интерфейс Function, потом создать экземпляры этих классов и передать в метод doMath.

```java
public class Square implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer i) {
        return i * i;
    }
}
```

```java
public class Cube implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer i) {
        return i * i * i;
    }
}
```

Используем эти классы:

```java
public class App {
    public static void main(String[] args) {
        Square square = new Square();
        Cube cube = new Cube();

        Math.doMath(5, cube);
    }
}
```

Получается весьма громоздко. Приходится объявлять полноценные классы.

## Анонимные классы

Добавим немножко сахарку:

```java
public class App {
    public static void main(String[] args) {
        Function<Integer, Integer> square = new Function<Integer, Integer>() {
            @Override
            public Integer apply(Integer i) {
                return i * i;
            }
        };

        Math.doMath(5, square);
        Math.doMath(5, new Function<Integer, Integer>() {
            @Override
            public Integer apply(Integer i) {
                return i * i * i;
            }
        });
    }
}
```

Улучшения заключаются в том, что не пришлось объявлять отдельные классы Square и Cube. Мы как бы вписали их реализацию прямо на месте.

Как понимать такой синтаксис:

* Анонимный класс называется анонимным, потому что у него нет никакого имени. У классов Square и Cube имена были, собственно, Square и Cube. Теперь же мы просто написали `new Function<Integer, Integer>`, что без знания синтаксиса выглядит как создание экземпляра интерфейса, что конечно же невозможно. А на самом деле это создание экземпляра анонимного класса. В этом классе мы реализуем нужные нам методы.
* Экземпляр анонимного класса можно сначала положить в переменную или сразу передать в качестве аргумента. Создать другой экземпляр получившегося анонимного класса невозможно, потому что у него нет имени и обратиться к нему, стало быть, никак нельзя.

По большей части анонимные классы широко использовались для предоставления реализаций разных слухачей, обработчиков и так далее. Т.е. вещей, для которых создавать отдельные классы довольной бессмысленно.

Кроме того, анонимные классы можно использовать для реализации подклассов. Но это уже просто синтаксическая возможность, на практике это вряд ли актуально:

```java
// Какой-то класс, от которого можно было бы унаследоваться
public class Foo {
    protected int number;

    public Foo(int number) {
        this.number = number;
    }

    public void doSome() {
        System.out.println("Это метод класса Foo. А number равен: " + number);
    }

    public void doOther() {
        System.out.println("Этот метод doOther класса Foo.");
    }
}
```

```java
public class App {
    public static void main(String[] args) {
        // Это мы создаем не экземпляр Foo, это мы создаем экземпляр анонимного класса,
        // который стал наследником Foo, унаследовал его метод doSome как есть, а
        // метод doOther переопределил по-своему
        Foo anon = new Foo(10) {
            @Override
            public void doOther() {
                System.out.println("Это метод doOther из анонимного класса.");
            }
        };
        
        anon.doSome();  // Это метод класса Foo. А number равен: 10
        anon.doOther();  // Это метод doOther из анонимного класса.
    }
}
```

## Лямбды

Ну и наконец самый современный синтаксис, позволяющий создавать реализацию функционального интерфейса - это лямбды:

```java
Math.doMath(5, i -> i * i);
Math.doMath(5, i -> i * i * i);
```

Здесь компилятор берет на себя сопоставление указанной реализации на метод функционального интерфейса.