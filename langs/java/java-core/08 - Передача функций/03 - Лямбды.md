# Лямбды, отложенное выполнение

Лямбды - это компактный синтаксис для описания реализации метода функционального интерфейса (ФИ). Лямбда под капотом превращается в реализацию ФИ, а *ее тело становится телом метода ФИ*. Как конкретно будет выглядеть эта реализация - вложенный класс, прокси, статический метод класса где объявлена лямбда, или что-то еще - зависит от реализации компилятора и в целом для нас с практической точки зрения не важно. Почитать про "десахаризацию" лямбд можно [тут](https://cr.openjdk.org/~briangoetz/lambda/lambda-translation.html).

Концептуальное назначение лямбд - это *отложенное выполнение* кода, когда мы не вызываем функцию сами, а просто передаем ее куда-то и там ее вызывают в нужный момент. Пример - обработка событий. Чайник закипел - произошло событие. Мы можем написать функцию - "бибикнуть", отдать ее чайнику и он будет вызывать ее, когда вода закипела. А можем передать другую функцию - "замигать индикатором". Так или иначе, это и есть отложенное выполнение кода, когда некий код код мы просто отдаем, а вызывает его кто-то другой.

Разберемся в вариантах синтаксиса лямбд:

* Полный - параметры берутся в скобки, указывается их тип, а тело размещается в `{ }`:

  ```java
  BiFunction<String, Integer, Boolean> isSame = (String s, Integer i) -> {
      int ival = Integer.getInteger(s);
      return Integer.compare(ival, i) == 0;
  };
  ```

* Сокращенный - типы параметров можно не писать, а если тело можно выразить единственной строкой, то и `{ }` можно опустить:

  ```java
  BiFunction<String, Integer, Boolean> isSame = (s, i) -> Integer.getInteger(s) == i;
  ```

* Минимальный - если параметр всего один, можно не брать его в скобки:

  ```java
  ActionListener listener = e -> System.out.println("Событие наступило" + e.getWhen());
  ```

Компилятор проверяет:

* Является ли интерфейс, на место которого мы хотим запихнуть лямбду, функциональным.

* Соответствует ли количество параметров лямбды количеству параметров метода интерфейса и правильно ли с точки зрения типов используются параметры в теле лямбды.

  Отсюда становится понятно, почему лямбда может сопоставляться только с функциональным интерфейсом - если бы нереализованных методов было больше одного, компилятор бы не понял, на какой метод ориентироваться.

* Сходятся ли тип результата метода и тип, который возвращает лямбда.

К лямбдам нельзя применять var, потому что компилятор обязательно должен знать, что вы затеяли:

```java
var func = (int x, int y) -> x + y;
// Ошибка! Cannot infer type: lambda expression requires an explicit target type
```

# Самое важное о лямбдах

Самое критичное, что надо понять в архитектуре лямбд это то, что тело лямбды, грубо говоря, помещается ВНУТРЬ тела метода ФИ, а НЕ ЗАМЕНЯЕТ собой этот метод. Без четкого осознания этого факта будет невозможно понять как работает техника method reference.

Если взять пример лямбды выше:

```java
BiFunction<String, Integer, Boolean> isSame = (String s, Integer i) -> {
    int ival = Integer.getInteger(s);
    return Integer.compare(ival, i) == 0;
};
```

То трансформацию лямбды в реализацию ФИ BiFunction можно представить примерно так:

```java
BiFunction<String, Integer, Boolean> isSame =
    new BiFunction<String, Integer, Boolean>() {
        @Override
        public Boolean apply(String s, Integer i) {
            int ival = Integer.getInteger(s);  // Метод apply остался методом apply, а код лямбды
            return Integer.compare(ival, i) == 0;  // разместился ВНУТРИ него
        }
};
```

# Лямбды и замыкания

Лямбды могут захватывать переменные из внешней области видимости:

```java
public void foo(List<Person> list) {
    final int bottom = 10;
    final int top = 20;
    list.removeIf(p -> (p.size >= bottom && p.size <= top));  // Захват bottom и top
}
```

Захватить можно только неизменяемые переменные. Поэтому они или дб объявлены как final, либо быть effectively final, т.е. фактически не изменяться.

