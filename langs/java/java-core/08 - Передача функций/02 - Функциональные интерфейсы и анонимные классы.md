# Функциональные интерфейсы

За термином "функциональный интерфейс" стоит всего лишь интерфейс, у которого *строго один* метод без реализации (абстрактный). Если методов без реализации больше одного, тогда интерфейс уже не считается функциональным. Методы с реализацией (т.е. дефолтные и приватные) не считаются, их может быть сколько угодно.

```java
@FunctionalInterface  // Эта аннотация не позволит добавить в интерфейс больше одного абстрактного метода
interface MyFunctional {
    void methodNameDoesNotMatter();  // Всего один метод без реализации, значит интерфейс - функциональный
}

interface NotFunctional {
    void methodA();
    String methodB();  // Больше одного метода без реализации - и интерфейс уже не функциональный
}
```

# Анонимные классы и передача функций

Анонимные классы могут использоваться в местах, где надо передать реализацию функционального интерфейса. 

Анонимные классы это сахар для сокращения объема кода. Поэтому начнем с рассмотрения самого горького варианта, вообще без сахара. Рассматривать будем на примере имеющегося в стандартной библиотеке функционального интерфейса `Function<Integer, Integer>`. Его метод *apply* принимает целое число и возвращает целое число. В конечном итоге должны понять, каким образом реализуется концепция передачи функции в функцию.

Пусть у нас будет простой метод, выполняющий над указанным числом математическую операцию, которая тоже передается в метод вместе с самим числом:

```java
public class Math {
    public static void doMath(int number, Function<Integer, Integer> func) {
        int result = func.apply(number);
        System.out.println("Результат операции: " + result);
    }
}
```

## Без сахара

Если не пользоваться сахаром, нам придется честно написать несколько классов, реализующих интерфейс Function, потом создать экземпляры этих классов и передать в метод doMath.

```java
public class Square implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer i) {
        return i * i;
    }
}
```

```java
public class Cube implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer i) {
        return i * i * i;
    }
}
```

Используем эти классы:

```java
public class App {
    public static void main(String[] args) {
        Square square = new Square();
        Cube cube = new Cube();

        Math.doMath(5, cube);
    }
}
```

Получается весьма громоздко. Приходится объявлять полноценные классы.

## Анонимные классы

Добавим немножко сахара:

```java
public class App {
    public static void main(String[] args) {
        
        // Объявили и инстанцировали анонимный класс прямо на месте аргумента
        // с типом функционального интерфейса
        Math.doMath(5, new Function<Integer, Integer>() {
            @Override
            public Integer apply(Integer i) {
                return i * i * i;
            }
        });
        
        // Объявили и инстанцировали еще один анонимный класс 
        // и положили его в переменную с типом функционального интерфейса.
        // К предыдущему АК из первой строчки он отношения не имеет.
        Function<Integer, Integer> square = new Function<Integer, Integer>() {
            @Override
            public Integer apply(Integer i) {
                return i * i;
            }
        };
        Math.doMath(5, square);  // Передали экземпляр АК в метод
    }
}
```

Улучшения заключаются в том, что не пришлось объявлять отдельные классы Square и Cube. Мы как бы вписали их реализацию прямо на месте.

Как понимать такой синтаксис:

* Анонимный класс называется анонимным, потому что у него нет никакого имени. У классов Square и Cube имена были, собственно, Square и Cube. Теперь же мы просто написали `new Function<Integer, Integer>`, что без знания синтаксиса выглядит как создание экземпляра интерфейса, что конечно же невозможно. А на самом деле это создание экземпляра анонимного класса. В этом классе мы реализуем нужные нам методы.
* Экземпляр анонимного класса можно сначала положить в переменную или сразу передать в качестве аргумента. Создать другой экземпляр получившегося анонимного класса невозможно, потому что у него нет имени и обратиться к нему, стало быть, никак нельзя.

По большей части анонимные классы широко использовались для предоставления реализаций разных слухачей, обработчиков и так далее. Т.е. вещей, для которых создавать отдельные классы довольной бессмысленно.

## Лямбды

Ну и наконец самый современный синтаксис, позволяющий создавать реализацию функционального интерфейса - это лямбды:

```java
Math.doMath(5, i -> i * i);
Math.doMath(5, i -> i * i * i);
```

Здесь компилятор берет на себя сопоставление указанной реализации на метод функционального интерфейса и создание класса с этой реализацией.