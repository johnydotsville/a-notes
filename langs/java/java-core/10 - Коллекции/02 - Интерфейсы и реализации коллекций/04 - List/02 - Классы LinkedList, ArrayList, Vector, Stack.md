## LinkedList

Список, где элементы идут в памяти не подряд и имеют ссылку друг на друга (двусвязный список).

На его основе также написана реализация Deque, потому что удобно. Эта реализация позволяет использовать LinkedList и в качестве стека в том числе, методы позволяют, но об этом в разделе про очереди. В качестве списка же LinkedList умеет все из интерфейса List и даже доступ по индексу, хотя и не так эффективно, как ArrayList.

Немного о том, что внутри. Есть указатели на первый и последний элементы:

```java
transient Node<E> first;
transient Node<E> last;
```

Операции добавления как в список, так и как в очередь, базируются на одной операции:

```java
public boolean add(E e) {  // Добавление как в список
    linkLast(e);  // Тут манипуляции с указателями first и last
    return true;
}
...
public boolean offer(E e) {  // Добавление как в очередь
    return add(e);
}
```

## ArrayList

Список, основанный на массиве, который может изменять свой размер:

```java
public class ArrayList<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, Serializable {
        +.removeRange(from, to);
    
        +.ensureCapacity(100);
}
```

Особенности:

* При заполнении изменяет свой размер на +50% от текущего
* Разрешает хранить null
* Несинхронизированный

```java
import java.util.ArrayList;

ArrayList<String> arr1 = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);
```

### Добавление, резервирование

При создании обычного массива все ячейки сразу инициализируются и доступны для использования. При создании ArrayList, несмотря на резервирование места под некоторое количество элементов, фактически никаких элементов до реального добавления не существует и работать с ними, соответственно, нельзя.

Для резервирования места под определенное количество элементов есть два способа:

```java
Employee john = new Employee("John Carter");
Employee abby = new Employee("Abby Lockhart");
Employee carry = new Manager("Carry Weaver");

var employees = new ArrayList<Employee>(128);  // 1. Указываем сразу при объявлении

var employees = new ArrayList<Employee>();
employees.ensureCapacity(40);  // 2. Расширяем память под элементы в произвольный момент
employees.add(john);  // Добавить элемент в конец
employees.add(abby);
employees.add(carry);
employees.ensureCapacity(500);
```

Добавлять можно не только в конец ArrayList, но и в указанную позицию, со сдвигом остальных элементов:

```java
employees.add(2, john);
```

При этом эта вторая позиция очевидно должна существовать, иначе `IndexOutOfBoundsException`. Конкретно в этом примере  у нас три элемента уже добавлено и можно было написать `.add(3, john)` и тогда это было бы аналогично обычному add и элемент добавился бы в конец списка. А вот `.add(4, john)` уже вызвало бы исключение, поскольку реально существует только три элемента.

Доступ к элементам возможен только через специальные методы `.get(i)` и `.set(i, item)` (в отличие от C#, где можно было использовать синтаксис [i] даже со списком):

```java
Employee emp = employees.get(2);
employees.set(3, emp);
```

### Перегон в обычный массив

Первый способ подразумевает предварительное создание массива, а потом уже копирование в него элементов. Характерен тем, что можно указать нужный тип массива самостоятельно:

```java
Employee[] arr = new Employee[employees.size()];
employees.toArray(arr);

for (Employee item : arr)
	System.out.println(item);
```

Второй способ подразумевает автоматическое создание массива и запись в него элементов. Но при этом создается массив типа Object:

```java
// Employee[] arr = employees.toArray();  // Ошибка, toArray() возвращает Object[]
Object[] arr = employees.toArray();

for (Object item : arr) {
	System.out.println(item);
    System.out.println(((Employee)item).getName());
}
```

Как следствие, придется приводить элементы, прежде чем обращаться с ними как с сотрудниками.

## Vector

По сути это тоже список, основанный на массиве, то же самое что ArrayList, за исключением того, что Vector *синхронизированный*, т.е. если поток А что-то делает с вектором, то другие потоки не могут с ним ничего делать, пока поток А не освободит его.

Кроме того, отличается в мелочах, например, когда заканчиваются слоты, вектор увеличивает размерность массива на 100%, в то время как ArrayList на 50% и вектор позволяет указать явно, на сколько надо увеличивать.

ArrayList - это выбор для большинства случаев. Его можно синхронизировать самостоятельно, если нужно, так что вектор - легаси.

## Stack

Не нужно использовать. Об этом сказано даже в документации джавы. Дремучее легаси с ошибками - наследуется от вектора, значит имеет лишние, не характерные для стека операции.