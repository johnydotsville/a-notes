# HashSet

* Реализует интерфейс Set
* Не потокобезопасен
* Итераторы fail-fast
* Логически основан на принципе хэш-таблицы, фактически базируется на HashMap
* Порядок итерации не подчиняется никаким правилам и со временем может измениться (наверное, после перехэширования)
* Разрешается вставлять null. Можно вставлять null несколько раз, но поскольку это множество, а значит дубликтов нет, то в результате будет только один null элемент
* Обеспечивает постоянное время к операциями добавления, удаления, поиска и определения размера.

Если производительность обхода важна, нельзя задавать слишком большую изначальную емкость и также нужно чтобы заполненность не была слишком низкой. Т.е. если емкость 100 элементов, а фактически добавлено 15, то обход этих 15 будет занимать времени как обход всей 100.

## Насчет null

Можно посмотреть чуть подробнее в конспекте про Map, раздел HashMap, но если вкратце, то когда в качестве ключа добавляется null, то вместо того чтобы считать хэш от null, просто используется 0. Поэтому null по сути является полноценным значением.

# LinkedHashSet

* Реализует интерфейс Set
* Разрешается вставлять null
* Поддерживает порядок итерации - как добавили, так и обошли
* Постоянное время для вставки, удаления, поиска
* Обход занимает ровно столько времени, сколько фактически содержится элементов, за счет того, что это все-таки список

LinkedHashSet под капотом работает на основе LinkedHashMap, а внутри LinkedHashMap каждый элемент представлен вот таким классом:

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
...
transient LinkedHashMap.Entry<K,V> head;
...
transient LinkedHashMap.Entry<K,V> tail;
```

Т.е. стандартный узел дополняется еще ссылками на следующий и предыдущий элемент. Кроме того, есть ссылки на начало и конец списка. Таким образом, элементы попадают в хэш-таблицу как обычно, но просто еще имеют ссылки друг на друга.

В остальном принцип такой же как и у HashSet+HashMap: элемент хранится в ключе map'ы, а в качестве данных - пустой объект-заглушка.

# TreeSet

* Базируется на TreeMap (поэтому все остальные пункты просто скопированы из описания TreeMap)

  ```java
  private transient NavigableMap<E,Object> m;
  ...
  public TreeSet() {
      this(new TreeMap<>());
  }
  ```

* Использует красно-черное дерево

* Поэтому для операций добавления, удаления, извлечения и contains дает сложность $log_{2} n$

* Порядок элементов - так называемый natural ordering, т.е. элементы или должны реализовывать интерфейс Comparable, или структуре при создании нужно передать Comparator, чтобы она знала, как сравнивать элементы

* null не допускается. Но когда-то давно, до 7 джавы, допускалось добавлять null первым элементом, после чего уже ничего нельзя было добавить и ничего не работало, но теперь null запрещен

* Не синхронизирован