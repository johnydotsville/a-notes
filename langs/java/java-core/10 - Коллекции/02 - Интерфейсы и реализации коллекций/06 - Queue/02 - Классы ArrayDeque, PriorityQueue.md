## ArrayDeque и LinkedList

В общем случае ArrayDeque предподчительнее. Из официальной документации:

* `ArrayDeque` эффективнее, чем `LinkedList` при добавлении и удалении элементов в начале и в конце
* `LinkedList` хорош для удаления текущего элемента при итерации, но не очень хорош для самой итерации
* `LinkedList` потребляет больше памяти, чем `ArrayDeque`

## PriorityQueue

[Документация](https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)

При добавлении в эту очередь, новый элемент встает не в конец, а в позицию, которая соответствует его приоритету. Приоритет определяется согласно natural ordering, т.е. хранимые объекты должны реализовать интерфейс Comparable, либо в очередь при создании нужно передать компаратор.

> Важный момент: при обычном обходе коллекции через for можно обнаружить, что элементы выводятся не в natural ordering, а как-то по-своему. Все потому что если нужен именно natural-порядок, то и обходить коллекцию надо как очередь - через извлечение элементов, например, методом poll
>
> UPD. Не на всяком примере это можно сразу заметить, но это так.

```java
Comparator<Person> personComparator = (Person p1, Person p2)
                -> Integer.compare(p1.getAge(), p2.getAge());

Queue<Person> queue = new PriorityQueue<>(personComparator);

Person tom = new Person("Tom Sawyer", 14);
Person huck = new Person("Huck Finn", 14);
Person mary = new Person("Mary Sawyer", 17);

queue.add(mary);  // Мэри окажется в конце очереди, хотя добавлена первой
queue.add(tom);
queue.add(huck);
```

В начало очереди попадают *меньшие* элементы. Если оказывается несколько одинаковых меньших элементов, то порядок извлечения не гарантируется (хотя у меня на многих запусках порядок соблюдался - по очередности добавления, т.е. Том всегда был впереди Гека, хотя обоим по 14 лет)