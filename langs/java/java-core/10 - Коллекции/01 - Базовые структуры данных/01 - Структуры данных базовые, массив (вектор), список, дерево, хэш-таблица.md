# Структуры данных базовые

Предисловие: под "элементы упорядочены" предполагается, что при каждом обходе элементы будут идти в одном и том же порядке. "Элементы не упорядочены" значит, что порядок зависит от реализации и в общем не следует рассчитывать на то, что элементы при обходе каждый раз будут выданы в одном и том же порядке.

> Базовыми структурами данных я их назвал по признаку организации в памяти. Т.е. либо элементы лежат последовательно, либо в разных участках памяти и имеют ссылку на связанные с ними участки.

## Массив (вектор)

Массив (array) или "вектор" (vector) - это СД, в которой:

* Элементы упорядочены
* Элемент можно получить по числовому индексу

## Список

"List" - это СД, в которой:

* Элементы упорядочены
* Помимо данных, элементы хранят ссылки на другие элементы

В зависимости от того, на какие именно элементы хранятся ссылки, списки бывают:

* Односвязный список - каждый элемент хранит ссылку только на следующий элемент
* Двусвязный список - каждый элемент хранит ссылку и на следующий, и на предыдущий элемент

И в дополнение к этому:

* Линейный список - у списка есть начало и конец, т.е. ярко выраженный первый и последний элемент
* Кольцевой список ("циклический") - "последний" элемент и "первый" связаны, т.е. образуется этакое "кольцо"

Т.о. комбинации этих видов дают 4 типа связных списка: ЛОС, ЛДС, КОС, КДС

> Какие бывают списки кроме "связных" - найти почему-то не удалось, хотя не раз встречалось утверждение, что "связный" список это только одна из разновидностей списка, который сам по себе является абстрактным понятием

Сам список это больше "техническая" структура данных, она не определяет правила добавления и извлечения элементов. На основе списка строятся СД "очередь" и "стек", которые, используя эту "техническую" основу, определяют логику добавления и извлечения.

## Дерево

*Дерево* - это структура данных, в которой у каждого элемента мб 0..n дочерних элементов. Да, именно несколько, а не обязательно только 2. У такого "обычного" дерева только одно требование - у каждого элемента мб только один родитель.

*Двоичное (бинарное) дерево* - это дерево, у которого:

* У каждого элемента не более двух детей
* "Левые" дети всегда меньше родителя, а "правые" дети - всегда больше родителя

*Сбалансированное дерево (B-дерево)* - это дерево, у которого высота левого и правого поддеревьев отличается не более чем на 1.

*Красно-черное дерево* - это подвид сбалансированного дерева. КЧ-дерево является двоичным. Тут высота может быть считается как-то по-другому, судя по картинкам не всегда разница между ветками в высоту равняется 1, но суть в том, что оно все-таки сбалансированное, т.е. поиск в нем происходит быстрее, чем если оно было несбалансированным. Ну а все остальные принципы у него как у двоичного дерева, т.е. левые - меньше, правые - больше, и только по два ребенка у родителя.

## Хэш-таблица

> Все нижеописанное является теоретической основой, без привязки к реализации. Т.е. вопросы вроде "а что пропускается через хэш-функцию в Map - ключ или что?" - не для этого раздела, а для раздела, посвященного Map'у.

Хэш-таблица используется, когда требуются быстрые вставка\удаление\поиск. Ее особенностью является отсутствие определенного порядка хранения элемента.

Хэш-таблица - это "обычный массив с необычной индексацией". Это значит, что в основе ХТ лежит обычный массив, но просто индекс ячейки, в которую нужно поместить элемент при добавлении, вычисляется особым способом - с помощью хэш-функции.

Хэш-функция принимает элемент и возвращает *индекс* массива для хранения этого элемента.

Если в ячейке пусто, то элемент просто добавляется. Если уже занято, эта ситуация называется коллизией и приходится размещать два (и более) элемента в одном месте. Коллизия решается разными способами:

* Связный список - каждая ячейка массива хранит не сами элементы, а ссылку на связный список с элементами. В случае коллизии в список просто добавляется новый элемент

* Линейное пробирование - если ячейка занята, то проверяется следующая за ней ячейка. Если она свободна, то элемент добавляется в нее, иначе поиск свободной ячейки продолжается дальше. Т.е. в отличие от способа со списком, все элементы хранятся непосредственно в ячейках массива. Есть и другие способы поиска свободной ячейки, например, *квадратичное пробирование* - когда берется не $i+1$, а $(i+1)^2$, $(i-1)^2$, $(i+2)^2$, $(i-2)^2$ и т.д. Но как ни крути, коллизии всегда приводят к образованию *кластеров* - нескольких разных элементов с одинаковым хэш-кодом - и приходится обойти весь кластер, чтобы найти нужный элемент

* Повторное хэширование - имеется несколько хэш-функций *H1, H2... Hn*. Сначала элемент проходит через H1. Если она выдает ячейку, которая уже занята, тогда элемент проходит через H2 и т.д., пока не найдется свободная ячейка. Хэш-функции подбираются таким образом, чтобы выдаваемые ими индексы ячеек гарантированно не повторялись. Этот метод эффективнее первых двух. Пример Hk хэш-функции:

  ```
  Hk(key) = [GetHash(key) + k * (1 + (((GetHash(key) >> 5) + 1) % (hashsize - 1)))] % hashsize
  ```

>На деле, описания методов разрешения коллизий вызывают кучу вопросов, путаницу в терминологии и вообще трудно составить однозначную картину. Но поскольку конкретная реализация спрятана под капотом, это в общем-то и не важно. Просто помним, что коллизии бывают и что разрешаются они разными способами.

С хэш-таблицей связаны несколько терминов:

* Bucket - это ячейка массива. В одной ячейке может храниться и несколько элементов, если они организованы в список.
* Capacity - это текущее количество бакетов в хэш-таблице (ячеек массива).
* Initial capacity - это количество бакетов на момент создания хэш-таблицы.
* Load factor - это число, которое показывает, насколько допустимо заполнить таблицу до проведения перехэширования. Выражается отношением `m/n`, где m - текущая заполненность, а n - общее количество слотов ("размер таблицы"). Дефолтное значение load factor примерно 0.75. Пример: пусть всего у нас будет 17 слотов. 11/17=0.64, а 13/17=0.76 Это значит, что когда в таблице окажется 13 элементов, будет проведено перехэширование. Т.е. выделится массив в два раза больше текущего, для каждого элемента повторно вычислится хэш-функция и элементы займут свои места в новом массиве.