# Строки

## Класс String

* В Java нет встроенного типа для строк.
* В стандартной библиотеке строка представлена обычным классом `String`. Внутри значение выглядит как массив байтов `final byte[] value;` в формате юникод.
* Значением по умолчанию для String является null.
* Строки неизменяемые. Любые операции над строками, например конкатенация, приводят к созданию нового объекта строки.

## Создание и сравнение строк, пул строк

Строки можно создать двумя способами:

```java
// 1 способ, через литерал
String a = "Hello, world!";
String b = "Hello, world!";
String e = "qwerty";

// или выражение
String f = "qwer" + "ty";
String g = e.substring(0);
```

```java
// 2 способ, через явное создание объекта с помощью оператора new
String c = new String("Hello, world!");
```

Когда строка создается *первым способом*, то задействуется *пул строк* - область *в куче*, где созданные строки "кэшируются". Если при создании строки обнаруживается, что такая строка уже есть в пуле, то просто возвращается ссылка на нее. Если строки в пуле нет, тогда создается новый объект строки и помещается в пул.

В случае создания строки вторым способом, через оператор new, новый объект строки создается в куче, но вне пула.

Поскольку строки - это объекты, то на этапе компиляции они еще не существуют и создание пула происходит уже в рантайме. Подробнее [тут](https://stackoverflow.com/questions/18866723/when-is-string-pool-create-in-java-at-compile-time-or-run-time). И поскольку строки - это объекты, то сравнение через оператор равенства `==` приводит к сравнению не содержимого строк, а ссылок на них. На примере строк, объявленных выше:

```java
System.out.println(a == c);  // false, "пульные" строки и "кучные" строки - это разные тусовки
System.out.println(b == c);  // false

System.out.println(a == b);  // true, за счет пула ссылки одинаковые
System.out.println(e == f);  // true
System.out.println(e == g);  // true
```

Поэтому, если надо сравнить строки "честно", по их содержимому, то надо это делать через метод equals:

```java
System.out.println(a.equals(c));  // true
```

## Конкатенация

Т.к. строки неизменяемые, то при конкатенации создается новый объект строки, а все участвующие объекты трансформируются в строки:

```java
String name = "Huck Finn";
int age = 14;
var info = 1 + ". " + name + ", " + age;  // "1. Huck Finn, 14"
```

## Пустые строки, null

Пустая строка - это строка с нулевой длиной:

```java
String zeroLen = "";
System.out.println(zeroLen.length());  // 0
```

В строковую переменную можно положить null, но это означает не пустую строку, а отсутствие данных:

```java
String nullInside = null;
System.out.println(nullInside.length());  // Ошибка! Cannot invoke "String.length()" because "nullInside" is null
```

# Методы строк

## length

Возвращает длину строки (с учетом начальных и конечных пробельных символов):

```java
var str = " Кот ";
int len = str.length();  // 5
```

## isEmpty, isBlank

`isEmpty` это про реальную пустоту строк, когда нет символов вообще.

`isBlank` это не про пустоту, а про отсутствие печатных символов. Наличие пробела уже делает строку не пустой технически. Пустая строка всегда является чистой, а вот чистая - не обязательно пустая.

```java
var noContent = "";
var spaceContent = "   \t\n";

System.out.println(noContent.isEmpty());  // true
System.out.println(noContent.isBlank());  // true

System.out.println(spaceContent.isEmpty());  // false
System.out.println(spaceContent.isBlank());  // true
```

## split, join

`split` разбивает строку по заданному регулярному выражению:

```java
var str = "Раз, два, Фредди заберет тебя.";
String[] frags = str.split(", ");
// ["Раз", "два", "Фредди заберет тебя."]
```

`join` - это статический метод класса String, объединяет несколько строк в одну через указанный разделитель:

```java
var frags = new String[] { "Раз", "два", "Фредди заберет тебя." };
String str = String.join("! ", frags);  // Раз! два! Фредди заберет тебя.

str = String.join("! ", str, "три", "четыре", "дверь запри в своей квартире.");
// Раз! два! Фредди заберет тебя.! три! четыре! дверь запри в своей квартире.
```

## repeat

Повторяет строку, на которой вызван, указанное число раз:

```java
String str = "hello".repeat(2);  // hellohello
```

## equals, equalsIgnoreCase, compareTo

`equals` проверяет строки на равенство без учета регистра, а `equalsIngnoreCase` - с учетом:

```java
"a".equals("a");  // true
"A".equals("a");  // false
"A".equalsIgnoreCase("a");  // true
```

`compareTo` сравнивает строки на "больше-меньше". Строки сравниваются посимвольно, по кодам символов. Если строки начинаются одинаково, то больше считается так, которая длиннее.:

```java
"a".compareTo("a");  // 0
"a".compareTo("b");  // -1
"b".compareTo("a");  // 1
"a".compareTo("ab"); // -1
"с".compareTo("ab"); // 992
```

## startsWith, endsWith

`startsWith` проверяет, начинается ли строка на указанный фрагмент. Регистр учитывается. Можно задать смещение, от которого начинать проверку:

```java
"Привет, мир!".startsWith("Прив");  // true
"Привет, мир!".startsWith("прив");  // false

"Привет, мир!".startsWith("рив", 1);  // true
```

`endsWith` проверяет, заканчивается ли строка на указанный фрагмент. Регистр тоже учитывается, смещение задавать нельзя.

```java
"Привет, мир!".endsWith("мир!");  // true
```

## replace, replaceAll, replaceFirst

Ключевое отличие в том, что последние два метода работают с регулярными выражениями (первый параметр), а первый метод - только с символами и строками.

`replace` заменяет все найденные фрагменты строки на указанный:

```java
var str = "Привет, мир!";
str = str.replace("мир", "Рим");  // Привет, Рим!
```

`replaceFirst` заменяет первый найденный фрагмент на указанный:

```java
var str = "Привет, мир!";
str = str.replaceFirst("и", "е");  // Превет, мир! - вторая и осталась нетронутой
```

`replaceAll` заменяет все найденные фрагменты строки на указанный:

```java
var str = "Привет, мир!";
str = str.replaceAll("и", "е");  // Превет, мер!
```

## toLowerCase, toUpperCase

`toLowerCase` приводит строку к нижнему регистру:

```java
var str = "УЗБАГОЙСЯ";
str = str.toLowerCase();  // узбагойся
```

`toUpperCase` приводит строку к верхнему регистру:

```java
var str = "я спокоен";
str = str.toUpperCase();  // Я СПОКОЕН
```

## strip, trim, stripLeading, stripTrailing

`strip` и `trim` удаляют пробельные символы в начале и в конце строки. trim старая версия, strip - новая (появилась в 11 jdk), отличие в том, что strip ввиду своей новизны может удалять любые пробельные символы юникода, даже более хитрые, чем пробел, таб и прочие "дефолтные".

`stripLeading` и `stripTrailing`, соответственно, удаляют пробельные символы только в начале и только в конце строки.

```java
var str = "\s\t\nВсе эти лишние пробелы нам не нужны\s\n\t";
var s1 = str.strip();  // "Все эти лишние пробелы нам не нужны"
var s2 = str.stripLeading();  // "Все эти лишние пробелы нам не нужны\s\n\t"
var s3 = str.stripTrailing();  // "\s\t\nВсе эти лишние пробелы нам не нужны"
```

# Построение строк, StringBuilder

`StringBuilder` - это класс, который упрощает динамическую работу со строками - замена символов, удаление, вставка, добавление. Внутри SB использует массив для хранения строки. Еще есть класс `StringBuffer`, рассчитанный на работу в многопоточке, у него такие же методы.

Может улучшать производительность при очень больших количествах конкатенаций (больше нескольких тысяч). Компилятор в некоторых случаях может самостоятельно трансформировать конкатенации в использование SB, если сочтет, что это будет производительнее. Так что в большинстве случаев, когда нам нужна конкатенация (например, в реализации метода toString), мы можем просто использовать обычный `+. Явно SB можно использовать, например, в циклах, ну или если нужно действительно сложное конструирование строки с заменой символов, вставку в середину и т.д.

```java
var sb = new StringBuilder("Привет");
sb.append(", мир!");
String result = sb.toString();  // Привет, мир!
```

## Конструкторы

```java
var sb1 = new StringBuilder();  // Дефолтный размер буфера, около 100
var sb2 = new StringBuilder(1500);  // Стартовый размер буфера задаем сами
var sb3 = new StringBuilder("Привет, мир!");  // Размер буфера будет чуть больше размера строки (+16)

StringBuilder(CharSequence seq);  // Не изучал пока CharSequence, todo
```

# Методы StringBuilder

* В качестве фрагментов можно использовать любой объект - число, строку, символ, свой класс и т.д.
* Отсчет позиций ведется с нуля.

## toString

Собирает добавленные фрагменты в единую строку и возвращает ее:

```java
var sb = new StringBuilder("Привет");
sb.append(", мир!");

String result = sb.toString();  // Привет, мир!
```

## length, capacity, trimToSize

`length` возвращает текущую длину строки, хранящуюся в буфере:

```java
var sb = new StringBuilder("Привет");
System.out.println(sb.length());  // 6

sb.append(", мир!");
System.out.println(sb.length());  // 12
```

`capacity` возвращает текущий размер внутреннего буфера:

```java
var sb = new StringBuilder("Кот");
int cap = sb.capacity();  // 19, 3 от кота и +16 потому что разрабы так запрограммировали
```

`trimToSize` пытается сократить размер внутреннего буфера до фактически используемого размера:

```java
var sb = new StringBuilder("Кот");
System.out.println(sb.capacity());  // 19
sb.trimToSize();
System.out.println(sb.capacity());  // 3
```

## charAt, setCharAt, deleteCharAt

`charAt` возвращает символ из указанной позиции:

```java
var sb = new StringBuilder("Кот");
char ch = sb.charAt(1);  // о
```

`setCharAt` заменяет символ в указанной позиции:

```java
//                          012
var sb = new StringBuilder("Кот");
sb.setCharAt(1, 'и');
String result = sb.toString();  // Кит
```

`deleteCharAt` удаляет символ в указанной позиции:

```java
//                          0123
var sb = new StringBuilder("Крот");
sb.deleteCharAt(1);
String result = sb.toString();  // Кот
```

## append, insert, delete, replace

`append` добавляет указанный фрагмент в конец строки:

```java
var sb = new StringBuilder("33");
sb.append('+');
sb.append(44);
sb.append("=");
sb.append(33 + 44);
String result = sb.toString();  // 33+44=77
```

`insert` вставляет фрагмент *перед* указанной позицией:

```java
//                          012
var sb = new StringBuilder("Кот");
sb.insert(1, "р");
String result = sb.toString();  // Крот
```

То, что вставляется именно перед, а не после, легко объяснить: если бы вставка была после, то как бы мы вставили фрагмент перед нулевой позицией?

`delete` удаляет символы [c, по)

```java
//                          012345
var sb = new StringBuilder("Компот");
sb.delete(2, 5);
String result = sb.toString();  // Кот
```

`replace` заменяет символы [c, по) на указанный фрагмент. Если *по* больше длины строки, то считается до конца строки:

```java
//                          01234
var sb = new StringBuilder("Стена");
sb.replace(0, 2, "Врем");
String result = sb.toString();  // Времена
```

## reverse

Инвертирует буфер:

```java
var sb = new StringBuilder("Java");
sb.reverse();

String result = sb.toString();  // avaJ
```

## equals

Сравнивает объекты SB, а не строки в них:

```java
var sb1 = new StringBuilder("Привет, мир!");
var sb2 = new StringBuilder("Привет, мир!");
System.out.println(sb1.equals(sb2));  // false
```



# Одинаковые методы

У String и StringBuilder некоторые методы работают идентично.

## charAt

`charAt` возвращает символ из указанной позиции:

```java
var sb = new StringBuilder("Кот");
char ch = sb.charAt(1);  // о
```

## indexOf, lastIndexOf

`indexOf` возвращает позицию первого вхождения указанного фрагмента. Можно задавать начало поиска:

```java
//                          0123456789
var sb = new StringBuilder("Java avatar");
int pos1 = sb.indexOf("ava");  // 1
int pos2 = sb.indexOf("ava", 3);  // 5
```

`lastIndexOf` возвращает позицию последнего вхождения указанного фрагмента. Можно задавать начало поиска, но все равно возвращается позиция последнего вхождения, так что я не понял, какой в этом смысл:

```java
int pos3 = sb.lastIndexOf("ava");  // 5
int pos4 = sb.lastIndexOf("ava", 9);  // 5
```

## substring

Возвращает фрагмент в виде строки [с, по)

```java
//                          0123456789
var sb = new StringBuilder("Оптоволокно");
String окно = sb.substring(7);  // [c и до конца
String вол = sb.substring(4, 7);  // [с, по)
```

# Текстовые блоки

* Текстовые блоки появились в Java 15. 
* Они упрощают работу в редакторе со строками, которые располагаются на нескольких строчках.
* Текстовый блок заключается в тройные кавычки `"""`, после которых ставится enter, а дальше уже начинается строка.
* Из текстового блока автоматически удаляются пустые символы в начале и конце.
* Правила эскейпинга, надо эскейпить:
  * Если подряд идут три и более кавычек.
  * Если текстовый блок заканчивается кавычкой.
  * Обратные слэши.
* Обратный слэш в конце строчки сам по себе работает как объединитель текущей строчки со следующей.

Пример:

```java
String htmlBlock = """
    <div class="info">
        Текстовые блоки появились в JDK 15.
        Теперь вы можете писать строку на нескольких строчках
        без этих дурацких конкатенаций на каждой строке.
    <div>
    """;
```

Эквивалент строке

```java
<div class="info">\nТекстовые блоки появились в JDK 15.\nТеперь вы можете писать строку на нескольких строчках\nбез этих дурацких конкатенаций на каждой строке.\n<div>
```

