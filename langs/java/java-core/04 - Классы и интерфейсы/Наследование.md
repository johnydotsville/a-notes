# Список вопросов

- [ ] Ковариантные типы
- [ ] Встраивание методов



# Наследование и private-поля

Наследуются все члены базового класса. Однако доступа к приватным полям суперкласса из потомка напрямую нет - он должен пользоваться открытым интерфейсом. Для обращения к членам суперкласса используется слово `super`.

```java
package com.company.sampleprog;

class Employee {
    private int salary;  // <-- Приватное поле наследуется, но напрямую недоступно подклассу

    public void setSalary(int salary) {
        this.salary = salary;
    }

    public int getSalary() {  // <-- Подклассу придется как и всем остальным пользоваться
        return this.salary;   // публичным методом, чтобы получить значение зарплаты
    } 
}
```

Наследование оформляется через слово `extends`:

```java
package com.company.sampleprog;

class Manager extends Employee {
    private int bonus;

    public void setBonus(int bonus) {
        this.bonus = bonus;
    }

    public int getBonus() {
        return this.bonus;
    }

    public int getSalary() {
        int baseSalary = super.getSalary();  // <-- Через super. подкласс может вызвать публичный
        return this.bonus + baseSalary;      // интерфейс суперкласса
    }
}
```

```java
package com.company.sampleprog;

public class Main {
    public static void main(String[] args) {
        Employee mark = new Manager();
        mark.setSalary(15_000);
        mark.setBonus(5_000);
        System.out.println(mark.getSalary());
    }
}
```

# Наследование и конструкторы

При создании объекта подкласса вызывается конструктор суперкласса. Если явно не сделать это, то подкласс попробует вызвать дефолтный конструктор суперкласса. Если его нет, будет ошибка компиляции:

```java
class Employee {
    private final String name;
    
    // теперь компилятор не создаст автоматически дефолтный конструктор
    public Employee(String name) {
        this.name = name;
    }
    ...
}

class Manager extends Employee {
    ...  // При создании Manager попробует вызвать дефолтный конструктор Employee, которого нет
}
```

Поскольку мы объявили в Employee конструктор с одним параметром, значит дефолтного конструктора компилятор автоматически не создает, а Manager будет пытаться его вызвать. Так что нужно или объявить дефолтный конструктор в Employee, или явно вызвать какой-нибудь конструктор из Manager, с помощью `super(...)`:

```java
class Manager extends Employee {
    ...
    public Manager(String name) {
        super(name);  // <-- Явно вызываем конструктор суперкласса
    }
    ...
}
```

# override

Переопределение - это режим по умолчанию для методов, имеющих одинаковую сигнатуру в суперклассе и подклассе. Но при этом они могут возвращать разные типы, т.к. тип в сигнатуру не входит. TODO Хорстман Том 1 с 206???Ковариантные возвращаемые типы.

Т.е. чтобы переопределить метод, достаточно в подклассе создать метод с такой же сигнатурой, как у метода в суперклассе. Но есть нюанс. Можно ошибиться в типе параметра и получится не переопределенный метод, а новый, и заметить эту ошибку может быть трудно.

Например, у Object есть метод `equals(Object otherObject)`. Если в своем классе "переопределить" его как `equals(Employee emp)`, то никакого переопределения не будет, потому что у метода в нашем классе тип параметра Employee, а не Object. Для этих целей есть аннотация `@Override`, которую следует применять ко всем переопределяемым методам. Тогда, если переопределения не произошло, будет ошибка компиляции.

# Поиск метода (черновик)

TODO Хорстман, Том 1, с 205. Однозначно понять по тексту пока не получается, поэтому догуглить потом дополнительно. Здесь предварительная понималка.

Есть тип *объявленный*, а есть *фактический*. Т.е. если мы положим объект типа Manager в переменную типа Employee, то объявленный тип будет Employee, а фактический - Manager.

Виртуальная машина всегда знает о *фактическом* типе объекта. Т.е. в этой ситуации ВМ понимает, что это на самом деле объект типа Manager, а не Employee. *Полиморфизм* - это способность переменной ссылаться на объекты, имеющие разные фактические типы.

Виртуальная машина составляет для класса таблицу методов. В ней, грубо говоря, две колонки: одна - под сигнатуру метода, вторая - под непосредственно метод, который надо вызвать, когда встречается эта сигнатура. Является ли метод public или private, final или static, является ли он конструктором - это тоже виртуальной машине известно. В таблице видно, какой метод является собственным, какой - унаследованным, а какой - переопределенным.

Если метод является конструктором, private, static или final - это *статическое связывание*, т.е. уже на этапе компиляции известно, из какого типа надо брать метод. В самом деле, приватный метод или статический - всегда относится только к одному типу - тому, в котором он определен.

Если метод не является ни одним из вышеперечисленных, значит это *динамическое связывание*. И метод будет браться из фактического типа объекта.

С учетом всего сказанного, нужный метод вычисляется примерно так:

* Взять объявленный тип за основу места поиска метода
* Найти в таблице методов объявленного типа все методы с интересующим именем
* По типам переданных в метод аргументов понять, какой именно из найденных методов нужен
* Если метод является конструктором, private, static, final - использовать метод из объявленного типа
* Если не является, тогда взять метод из фактического типа