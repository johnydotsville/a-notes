# Несколько фактов о классах

`.clone()` - метод для создания копии объекта. Его следует использовать для возврата из методов копий объектов, а не ссылок на объекты, чтобы их нельзя было изменить извне.

---

В файле может быть размещено несколько классов, но только один может быть public.

---

При компиляции файла А, если компилятор встречает использование класса В, то он ищет файл B.class и если не находит его, то заодно компилирует В. Если находит, но при этом видит, что файл B.java модифицирован позже, то он перекомпилирует В.

---

Если локальные переменные имеют такие же имена как поля класса, это приводит к трудноуловимым ошибкам.

---

`var` доступно с Java 10. Обычно не применяется к int, double и т.д., чтобы явно видеть различие между 1 или 1L например.

---

Обращение к null вызывает исключение типа `NullPointerException`.

---

В Java 9 появились методы

```java
name = Object.requireNonNullElse(name, “unknown”);
name = Object.requireNonNull(name, “Имя не может быть пустым”); // выбросит NullPointerException, если name == null
```

Еще есть requireNonNullElseGet и перегрузка с дженериками, но это уже отдельно посмотреть надо.

---

TODO??? Есть ли в Java встраиваемые методы и что это вообще такое? (Хорстман, Т1, с147)

---



---



---



---

## Передача по значению

В Java при передаче параметров методу всегда используется передача по значению. Т.е. значение исходной переменной копируется в параметр и все изменения параметра касаются только этого параметра. В случае передачи объекта это тоже справедливо - в параметр ссылка именно копируется и через параметр можно конечно же изменить состояние объекта, но например поменять ссылки на два объекта местами - нельзя:

```java
…
Employee emp1 = new Employee();
Employee emp2 = new Employee();

public static void swap(Employee a, Employee b) {
    Employee tmp = a;
    a = b;
    b = tmp;
}  // emp1 и emp2 останутся при своих
```

---

В сигнатуру метода входит имя и количество\типы параметров. Возвращаемый тип не входит.

---

Поля инициализируются по умолчанию (кроме final полей), переменные - нет. Для String значение по умолчанию null, а не пустая строка.

Инициализировать поля можно сразу при объявлении. Причем для этого можно использовать даже статический метод например, а не обязательно литерал.

---



---

Вызвать из конструктора другой конструктор можно так:

```java
class Employee {
    public String name;
    public String who;
    
    public Employee(String name) {
        this.name = name;
    }
    
    public Employee(String name, String who) {
        this(name);  // <-- Вызов другого конструктора
        this.who = who;
    }
}
```

т.е. первым оператором конструктора идет `this(...)` с передачей нужных параметров и выбирается подходящий конструктор.

