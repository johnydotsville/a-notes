# Наследование

Характеристики наследования в Java:

* Наследование производится с помощью ключевого слова `extends`
* Наследоваться можно только от одного класса.
* Тип наследования - "классический" (для сравнения, в JavaScript - тип наследования "прототипный")
* Наследуются все поля, свойства, методы, конструкторы, не являющиеся приватными (приватные тоже наследуются, но компилятор не даст обращаться к ним напрямую в потомках)

```java
public class Asset {
    public String name;
}
```

```java
public class Stock extends Asset {  // Для наследования указываем после extends класс родителя
    public long sharesOwned;
}
```

```java
public class House extends Asset {
    public long cost;
}
```

# Наследование и конструкторы

## Необходимость дефолтного конструктора у родителя

Конструкторы не наследуются. Каждый потомок объявляет свои собственные конструкторы, но при их вызове имеет возможность вызвать конструктор родителя, чтобы например избавиться от дублирования кода инициализации полей.

Когда создается экземпляр потомка, *всегда* срабатывает также и конструктор родителя, даже если явно мы этого не пишем. По умолчанию вызывается конструктор родителя без параметров:

```java
public class Asset {
    public String name;

    public Asset() {
        System.out.println("Выполняется конструктор Asset.");
    }
}
```

```java
public class House extends Asset {
    public long cost;

    public House() {
        System.out.println("Выполняется конструктор House.");
    }
}
```

```java
var house = new House();
// Вывод:
Выполняется конструктор Asset.
Выполняется конструктор House.
```

Это может быть не очевидно, но если поменять пример вот так:

```java
public class Asset {
    public String name;

    public Asset(String name) {  // Объявим конструктор с одним параметром. Дефолтного К больше нет.
        System.out.println("Выполняется конструктор Asset.");
        this.name = name;
    }
}
```

```java
public class House extends Asset {
    public long cost;

    // Error: There is no default constructor available in 'johny.dotsville.syntax.inheritance.Asset'
    public House(String name, long cost) {
        System.out.println("Выполняется конструктор House.");
        this.name = name;
        this.cost = cost;
    }
}
```

То компилятор укажет на ошибку, что мы не обеспечили конструктор Asset необходимым параметром. Все потому, что, как уже говорилось, при создании потомка обязательно вызывается конструктор родителя без параметров. Но поскольку мы явно описали конструктор с одним параметром в родителе, то у него исчез конструктор без параметров. Если бы он был, то вызвался бы он и компилятор бы не ругался. Но поскольку его нет, то будет попытка вызвать конструктор, который есть, а он требует параметр string name. Если бы в Asset было несколько конструкторов, с разным набором параметров, тогда бы компилятор сказал, что у Asset отсутствует конструктор без параметров.

## Явный вызов родительского конструктора (super)

Одним словом, надо помнить, что если вдруг у родителя отсутствует дефолтный конструктор, то нам либо надо его добавить, либо в конструкторах потомка придется явно вызывать какой-нибудь из конструкторов родителя. 

Делается это через ключевое слово `super`:

```java
public class House extends Asset {
    public long cost;

    public House(String name, long cost)
    {
        super(name);  // <-- Явно вызываем конструктор родителя
        System.out.println("Выполняется конструктор House.");
        this.cost = cost;
    }
}
```

Ключевое слово super *не является ссылкой на экземпляр родителя*, это просто средство для *невиртуального* доступа к элементу родительского класса. Проще говоря, используя super в данном случае мы можем из потомка вызвать родительскую реализацию конструктора.

