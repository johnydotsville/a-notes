# Наследование

Характеристики наследования в Java:

* Наследование производится с помощью ключевого слова `extends`
* Наследоваться можно только от одного класса.
* Тип наследования - "классический" (для сравнения, в JavaScript - тип наследования "прототипный")
* Наследуются все поля, свойства, методы, конструкторы, не являющиеся приватными (приватные тоже наследуются, но компилятор не даст обращаться к ним напрямую в потомках)

```java
public class Asset {
    public String name;
}
```

```java
public class Stock extends Asset {  // Для наследования указываем после extends класс родителя
    public long sharesOwned;
}
```

```java
public class House extends Asset {
    public long cost;
}
```

# Наследование и конструкторы

Конструкторы не наследуются. Каждый потомок объявляет свои собственные конструкторы, но при их вызове имеет возможность вызвать конструктор родителя. Например, чтобы избавиться от дублирования кода инициализации полей.

## Необходимость дефолтного конструктора у родителя

При создании экземпляра потомка всегда срабатывает не только конструктор самого потомка, но и конструктор родителя. По умолчанию вызывается конструктор родителя без параметров:

```java
public class Asset {
    public String name;

    public Asset() {  // <-- Вызовется по умолчанию при создании экземпляра потомка
        System.out.println("Выполняется конструктор Asset.");
    }
}
```

```java
public class House extends Asset {
    public long cost;

    public House() {
        System.out.println("Выполняется конструктор House.");
    }
}
```

```java
var house = new House();
// Вывод:
Выполняется конструктор Asset.
Выполняется конструктор House.
```

Порядок выполнения такой:

* При команде `new House()` срабатывает конструктор House.
  * Из него первым делом вызывается конструктор Asset.
* Продолжает работу конструктор House.

Если у родителя нет дефолтного конструктора, то в потомке будет ошибка компиляции:

```java
public class Asset {
    public String name;

    public Asset(String name) {  // Объявим конструктор с одним параметром. Дефолтного К больше нет.
        System.out.println("Выполняется конструктор Asset.");
        this.name = name;
    }
}
```

```java
public class House extends Asset {
    public long cost;

    // Error: There is no default constructor available in 'johny.dotsville.syntax.inheritance.Asset'
    public House(String name, long cost) {
        System.out.println("Выполняется конструктор House.");
        this.name = name;
        this.cost = cost;
    }
}
```

В этом случае мы должны явно вызвать какой-нибудь конструктор родителя из конструктора потомка.

## Явный вызов родительского конструктора (super)

Одним словом, надо помнить, что если вдруг у родителя отсутствует дефолтный конструктор, то надо либо его добавить, либо в конструкторах потомка явно вызвать какой-нибудь из конструкторов родителя. 

Делается это через ключевое слово `super`:

```java
public class House extends Asset {
    public long cost;

    public House(String name, long cost) {
        super(name);  // <-- Явно вызываем конструктор родителя
        System.out.println("Выполняется конструктор House.");
        this.cost = cost;
    }
}
```

Ключевое слово super *не является ссылкой на экземпляр родителя*, это просто средство для *невиртуального* доступа к элементу родительского класса. Проще говоря, используя super в данном случае мы можем из потомка вызвать родительскую реализацию конструктора.

Техническая реализация наследования зависит от виртуальной машины, компилятора, одним словом конечная организация кода является черным ящиком, и вызов родительского конструктора является необходимым условием для его работы.
