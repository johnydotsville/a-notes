# Виртуальные методы, @Override

Виртуализация (она же переопределение, оверрайдинг, overriding) методов - это когда в потомке есть метод с такой же сигнатурой, как у родителя и за счет этого достигается полиморфизм при вызове.

В Java виртуализация методов подразумевается по умолчанию, отдельных ключевых слов для нее не требуется. Можно пометить виртуальный метод аннотацией `@Override`, чтобы компилятор выдал ошибку, если не найдет в родителе метод для переопределения.

```java
class Asset {
    public void info() {
        System.out.println("Это метод info() класса Asset");
    }
    
    public String getAlertMessage() {
        return "Это сообщение получено из public-метода getAlertMessage() класса Asset";
    }
}
```

```java
class House extends Asset {
    @Override  // Переопределяем метод
    public void info() {
        System.out.println("Это метод info() класса House");
    }

    @Override  // Ошибка! Нечего переопределять, 'Method does not override method from its superclass'
    public void notExistInParent() { }
}
```

```java
Asset assHouse = new House();
assHouse.info();  // Это метод info() класса House
```

Несмотря на то, что ссылка на объект имеет тип Asset, мы получили вызов метода из типа House, потому что реальный объект, лежащий по ссылке, имеет тип House. Это и есть виртуализация методов в деле.

## Возврат ковариантного типа из виртуального метода

В Java мы можем возвращать из виртуального метода более конкретный тип. Например:

```java
class Asset {
    public String name;

    public Asset(String name) {
        this.name = name;
    }

    public Asset clone() {
        return new Asset(name);
    }
}
```

```java
class House extends Asset {
    public long cost;

    public House(String name, long cost) {
        super(name);
        this.cost = cost;
    }

    @Override
    public House clone() {  // <-- Можем вернуть House, а не Asset
        return new House(name, cost);
    }
}
```

В C# такая возможность появилась только с 9 версии. До этого там можно было бы вернуть только Asset, который потом пришлось бы даункастить до House. А здесь у нас есть возможность сразу вернуть нужный тип.

# Перекрытые методы

Они же скрытые (hide). В Java такой фичи нет, в C# - есть. С логической точки зрения фича довольно странная. Возможно, имеет технические причины на существование.

Скрытый метод имеет такую же сигнатуру как в родителе, но при этом виртуализация не используется и он фактически считается самостоятельным, никак не связанным с методом родителя. Поэтому при вызове такого метода берется реализация из типа ссылки, а не из типа реально лежащего по ней объекта.

# Вызов родительского метода, super

Если у нас появляется необходимость в вызове родительской реализации текущего метода, мы можем сделать это с помощью ключевого слова `super`:

```java
class House extends Asset {
    
    @Override
    public void info() {
        super.info();  // <-- Вызов родительской реализации метода info()
        System.out.println("Это метод info() класса House");
        String mes = super.getAlertMessage();  // Можно, но бессмысленно
    }
    
}
```

Как правило, вызов через super имеет смысл только для виртуальных методов. Приватные методы родителя таким образом вызвать нельзя, а обращаться через super к не-private методам родителя конечно можно, но смысла в этом нет, потому что эти методы и так есть у потомка в аналогичном виде.