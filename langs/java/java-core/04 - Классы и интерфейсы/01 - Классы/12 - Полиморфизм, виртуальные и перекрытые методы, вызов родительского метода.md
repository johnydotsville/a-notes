# Виртуальные методы, @Override

Виртуализация (она же переопределение, оверрайдинг, overriding) методов - это когда в потомке есть метод с такой же сигнатурой, как у родителя и за счет этого достигается полиморфизм при вызове.

В Java виртуализация методов подразумевается по умолчанию, отдельных ключевых слов для нее не требуется. Можно пометить виртуальный метод аннотацией `@Override`, чтобы компилятор выдал ошибку, если не найдет в родителе метод для переопределения.

```java
class Asset {
    public void info() {
        System.out.println("Это метод info() класса Asset");
    }
    
    public String getAlertMessage() {
        return "Это сообщение получено из public-метода getAlertMessage() класса Asset";
    }
}
```

```java
class House extends Asset {
    @Override  // Переопределяем метод
    public void info() {
        System.out.println("Это метод info() класса House");
    }

    @Override  // Ошибка! Нечего переопределять, 'Method does not override method from its superclass'
    public void notExistInParent() { }
}
```

```java
Asset assHouse = new House();
assHouse.info();  // Это метод info() класса House
```

Несмотря на то, что ссылка на объект имеет тип Asset, мы получили вызов метода из типа House, потому что реальный объект, лежащий по ссылке, имеет тип House. Это и есть виртуализация методов в деле.

# Перекрытые методы

Они же скрытые (hide). Это когда метод имеет такую же сигнатуру как в родителе, но при этом виртуализация не используется и он фактически считается самостоятельным, никак не связанным с методом родителя. Поэтому при вызове такого метода берется реализация из типа ссылки, а не из типа реально лежащего по ней объекта.

В Java такой фичи нет, в C# - есть. С логической точки зрения фича довольно странная. Возможно, имеет технические причины на существование.

# Вызов родительского метода, super

Если у нас появляется необходимость в вызове родительской реализации текущего метода, мы можем сделать это с помощью ключевого слова `super`:

```java
class House extends Asset {
    
    @Override
    public void info() {
        super.info();  // <-- Вызов родительской реализации метода info()
        System.out.println("Это метод info() класса House");
        String mes = super.getAlertMessage();  // Можно, но бессмысленно
    }
    
}
```

Как правило, вызов через super имеет смысл только для виртуальных методов. Приватные методы родителя таким образом вызвать нельзя, а обращаться через super к не-private методам родителя конечно можно, но смысла в этом нет, потому что эти методы и так есть у потомка в аналогичном виде.