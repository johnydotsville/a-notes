# Локальные и анонимные классы

Их характеристики:

* И локальные, и анонимные классы являются подвидом вложенных классов.
* Локальные классы вложены не непосредственно в класс, а еще глубже - в его метод, и нигде за пределами этого метода не видны.
* У локальных и анонимных классов полный доступ к внешнему классу и к параметрам \ переменным метода, в котором они объявлены.
  * Чтобы локальные и анонимные классы могли использовать переменные метода, то эти переменные дб или final, или effective final (это когда переменная не объявлена как final, но фактически после инициализации нигде не присваивается повторно)
* Могут иметь свои собственные поля (в т.ч. статические) и методы.

# Локальные классы

Сами по себе локальные классы мне кажутся бесполезными, поэтому особо даже не буду ничего здесь про них писать и разбираться. А вот их подвид - анонимные классы, уже интереснее, про них напишу.

Просто для справки, как выглядит локальный класс:

```java
public class LocalClassDemo {

    public Object methodWithLocalClassInside(String message) {
        int koef = 5;
        
        class Local {  // Прямо посреди метода можно объявить класс
            private String secret;
            
            public void hello() {
                System.out.println("I see message: " + message);
                System.out.println("I see koef: " + koef);
            }
        }
        
        var local = new Local();
        local.hello();
        return local;
    }

}

var acd = new AnonClassDemo();
var local = acd.methodWithLocalClassInside("test");
// Теперь в local лежит экземпляр этого локального класса, и в дебаггере видно, что там есть
// поля message и koef, полученные из захваченного параметра и локальной переменной. Но как
// до них добраться, не зная типа, не понятно. Мб это невозможно.
```

# Анонимные классы

Анонимные классы (в дополнение к общим характеристикам, перечисленным выше) можно охарактеризовать так:

* Это *выражение*, которое одновременно заключает в себе и объявление класса, и создание его экземпляра.
* Анонимный класс не имеет имени, стало быть повторно использовать его нельзя, а каждое новое выражение объявляет и создает новый анонимный класс и его экземпляр.
* Синтаксис анонимного класса можно применить к:
  * Интерфейсу - в этом случае анонимный класс реализует интерфейс. Причем только один, больше одного - невозможно.
  * Классу - в этом случае анонимный класс расширяет этот класс, т.е. становится его потомком.

## Синтаксис анонимного класса

Распознать анонимный класс в выражении можно по фигурным скобкам после круглых скобок:

```java
var func = new Function<Integer, Integer>() {
    @Override
    public Integer apply(Integer num) {
        return num;
    }
};
```

Смотря на этот пример и не зная такой фичи как анонимный класс, можно было бы подумать, что создается экземпляр функционального интерфейса Function, что невозможно, потому что нельзя создать экземпляр интерфейса. Так что нет, это объявляется анонимный класс и создается его экземпляр, а в `{}` идет его тело.

```java
// Foo - это класс, с единственным конструктором (int)
Foo anon = new Foo(10) {
    @Override
    public void doOther() {
        System.out.println("Это метод doOther из анонимного класса.");
    }
};
```

В этом примере, опять же, создается анонимный класс, расширяющий класс Foo и переопределяющий его метод doOther. Что важно, нам надо обеспечить параметр для конструктора анонимного класса, потому что у Foo есть только один конструктор, и он требует параметр. Вот полная версия:

```java
// Какой-то класс, от которого можно было бы унаследоваться
public class Foo {
    protected int number;

    public Foo(int number) {
        this.number = number;
    }

    public void doSome() {
        System.out.println("Это метод класса Foo. А number равен: " + number);
    }

    public void doOther() {
        System.out.println("Этот метод doOther класса Foo.");
    }
}
```

```java
public class App {
    public static void main(String[] args) {
        // Это мы создаем не экземпляр Foo, это мы создаем экземпляр анонимного класса,
        // который стал наследником Foo, унаследовал его метод doSome как есть, а
        // метод doOther переопределил по-своему
        Foo anon = new Foo(10) {
            @Override
            public void doOther() {
                System.out.println("Это метод doOther из анонимного класса.");
            }
        };
        
        anon.doSome();  // Это метод класса Foo. А number равен: 10
        anon.doOther();  // Это метод doOther из анонимного класса.
    }
}
```

## Примеры

### Инициализация списка при создании

Теперь синтаксис "{} после ()" проливает свет на вот такой фрагмент инициализации списка:

```java
var guys = new ArrayList<String>() {{
    add("Tom Sawyer");
    add("Huck Finn");
    add("Becky Thatcher");
}};
guys.add("Joe Harper");

for (String name: guys) {
    System.out.println(name);
}
```

На самом деле это создание анонимного класса-наследника ArrayList, а внутренние `{}` не что иное, как блок инициализации, в котором используются методы add для добавления значений. Не знаю точно как насчет влияния на производительность, но по идее это явно не должно проходить бесследно.

### Анонимы в разных местах

Поскольку анонимные классы - это выражения, они могут появляться в разных местах, где возможно написать выражение:

```java
public class AnonClassDemo {

    // Например, при инициализации поля класса
    private Function<Integer, Integer> func = new Function<Integer, Integer>() {
        @Override
        public Integer apply(Integer num) {
            return num;
        }
    };

    public void methodWithAnonClassInside(int number) {
        int koef = 5;  // effectively final

        // Или при инициализации обычной переменной
        var anon = new Function<Integer, Integer>() {
            @Override
            public Integer apply(Integer num) {
                return num * koef;
            }
        };

        // koef = 20;  // Если так написать, то koef перестает быть effectively final и компилятор
        // начнет ругаться на использование koef внутри тела анонимного класса
    }
}
```

### Анонимные слухачи и обработчики

Анонимные классы широко использовались для реализации слухачей, подписчиков и т.д., до появления лямбд:

```java
b.addActionListener(new ActionListener(  ) {
    public void actionPerformed(ActionEvent e) {
            showStatus("Thanks for pushing my second button!");
        }
});
```

С лямбдами необходимость в анонимных классах резко снизилась, если не отпала:

```java
b.addActionListener((e) -> showStatus("Thanks for pushing my second button!"));
// Или в случае многострочного обработчика:
b.addActionListener((e) -> {
    // doSome
    showStatus("Thanks for pushing my second button!");
});
```





