# Наследование, характеристики и синтаксис

Характеристики наследования в Java:

* Наследоваться можно только от одного класса.
* Тип наследования - "классический" (для сравнения, в JavaScript - тип наследования "прототипный")
* Наследуются все поля, свойства, методы, конструкторы, не являющиеся приватными (приватные тоже наследуются, но компилятор не даст обращаться к ним напрямую в потомках)

```java
public class Asset {
    public String name;
}
```

```java
public class Stock extends Asset {  // Для наследования указываем после extends класс родителя
    public long sharesOwned;
}
```

```java
public class House extends Asset {
    public long cost;
}
```

# Наследование и конструкторы, ключевое слово super

## Отношения между конструкторами родителя и потомка

Конструкторы не наследуются. Каждый потомок объявляет свои собственные конструкторы, но при их вызове имеет возможность вызвать конструктор родителя, чтобы например избавиться от дублирования инициализации полей.

Когда создается экземпляр потомка, *всегда* срабатывает также и конструктор родителя, даже если явно мы этого не пишем. По умолчанию вызывается конструктор родителя без параметров:

```java
public class Asset {
    public String name;

    public Asset() {
        System.out.println("Выполняется конструктор Asset.");
    }
}
```

```java
public class House extends Asset {
    public long cost;

    public House() {
        System.out.println("Выполняется конструктор House.");
    }
}
```

```java
var house = new House();
// Вывод:
Выполняется конструктор Asset.
Выполняется конструктор House.
```

Это может быть не очевидно, но если поменять пример вот так:

```java
public class Asset {
    public String name;

    public Asset(String name) {  // Объявим конструктор с одним параметром. Дефолтного К больше нет.
        System.out.println("Выполняется конструктор Asset.");
        this.name = name;
    }
}
```

```java
public class House extends Asset {
    public long cost;

    // Error: There is no default constructor available in 'johny.dotsville.syntax.inheritance.Asset'
    public House(String name, long cost) {
        System.out.println("Выполняется конструктор House.");
        this.name = name;
        this.cost = cost;
    }
}
```

То компилятор укажет на ошибку, что мы не обеспечили конструктор Asset необходимым параметром. Все потому, что, как уже говорилось, при создании потомка обязательно вызывается конструктор родителя без параметров. Но поскольку мы явно описали конструктор с одним параметром в родителе, то у него исчез конструктор без параметров. Если бы он был, то вызвался бы он и компилятор бы не ругался. Но поскольку его нет, то будет попытка вызвать конструктор, который есть, а он требует параметр string name. Если бы в Asset было несколько конструкторов, с разным набором параметров, тогда бы компилятор сказал, что у Asset отсутствует конструктор без параметров.

Одним словом, надо помнить, что если вдруг у родителя отсутствует дефолтный конструктор, то нам в конструкторах потомка придется явно вызвать какой-нибудь конструктор родителя. Делается это через ключевое слово `super`:

```java
public class House extends Asset {
    public long cost;

    public House(String name, long cost)
    {
        super(name);  // Явно вызываем конструктор родителя
        System.out.println("Выполняется конструктор House.");
        this.cost = cost;
    }
}
```

## Ключевое слово super

Само по себе ключевое слово `super` предназначено для *невиртуального* доступа к элементу родительского класса. При этом super не является ссылкой на экземпляр родителя. Проще говоря, используя super мы можем из потомка вызвать родительскую реализацию нужного метода. Например, когда нам нужно дополнить родительскую реализацию:

TODO: вернуться сюда



# Поиск метода

TODO: Новый Хорстман, 338стр. Это очень трудно понять, потому что в книге чуется какая-то очень сильная недомолвка, т.е. объяснено как-то кусочно, с серединки на половинку, такими формулировками, что до конца невозможно понять. Объяснение не самостоятельное. Так что оставлю это как есть, потом догуглю. А то уж очень много времени уходит на это.

```java
public class C { ... }
var c = new C();
x.f("hello", 7);
```

Процесс определения метода, который нужно вызвать, выглядит примерно так:

* Компилятор берет тип ссылки, в которой лежит объект. В данном примере это тип `C`.
* Компилятор пробегает по методам этого типа и по доступным методам его родителей и подбирает всех подходящих по сигнатуре кандидатов. Типы параметров при необходимости проходят конвертацию. Если даже после конвертации ни один подходящий метод не найден, компилятор выдает ошибку.
* Если найденный метод является private, static, final или это конструктор, тогда компилятор понимает, что именно из этого типа необходимо будет вызвать метод. Это *статическое связывание*.
* Если метод не является ни тем, ни другим, тогда метод придется определять в рантайме, на основе объекта, который фактически лежит в переменной `x`. В этом случае компилятор задает вызов с  *динамическим связыванием*.
* Когда программа уже запущена, при загрузке класса в память виртуальная машина составляет для него таблицу методов. В нее входят методы самого класса и все унаследованные от родителей. В таблице есть вся необходимая информация для поиска в ней метода и вызова - сигнатура, адрес метода и т.д.
* Когда дело доходит до вызова, виртуальная машина





# Было написано

# Список вопросов

- [ ] Ковариантные типы
- [ ] Встраивание методов

# Наследование и private-поля

Наследуются все члены базового класса. Однако доступа к приватным полям суперкласса из потомка напрямую нет - он должен пользоваться открытым интерфейсом. Для обращения к членам суперкласса используется слово `super`.

```java
package com.company.sampleprog;

class Employee {
    private int salary;  // <-- Приватное поле наследуется, но напрямую недоступно подклассу

    public void setSalary(int salary) {
        this.salary = salary;
    }

    public int getSalary() {  // <-- Подклассу придется как и всем остальным пользоваться
        return this.salary;   // публичным методом, чтобы получить значение зарплаты
    } 
}
```

Наследование оформляется через слово `extends`:

```java
package com.company.sampleprog;

class Manager extends Employee {
    private int bonus;

    public void setBonus(int bonus) {
        this.bonus = bonus;
    }

    public int getBonus() {
        return this.bonus;
    }

    public int getSalary() {
        int baseSalary = super.getSalary();  // <-- Через super. подкласс может вызвать публичный
        return this.bonus + baseSalary;      // интерфейс суперкласса
    }
}
```

```java
package com.company.sampleprog;

public class Main {
    public static void main(String[] args) {
        Employee mark = new Manager();
        mark.setSalary(15_000);
        mark.setBonus(5_000);
        System.out.println(mark.getSalary());
    }
}
```

# Наследование и конструкторы

При создании объекта подкласса вызывается конструктор суперкласса. Если явно не сделать это, то подкласс попробует вызвать дефолтный конструктор суперкласса. Если его нет, будет ошибка компиляции:

```java
class Employee {
    private final String name;
    
    // теперь компилятор не создаст автоматически дефолтный конструктор
    public Employee(String name) {
        this.name = name;
    }
    ...
}

class Manager extends Employee {
    ...  // При создании Manager попробует вызвать дефолтный конструктор Employee, которого нет
}
```

Поскольку мы объявили в Employee конструктор с одним параметром, значит дефолтного конструктора компилятор автоматически не создает, а Manager будет пытаться его вызвать. Так что нужно или объявить дефолтный конструктор в Employee, или явно вызвать какой-нибудь конструктор из Manager, с помощью `super(...)`:

```java
class Manager extends Employee {
    ...
    public Manager(String name) {
        super(name);  // <-- Явно вызываем конструктор суперкласса
    }
    ...
}
```

# override

Переопределение - это режим по умолчанию для методов, имеющих одинаковую сигнатуру в суперклассе и подклассе. Но при этом они могут возвращать разные типы, т.к. тип в сигнатуру не входит. TODO Хорстман Том 1 с 206???Ковариантные возвращаемые типы.

Т.е. чтобы переопределить метод, достаточно в подклассе создать метод с такой же сигнатурой, как у метода в суперклассе. Но есть нюанс. Можно ошибиться в типе параметра и получится не переопределенный метод, а новый, и заметить эту ошибку может быть трудно.

Например, у Object есть метод `equals(Object otherObject)`. Если в своем классе "переопределить" его как `equals(Employee emp)`, то никакого переопределения не будет, потому что у метода в нашем классе тип параметра Employee, а не Object. Для этих целей есть аннотация `@Override`, которую следует применять ко всем переопределяемым методам. Тогда, если переопределения не произошло, будет ошибка компиляции.

# Поиск метода (черновик)

TODO Хорстман, Том 1, с 205. Однозначно понять по тексту пока не получается, поэтому догуглить потом дополнительно. Здесь предварительная понималка.

Есть тип *объявленный*, а есть *фактический*. Т.е. если мы положим объект типа Manager в переменную типа Employee, то объявленный тип будет Employee, а фактический - Manager.

Виртуальная машина всегда знает о *фактическом* типе объекта. Т.е. в этой ситуации ВМ понимает, что это на самом деле объект типа Manager, а не Employee. *Полиморфизм* - это способность переменной ссылаться на объекты, имеющие разные фактические типы.

Виртуальная машина составляет для класса таблицу методов. В ней, грубо говоря, две колонки: одна - под сигнатуру метода, вторая - под непосредственно метод, который надо вызвать, когда встречается эта сигнатура. Является ли метод public или private, final или static, является ли он конструктором - это тоже виртуальной машине известно. В таблице видно, какой метод является собственным, какой - унаследованным, а какой - переопределенным.

Если метод является конструктором, private, static или final - это *статическое связывание*, т.е. уже на этапе компиляции известно, из какого типа надо брать метод. В самом деле, приватный метод или статический - всегда относится только к одному типу - тому, в котором он определен.

Если метод не является ни одним из вышеперечисленных, значит это *динамическое связывание*. И метод будет браться из фактического типа объекта.

С учетом всего сказанного, нужный метод вычисляется примерно так:

* Взять объявленный тип за основу места поиска метода
* Найти в таблице методов объявленного типа все методы с интересующим именем
* По типам переданных в метод аргументов понять, какой именно из найденных методов нужен
* Если метод является конструктором, private, static, final - использовать метод из объявленного типа
* Если не является, тогда взять метод из фактического типа