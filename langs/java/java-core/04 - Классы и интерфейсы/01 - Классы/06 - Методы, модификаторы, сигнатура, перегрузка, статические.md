# Методы

## Доступные модификаторы

TODO

## Сигнатура метода

Сигнатура метода включает в себя:

- Имя метода
- Тип и *последовательность* параметров

Сигнатура НЕ включает:

- Возвращаемое методом значение
- Имена параметров

## Обычный синтаксис

```java
public class MethodDemo {
    public static String Foo() {
        return "public static method Foo()";
    }
}
```

В Java для методов характерен следующий стиль:

* Имя метода пишется с большой буквы.
* Открывающая фигурная скобка ставится на одной строке с объявлением метода.

## Перегрузка (overload)

Перегрузка - *overload*, когда в классе есть несколько методов с одинаковым именем, но разным набором параметров. Порядок параметров имеет значение, поэтому (int, string) и (string, int) считается разным набором параметров.

> Не путать с *переопределением - override*, когда один и тот же метод ведет себя по-разному в родительском классе и подклассе.

Для перегрузки нет ключевых слов, достаточно просто правильно написать методы:

```java
public class OverloadDemo
{
    public int foo() {
        return 5;
    }
    public void foo(String message) {
        System.out.println(message);
    }
    public String foo(int x, String message) {
        return Integer.toString(x) + message;
    }
    public String foo(String message, int x) {  // Ok, т.к. порядок разный
        return Integer.toString(x) + message;
    }
}
```



## Статические методы

TODO: В принципе очевидные вещи. Что принадлежат классу, а не экземпляру, поэтому не получают неявного параметра при вызове.  Не могут вызывать методы экземпляра и т.д. Стоит дописать потом, когда более важные вещи будут готовы.

# TODO

Просто какие-то факты, связанные с темой, которые можно было бы вписать, когда дело дойдет до полноценного оформления этой темы.

## Явные и неявные параметры

Стр 146

Говорится о том, что у каждого метода класса есть два типа параметров:  явные и неявный. Неявный - это this. Он неявно передается в метод, когда мы вызываем его на объекте:

```java
Person p = new Person();
p.setName("JohNy");  // Вот тут строка "JohNy" это явный параметр, а еще туда передастся ссылка на объект, которая будет доступна через this
```



## Доступ к приватным полям

Интересный факт - методы объекта имеют доступ к приватным полям не только “своего” объекта, но и других объектов *того же типа* (ничего интересного, похоже это естественно, в C# так же):

```java
public class MyProgram
{
    public static void main(String[] args)
    {
        Employee vasya = new Employee();
        vasya.setName("Vasiliy");
        
        Employee petya = new Employee();
        petya.setName("Petr");
        
        String fused = vasya.some(petya);
        System.out.println(fused);
    }
}


class Employee {
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String some(Employee emp) { // Объект, получив в этот метот агрумент такого же типа,
        return this.name + " " + emp.name;  // сможет напрямую обращаться к приватному полю
    }
}
```



## Статические методы и экземпляры

Статические методы можно использовать и на объектах, а не только на классах. Но делать этого не рекомендуется, поскольку приводит к путанице.

СМ широко используются для создания статических фабричных методов. Преимущества статических ФМ перед конструкторами в том, что имя конструктора должно совпадать с именем класса и возвращает всегда один тип - самого класса. А статический ФМ может иметь любое имя и возвращать разные типы.

Пример: класс `NumberFormat` и его статический ФМ `getCurrencyInstance()` и `getPercentInstance()`

## Метод main в любом классе

Метод static void main(String[] args) можно добавить в любой класс, компилировать и запускать потом через java MyClassName, чтобы быстро протестировать.