# Вложенные классы

## Виды вложенных классов

"Классы внутри класса" бывают двух видов:

* Статические - обозначаются термином "nested".
* Обычные - обозначаются термином "inner". Бывают двух видов:
  * Анонимные (anonymous)
  * Локальные (local)

Далее я буду пользоваться именно этими терминами, nested-класс и inner-класс. Можно было бы говорить вложенный и внутренний соответственно, но так их легче перепутать, поэтому лучше на оригинале.

```java
public class Outer {  // Внешний класс
    
    class Inner {  // inner-класс, вложенный обычный
        
    }
    
    static class Nested {  // nested-класс, вложенный статический
        
    }
}
```

## Причины использовать вложенные классы

Есть несколько причин использовать вложенные классы:

* Если классу А требуется "хелпер", который больше никому не нужен, то логичнее всего объявить этот хелпер как внутренний класс в А, чтобы не засорять общее пространство.
* Если классы А и В тесно связаны; В логически не существует без А; В нужен свободный доступ ко всем элементам А; тогда В удобнее всего будет объявить внутри А. Пример - классы представлений и итераторов элементов внутри коллекций, например, HashMap. Коллекция и представление тесно связаны - если нет коллекции, то нет и ее представления; представлению нужен полный доступ к внутренним данным коллекции, безо всяких лишних геттеров. Поэтому классы представлений и итераторов объявлены внутренними.

## Сравнительные характеристики вложенных классов

Для вложенных классов характерно:

* Могут использовать все доступные модификаторы доступа: private, public, protected и без модификатора (package-friendly)
* Имеют прямой доступ к элементам внешнего класса. В случае nested-класса доступ к не-static элементам внешнего возможен очевидно только через экземпляр.



```java
public class Outer {
    // static поля
    public static String oStaticPublic = "oStaticPublic";
    private static String oStaticPrivate = "oStaticPrivate";
    // Обычные поля
    public String oPublic = "oPublic";
    private String oPrivate = "oPrivate";

    class Inner {
        private static String iStaticPrivate = "iStaticPrivate";  // Могут иметь static поля и методы
        private String iPrivate = "i";  // Могут иметь обычные поля и методы

        public void accessOuter() {
            // Доступ к static
            System.out.println(oStaticPublic);  // Есть
            System.out.println(oStaticPrivate);  // Есть
            // Доступ к обычным (можно напрямую)
            System.out.println(oPublic);  // Есть
            System.out.println(oPrivate);  // Есть
        }
    }

    static class Nested {
        private static String nStaticPrivate = "nStaticPrivate";  // Могут иметь static поля и методы
        private String nPrivate = "nPrivate";  // Могут иметь обычные поля и методы

        public void accessOuter(Outer outer) {
            // Доступ к static
            System.out.println(oStaticPublic);  // Есть
            System.out.println(oStaticPrivate);  // Есть
            // Доступ к обычным (только через экземпляр, напрямую - нельзя)
            System.out.println(outer.oPublic);  // Есть
            System.out.println(outer.oPrivate);  // Есть
        }
    }
}
```





## Nested-классы

Обладают следующими характеристиками:

* Имеют доступ к статическим элементам внешнего класса, т.к. сами являются статическими. По этой причине очевидно не имеют доступа к нестатическим элементам.



## Inner-классы

Обладают следующими характеристиками:

* Имеют доступ ко всем элементам внешнего класса, даже если они приватные.
* Связаны с экземпляром внешнего класса, поэтому:
  * Существуют только совместно с экземпляром внешнего класса.
  * Не могут иметь собственных статических элементов. ??? Да как не могут-то, когда могут?!







```java
public class TalkingClock {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beep) {
        this.interval = interval;
        this.beep = beep;
    }

    public void start() {
        var listener = new TimePrinter();
        var timer = new Timer(interval, listener);
        timer.start();
    }


    public class TimePrinter implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("The time is " + Instant.ofEpochMilli(e.getWhen()));
            if (beep) {
                System.out.println("Beep-beep!");
            }
        }
    }
}
```



An inner class is a class that is defined inside another class. Why would you want to do that? There are two reasons:

• Inner classes can be hidden from other classes in the same package. 

• Inner class methods can access the data from the scope in which they are defined—including the data that would otherwise be private.

The outer class reference is set in the constructor. The compiler modifies all inner class constructors, adding a parameter for the outer class reference

```java
public TimePrinter(TalkingClock clock) { // automatically generated code
   outer = clock;
}
```







```java
public void start() {
    var listener = new TimePrinter();
    // var listener = new TimePrinter(this);  // Компилятор сам передаст this
}
```



We could have declared the TimePrinter class as private. Then only TalkingClock methods would be able to construct TimePrinter objects. Only inner classes can be private. Regular classes always have either package or public access

 an object of an inner class always gets an implicit reference to the object that created it (see Figure 6.3). This reference is invisible in the definition of the inner class. However, to illuminate the concept, let us call the reference to the outer object outer. Then the actionPerformed method is equivalent to the following:

The outer class reference is set in the constructor. The compiler modifies all inner class constructors, adding a parameter for the outer class reference.









**Terminology:** Nested classes are divided into two categories: non-static and static. Non-static nested classes are called *inner classes*. Nested classes that are declared `static` are called *static nested classes*. 

```java
class OuterClass {
    ...
    class InnerClass {
        ...
    }
    static class StaticNestedClass {
        ...
    }
}
```





An instance of `InnerClass` can exist only within an instance of `OuterClass` and has direct access to the methods and fields of its enclosing instance.

To instantiate an inner class, you must first instantiate the outer  class. Then, create the inner object within the outer object with this  syntax:

```
OuterClass outerObject = new OuterClass();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
```