# Вложенные классы

## "inner" и "nested" вложенные классы

"Классы внутри класса" бывают двух видов:

* Статические - обозначаются термином "nested".
* Обычные - обозначаются термином "inner".

```java
public class Outer {  // Внешний класс
    
    class Inner {  // inner-класс, вложенный обычный
        
    }
    
    static class Nested {  // nested-класс, вложенный статический
        
    }
}
```

Главное отличие между ними в том, что:

* Экземпляр nested-класса может быть создан и существовать сам по себе.

* Экземпляр inner-класса  может быть создан только после создания экземпляра внешнего класса и может существовать только совместно с ним. В примерах дальше это рассмотрено.

## Причины использовать вложенные классы

> Реальный пример использования вложенных классов можно найти, например, в стандартных реализациях джавовских коллекций, например, внутри класса HashMap. Они там используются для реализации классов-представлений для данных и ключей словаря, и итераторов по этим представлениям.

Есть несколько причин использовать вложенные классы:

* Если классу А требуется "хелпер", который больше никому не нужен, то логичнее всего объявить этот хелпер как внутренний класс в А, чтобы не засорять общее пространство.
* Если классы А и В тесно связаны; В логически не существует без А; В нужен свободный доступ ко всем элементам А; тогда В удобнее всего будет объявить внутри А. Пример - классы представлений и итераторов элементов внутри коллекций, например, HashMap. Коллекция и представление тесно связаны - если нет коллекции, то нет и ее представления; представлению нужен полный доступ к внутренним данным коллекции, безо всяких лишних геттеров. Поэтому классы представлений и итераторов объявлены внутренними.

## Особенности вложенных классов

Пока писал конспект и экспериментировал на примерах, я не выявил каких-то странных особенностей у вложенных классов. Общие выводы такие:

* Вложенные классы по сути умеют все то же самое, что и обычные классы и воспринимать их стоит именно как обычные классы, просто с расширенным доступом к своему "классу-контейнеру". У Хорстмана в книге от 2021 года написано, что у вложенных классов, например, не может быть статических методов и полей. Но с JDK 16 это ограничение убрано, теперь может.
* Раз вложенные классы написаны внутри другого класса, то это максимально естественно, что они имеют полный доступ к его полям и методам. Ведь методы класса имеют доступ к полям и другим методам, поэтому и у вложенных классов такая же логика доступа - раз объявлены внутри класса, то имеют доступ к его элементам. Синтаксис создания экземпляров внутренних классов тоже логичный, если призадуматься.

## Создание экземпляров

Особенности создания экземпляров:

* Тип внутреннего класса пишется как `ВнешнийКласс.ВнутреннийКласс obj = ...`

* Экземпляр статического внутреннего класса может быть создан и существовать сам по себе.

* Экземпляр не-static внутреннего класса  может быть создан только после создания экземпляра внешнего класса и может существовать только совместно с ним.

  Компилятор автоматически модифицирует все конструкторы вложенных не-static классов, добавляя им параметр типа внешнего класса, чтобы передавать через него ссылку на экземпляр внешнего. Эта передача тоже осуществляется автоматически.

### Создание экземпляров "снаружи"

Снаружи - означает за пределами внешнего класса, например из main:

```java
class App {
    public static void main(String[] args) {
        
        // Внешний
        var outer = new Outer();  // Никаких особенностей
        
        // Внутренний обычный
        var outer = new Outer();
        Outer.Inner inner = outer.new Inner();  // new обязательно используется НА ЭКЗЕМПЛЯРЕ внешнего класса,
        // так что ссылка на него попадает к экземпляру внутреннего
        
        // Внутренний статический
        Outer.Nested nested = new Outer.Nested();
        
    }
}
```

### Создание экземпляров "изнутри"

Изнутри - означает в пределах внешнего класса.

```java
public class Outer {
    
    public void greet() {
        System.out.println("Outer instance");
        // inner неявно получит ссылку this, указывающую на экземпляр Outer
        var inner = new Inner();  // краткий синтаксис
        var inner = this.new Inner();  // полный синтаксис, с указанием ссылки на внешний класс
        inner.greet();
        
        var nested = new Nested();
        nested.greet();
    }

    class Inner {
        // class Inner(Outer outer, наши параметры) { }  // Компилятор сам создаст \ модифицирует все 
        // конструкторы так, чтобы они кроме объявленных нами параметров также еще имели ссылку 
        // на экземпляр внешнего класса
        
        // @Override   // оверрайд не нужен, т.к. классы не родственники
        public void greet() {
            System.out.println("Inner instance");
        }
    }

    static class Nested {
        // @Override   // оверрайд не нужен, т.к. классы не родственники
        public void greet() {
            System.out.println("Nested instance");
        }
    }
}
```

```java
class App {
    public static void main(String[] args) {
        var outer = new Outer();
        outer.greet();
    }
}
```

## Модификаторы, доступ к элементам внешнего класса

Для вложенных классов характерно:

* К ним можно применить любой модификатор доступа: private, public, protected и без модификатора (package-friendly), в отличие от обычных классов, которые могут быть либо public, либо package-friendly.
* Имеют доступ ко всем элементам внешнего класса, даже к приватным.
* Полный синтаксис доступа к элементам внешнего класса из не-static вложенного выглядит как `ИмяВнешнегоКласса.this.имяЭлемента`

```java
public class Outer {
    // static поля
    public static String oStaticPublic = "oStaticPublic";
    private static String oStaticPrivate = "oStaticPrivate";
    // Обычные поля
    public String oPublic = "oPublic";
    private String oPrivate = "oPrivate";

    // Обычный вложенный класс
    class Inner {
        private static String iStaticPrivate = "iStaticPrivate";  // Могут иметь static поля и методы
        private String iPrivate = "i";  // Могут иметь обычные поля и методы

        public void accessOuter() {
            // Доступ к static
            System.out.println(oStaticPublic);  // Есть
            System.out.println(oStaticPrivate);  // Есть
            // Или полный синтаксис
            System.out.println(Outer.oStaticPublic);
            System.out.println(Outer.oStaticPrivate);
            
            // Доступ к обычным
            System.out.println(oPublic);  // Есть
            System.out.println(oPrivate);  // Есть
            // Или полный синтаксис
            System.out.println(Outher.this.oPublic);  // Есть
            System.out.println(Outher.this.oPrivate);  // Есть
        }
    }

    // Статический вложенный класс
    static class Nested {
        private static String nStaticPrivate = "nStaticPrivate";  // Могут иметь static поля и методы
        private String nPrivate = "nPrivate";  // Могут иметь обычные поля и методы

        public void accessOuter(Outer outer) {
            // Доступ к static
            System.out.println(oStaticPublic);  // Есть
            System.out.println(oStaticPrivate);  // Есть
            // Или полный синтаксис
            System.out.println(Outer.oStaticPublic);
            System.out.println(Outer.oStaticPrivate);
            
            // Доступ к обычным, используя экземпляр
            System.out.println(outer.oPublic);  // Есть
            System.out.println(outer.oPrivate);  // Есть
        }
    }
}
```

## Совпадение имен полей и методов с внешним классом

Имена полей и методов вложенного класса могут совпадать с именами внешнего. В этом случае собственные перекрывают внешние, но к ним все еще можно обратиться:

```java
public class Outer {
    private static String fStaticString = "hello";
    private String fString = "outer";

    class Inner {
        private static String fStaticString = "I am";
        private String fString = "inner";

        public void shadowingMemberNames() {
            // Обращение к своим, кратко
            System.out.println(fStaticString);  // I am
            System.out.println(fString);  // inner
            
            // Обращение к своим, полная форма
            System.out.println(Inner.fStaticString);  // I am
            System.out.println(this.fString);  // inner
            
            // Обращение к внешним
            System.out.println(Outer.fStaticString);  // hello
            System.out.println(Outer.this.fString);  // outer
        }
    }
    
    static class Nested {
        private static String fStaticString = "me is";
        private String fString = "nested";

        public void shadowingMemberNames(Outer outer) {
            // Обращение к своим, кратко
            System.out.println(fStaticString);  // me is
            System.out.println(fString);  // nested
            // Обращение к своим, полная форма
            System.out.println(Nested.fStaticString);  // me is
            System.out.println(this.fString);  // nested
            // Обращение к внешним
            System.out.println(Outer.fStaticString);  // hello
            System.out.println(outer.fString);  // outer - требуется экземпляр
        }
    }
}
```
