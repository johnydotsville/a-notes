# Объявление интерфейса

Все члены интерфейса по умолчанию public. Поэтому в самом интерфейсе писать это явно не надо (если написать, ошибки компиляции не будет, но это лишнее).

## Простой интерфейс

```java
public interface Movable {
    void move();
    // Статические константы
    // Абстрактные методы
    // Дефолтные методы
    // Приватные \ статические методы
}
```

## Дженерик-интерфейс

```java
public interface Fillable<T> {
    boolean fill(T fuel);
    // Статические константы
    // Абстрактные методы
    // Дефолтные методы
    // Приватные \ статические методы
}
```

В качестве типа для дженерика тоже может быть интерфейс:

```java
interface Fuel { }
class Gas implements Fuel {  }

class Car implements Movable, Fillable<Fuel> {
    public void fill(Fuel fuel) {
        
    }
}

var car = new Car();
car.fill(new Gas());
```

# Реализация интерфейса классом

* Осуществляется через ключевое слово `implements`
* Класс может реализовывать сколько угодно интерфейсов. Их просто нужно перечислить через запятую.

```java
public class Car 
    implements Movable, Fillable<Gas> {  // <-- Для дженерика указываем тип
    
}
```

# Содержимое интерфейса

## Статические константы

В интерфейсе можно объявить не только методы, но и статические константы:

* С виду они могут быть похожи на обычные поля, но это обманка. Просто компилятор сам подставляет `public static final`

* Могут быть только публичными.

* В классах, реализующих интерфейс, можно пользоваться статическими константами напрямую, без указания имени интерфейса.

  Полей в интерфейсе быть не может, потому что поля - это переменные экземпляра. А поскольку интерфейс - не класс, то и создать экземпляр интерфейса нельзя. Поэтому и полей у него быть не может.

```java
public interface Movable {
    public static final int FUEL_LIMIT = 50;
    int SAFE_SPEED_LIMIT = 200;  // Не путать с полем! Компилятор сам добавляет public static final
    
    void move();
}

class Car implements Movable {
    @Override
    public void move() {
        System.out.println("Машина едет со скоростью " + SAFE_SPEED_LIMIT + " км/ч");
    }
}
```

## Методы

### Абстрактные методы

* Это методы интерфейса, не имеющие реализации.
* Никаких ключевых слов не требуют.
* Могут быть только публичными и слово public можно не писать.

```java
public interface Movable {
    void move();  //  public void move, но public можно не писать
}
```

### Дефолтные методы

* Для них мы пишем реализацию по умолчанию.
* Объявляются с помощью ключевого слова `default`
* Могут быть только публичными и слово public можно не писать.

```java
public interface Movable {
    default void move(int speed) {
        System.out.println("Мы едем со скоростью " + speed + " км/ч");
    }
}
```

Дефолтные методы полезны по нескольким причинам:

* Отпадает необходимость создавать абстрактные классы, чтобы сделать какую-нибудь дефолтную реализацию метода. Абстрактные классы теперь можно использовать для сложных случаев, а в простых - писать реализацию прямо в интерфейсе.

* Если класс А реализует интерфейс, то при добавлении в интерфейс нового метода без дефолтной реализации придется дописать реализацию в класс А, иначе он не скомпилируется.

  Если пользоваться классом без перекомпиляции, он будет работать, т.к. добавление метода в интерфейс не нарушает бинарную совместимость. Однако только до тех пор, пока на нем не попытаются вызвать отсутствующий метод. Тогда получится ошибка AbstractMethodError.

  Дефолтная реализация решает обе проблемы. Класс будет компилироваться, потому что ему не надо писать реализацию, и не будет ломаться без перекомпиляции, т.к. реализация есть в интерфейсе.

### Статические методы

* Принадлежат непосредственно интерфейсу
* По умолчанию публичные, но могут быть и приватными.
* Поскольку статические, то могут в себе вызывать только другие статические методы.

```java
public interface Movable {
    int SAFE_SPEED_LIMIT = 200;
    
    static boolean canRideBeDangerous(int maxSpeedAvailable) {
        return maxSpeedAvailable > SAFE_SPEED_LIMIT;
    }
}
```

До Java 8, если к интерфейсу хотелось приделать статические методы, то просто создавали парный класс с похожим названием и клали их туда. Из реального примера - в самой Java есть интерфейс Collection и класс Collections.

### Приватные

* Видны и могут использоваться исключительно в самом интерфейсе. Поэтому обязаны иметь реализацию.
* Объявляются ключевым словом `private`
* Могут быть статическими.

```java
public interface Movable {
    int SAFE_SPEED_LIMIT = 200;

    private boolean isSafeSpeedOverlimited(int currentSpeed) {
        return currentSpeed > SAFE_SPEED_LIMIT;
    }
    
    static private int compareToSafeSpeedLimit(int value) {
        return Integer.compare(value, SAFE_SPEED_LIMIT);
    }
}
```

В приватных методах обычно пишется вспомогательный код, который мб полезен в следующих случаях:

* Несколько дефолтных методов используют какой-то одинаковый код в своей работе. В этом случае его можно вынести в приватный метод и убрать таким образом дублирование.
* Дефолтные методы имеют сложную реализацию и их код удобнее разнести по отдельным методам, для наглядности. Эти методы можно сделать приватными, чтобы класс, реализующий интерфейс, их не видел. Таким образом интерфейс выглядит чище снаружи.

## Коллизия методов

### Одинаковый метод в родителе и интерфейсе

Когда класс реализует некий интерфейс, где есть метод с дефолтной реализацией, и при этом в родителе класса есть метод с аналогичной сигнатурой, то побеждает метод из родителя.

```java
public class Parent {
    public void foobar() {  // <-- В родителе есть метод foobar()
        System.out.println("Это метод foobar из класса Parent");
    }
}

public interface IFace {  // <-- И в интерфейсе есть идентичный метод foobar(),
    default void foobar() {  // причем с дефолтной реализацией
        System.out.println("Это метод foobar из интерфейса IFace");
    }
}

public class Child extends Parent
    implements IFace {  // <-- Наследник класса реализует интерфейс,
}  // стало быть он оказывается перед выбором, какой метод использовать
...

IFace child = new Child();  // <-- Тип ссылки - IFace
child.someMethod();  // "Это foobar из класса Parent", но используется реализация из родителя
```

Если метод переопределить, тогда очевидно будет использоваться собственная реализация потомка:

```java
public class Child extends Parent implements IFace {
    @Override public void foobar() {
        System.out.println("Я Child и это мой личный метод foobar");
    }
}
...

IFace bar = new Subclass();  // <-- Тип ссылки - IFace
bar.someMethod();  // "Я Subclass и это мой личный метод someMethod"
```

### Одинаковые методы в нескольких интерфейсах

Класс реализует два интерфейса, и в обоих есть метод с одинаковой сигнатурой.

```java
public interface A {
    default void foobar() {
        System.out.println("Этот метод foobar интерфейса A");
    }
}

public interface B {
    default void foobar() {
        System.out.println("Интерфейс B предоставил метод foobar");
    }
}

public class Clazz implements A, B {
    // Ошибка компиляции! Хз какой метод выбрать.
}
```

В ситуации, когда конфликт случается между методами интерфейсов, возникает ошибка компиляции. Причем даже если только у одного интерфейса есть реализация по умолчанию, то все равно возникает ошибка. Важен сам факт, что в двух интерфейсах два метода с одинаковой сигнатурой.

В этом случае надо явно переопределить в классе метод и либо написать свою реализацию, либо вызвать реализацию из желаемого интерфейса с помощью конструкции `ИмяИнтерфейса.super.метод()`:

```java
public class Clazz implements A, B {
    @Override public void foobar() {
        // Либо пишем свою реализацию
        // Либо вызываем дефолтную из нужного интерфейса (если она конечно есть)
        A.super.foobar();
    }
}
```

# Наследование интерфейсов

Один интерфейс может расширять другой с помощью ключевого слова `extends`:

```java
public interface Fillable extends Movable {
    
}
```

# Принадлежность к интерфейсу

Объекты, реализующие интерфейс, можно класть в переменные типа соответствующего интерфейса:

```java
Movable mov = new Car();
Fillable fil = new Car();
```

Проверить, реализует ли объект какой-либо интерфейс, можно с помощью оператора `instanceof`:

```java
boolean carIsMovable = car instanceof Movable;  // true
boolean carIsFillable = car instanceof Fillable;  // true
```

# Дополнительно

Есть еще дополнительные возможности, вроде вложения интерфейсов друг в друга, объявление класса внутри интерфейса и возможно еще какие-то не совсем типичные сценарии. О всем этом я писать не стал, потому что ни разу не видел, чтобы это где-то использовалось. Вот когда увижу, тогда и напишу.

