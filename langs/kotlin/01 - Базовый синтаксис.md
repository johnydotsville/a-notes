# Переменные

## Обычные

```kotlin
val playerName: String = "JohNy";
val playerHero = "Slark";

var playerLevel: Int = 10;
var playerExp = 587;
```

Итак, переменные объявляются с помощью двух ключевых слов:

* var - переменные, которые могут изменяться со временем
* val - переменные, которые не могут изменяться. После первого присваивания значение изменить уже не удастся, будет ошибка компиляции.

Тип переменной указывается через `:` после имени и может быть опущен, если переменная тут же инициализируется и ее тип очевиден. Если переменная инициализируется не сразу, тип обязателен.

## Константы времени компиляции

```kotlin
const val MAX_HERO_LEVEL: Int = 25;  // <-- Вот она

fun main(args: Array<String>) {
    ...
}
```

Это константы, "не принадлежащие" функциям или классам, они находятся на самом верхнем уровне, "в открытом космосе".

> В итоге конечно после компиляции в байт-код все эти "независимые" переменные и функции будут внутри статических классов, но при написании это довольно удобно - не писать классы ради классов, а просто голые функции в файлах.

Они могут быть только базовых типов. По умолчанию у них модификатор доступа public и их можно использовать в любых других файлах. Можно поменять на private и тогда пользоваться можно будет только в текущем файле. Аналогично по модификаторам касается функций. Но о функциях дальше еще будет.

## Типы

В Kotlin есть только ссылочные типы. Примитивов не существует. Компилятор автоматически подставляет вместо ссылочного типа соответствующий примитив, если это возможно. Т.е. Int заменится на int, а String останется String. Поэтому производительность не страдает, а путаницы в коде меньше. Доступные базовые типы:

```kotlin
String
Int
Double
Float
Long
Short
Byte
Char
Boolean
```

# Условные операторы

## Сравнение, логические

```kotlin
>, >== <, <==
==, !=
===, !=== (указывают ли две ссылки на один объект или нет)
```

```kotlin
&&, ||, ! - классические "и", "или", "не"
```

```kotlin
val result = positive && simple || value < 1000
```



## if, else if

Оператор максимально классический:

```kotlin
var currentHp = 100;
    
if (currentHp > 0) {  // <-- Скобки можно не писать, если одна строка
    println("Хилимся-живем");
} else {
    println("Потрачено");
}
```

Множественные условия:

```kotlin
if (currentHp > 50) {
    println("Бодрячком");
} else if (currentHp > 20) {
    println("Жив еще");
} else if (currentHp > 0){
    println("Плохо дело");
} else {
    println("Потрачено");
}
```

Можно использовать if-else прямо в выражении. В этом случае обязательны ветки else:

```kotlin
val hpBarColor = if (hp > 50) "Green" else if (hp > 25) "Yellow" else "Red";
```

## when

```kotlin
val hpBarColor = when (hp) {
    in 50..100 -> "Green"
    in 25..50 -> "Yellow"
    else -> "Red"
}
```

Здесь использован синтаксис *интервалов*.

# Интервалы

Оператор `in 5..10` называется *интервал* и его можно использовать в if тоже:

```kotlin
val hpBarColor = if (hp in 50..100) "Green" else if (hp in 25..49) "Yellow" else "Red";
```

Интервалы имеют разный синтаксис:

* `5..10` - от 5 до 10 включительно
* `5 until 10` - от 5 до 10, не включая 10
* `10 downTo 1` - от 10 до 1 включительно (исключительно - нет такой встроенной возможности)
* `___ step 2` - использовать вышеуказанные синтаксисы с нужным шагом, например `1..10 step 2`

Все эти вещи можно использовать там, где требуется интервал: в условиях, циклах, и т.д., используем синтаксис `переменная in (интервал)` (скобки можно не писать, но когда с ними нагляднее, лучше ставить):

```kotlin
for (i in (10 downTo 1)) {
    println(i);
}
```

## Рецепты

* Интервалы работают и с буквами: `'x' in 'a'..'z'`
* Можно быстро формировать список: `(1..5).toList()`

# Вычисляемые строки

В строки можно добавлять значения непосредственно, без конкатенации, через `$`: 

```kotlin
val message = "Current hp: $hp";
```

Можно добавить также вычисляемое выражение через `${}`:

```kotlin
val medtkitsStatus = "Has medkits: ${if (hasMedkits) "Yes" else "No"}";
```

# Функции

## Обычные

```kotlin
public fun foobar(hp: Int, mana: Int, onCooldown: Boolean = true): Int {
    print("Hero has $hp hp and $mana mana. Ult on cooldown: ${if (onCooldown) "yes" else "no"}.");
    return -1;
}
```

* Модификатор по умолчанию - `public`
* Ключевое слово `fun` для определения функции

## Однострочные

Если функция состоит всего из одно строки, можно опустить скобки (и тип результата, но я оставил):

```kotlin
public fun foobar(hp: Int, mana: Int, onCooldown: Boolean = true): String =
    "Hero has $hp hp and $mana mana. Ult on cooldown: ${if (onCooldown) "yes" else "no"}.";
```

## Unit-функции

Это функции, которые ничего не возвращают, как void. В котлине для этого используется тип `Unit`:

```kotlin
public fun likeAVoid(message: String): Unit =
    println(message);
```

Можно Unit в данном случае вообще не писать, компилятор сам поймет, что это Unit.

## Nothing-функции

Этот тип (пока мне кажется странным, не чую в нем смысла) нужен для обозначения функции, которая точно не возвращает значение. Например, ввиду того, что еще не дописана:

```kotlin
public fun nothingFunTest(): Nothing {
    var a = 5;
    throw NotImplementedError("Остальное еще не написали");
}
```

Правда не понятно, почему бы просто не написать нужный тип сразу.

## Перегруженные функции

Классика: можно объявить несколько функций с одинаковым именем, но разным набором параметров:

```kotlin
public fun foobar(name: String): Unit = println(name);
public fun foobar(name: Int): Unit = println(name);
```

Пример немного абсурдный, зато видно, что отличие в типе параметра при прочей идентичности делает функции разными с точки зрения компилятора.

## Необычные имена функций

В котлине есть возможность задавать функциям имена почти с любыми символами, если заключить имя в апострофы (которые на тильде):

```kotlin
public fun `пишите, что хотите!`(message: String): Int = -1;  // Объявление
`пишите, что хотите!`("Самое безумное имя функции");  // Вызов
```

Это нужно для обратной совместимости с джавой, т.к. у языков ключевые слова не совпадают и то, что нормально в джаве, мб зарезервировано в котлине.

## Параметры функций

### Со значениями по умолчанию

Значение по умолчанию просто указывается через `=`:

```kotlin
public fun foobar(hp: Int, mana: Int, onCooldown: Boolean = true): Int {
    print("Hero has $hp hp and $mana mana. Ult on cooldown: ${if (onCooldown) "yes" else "no"}.");
    return -1;
}
```

Параметры со значениями по умолчанию нужно или размещать в конце, или использовать при вызове функции имена параметров.

### Именованные параметры

При вызове функции можно указывать имена параметров. Это дает два преимущества:

* Параметры можно передавать в каком угодно порядке, а не только в том как они объявлены в функции
* Если параметров много, это делает код нагляднее

```kotlin
public fun foobar(hp: Int, mana: Int, onCooldown: Boolean = true): String =
    "Hero has $hp hp and $mana mana. Ult on cooldown: ${if (onCooldown) "yes" else "no"}.";
...
var result = foobar(mana = 250, hp = 140);
```

Просто указываем имя параметра и через `=` значение. Параметры со значениями по умолчанию можно не указывать. Как видно, здесь сначала передается значение маны, а потом - здоровья, хотя в функции они объявлены в другом порядке.

# Прочие фишки

* Точки с запятыми в конце строк можно не ставить