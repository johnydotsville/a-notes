Концепции, связанные с классами. Это именно концепции, которые могут в языках реализовываться разными фичами или даже отсутствовать. Названия сначала хотел придумать нейтральные, но потом решил взять из языков, где они есть, чтобы не путаться и сразу понимать, о чем речь:
* Классы
    
	* Обычный класс
	* `Абстрактный класс` - класс, экземпляр которого нельзя создать.
	* `Статический класс` - класс, экземпляр которого невозможно создать и который содержит только статические элементы.
	* Вложенные классы
	* Частичные классы
	
* Конструкторы
    * `Дефолтный конструктор` - конструктор, который компилятор создает автоматически, если не объявлять никаких конструкторов самостоятельно.
	* `Пользовательские конструкторы` - конструкторы, которые мы пишем самостоятельно.
	* `Чейнинг конструкторов` - вызов из одного конструктора другого конструктора *этого же класса*.
	
* Наследование
    
	* `Вызов родительского конструктора` - вызов из конструктора потомка конструктора родителя, как правило с целью уменьшить код инициализации в потомке или передачи значений для приватных полей родителя (реже).
* Запрет наследования (final в Java, sealed в C#), 
    * Ограничение наследования (в Java это sealed, с 17 jdk)
    * 
    
* Поля
    
	* `Обычные поля` (поля экемпляра) - это поля, принадлежащие экземпляру класса.
* `Статические поля` (поля класса) - это поля, принадлежащие непосредственно классу.
    * Геттеры и сеттеры
    
* Свойства

* `Полиморфизм` - возможность вызывать разные реализации одного и того же метода в зависимости от того, экземпляр какого класса лежит по ссылке, через которую происходит вызов метода.
	
* Методы
  
	* Оверрайдинг, запрет оверрайда
	  
	* Вложенные методы
	  
	* Перекрытие (сокрытие, hiding)
    
  * `Обычные методы` (методы экемпляра) - это методы, для вызова которых нужно обязательно создать экземпляр класса и при вызове воспользоваться ссылкой на этот экземпляр.
  
  * `Статические методы` (методы класса) - это методы, для вызова которых не обязательно создавать экземпляр класса. Их можно вызвать, например, воспользовавшись именем класса.
  
  * `Виртуальный метод` и `Скрытый метод` 
  
  * `Виртуальный метод` (метод фактического экземпляра) - это когда при вызове метода реализация берется из класса экземпляра, лежащего по ссылке, через которую идет вызов.
  
        ```java
        class A { virtual void foo(); }
        class B { void foo(); }
        A link = new B();
        link.foo();
        /* Вызов B.foo(), потому что, хотя тип ссылки link - А, но метод в классе А объявлен как
        виртуальный, стало быть реализацию нужно брать из класса, экземпляр которого фактически 
        будет лежать в ссылке во время выполнения программы
        ```
  
      * `Скрытый метод` (метод ссылки) - это когда при вызове метода реализация берется из класса ссылки, через которую идет вызов и в которой лежит экземпляр.
  
        ```java
        class A { void foo(); }
        class B { hidden void foo(); }
        A link = new B();
        link.foo();
        /* Вызов A.foo(), потому что, хотя по этой ссылке лежит экземпляр класса В, но виртуализация 
        не используется, поэтому вызывается метод из класса самой ссылки
        ```
  
      > Какая-то концепция в одном языке может подразумеваться по умолчанию, а в другом требовать специальных ключевых слов.
  
      
  
* `Статический конструктор` - выполнение кода при загрузке класса в память.

* `Финализатор` - выполнение кода перед уничтожением объекта из памяти.

* `Деконструкция объекта` - синтаксис, позволяющий извлечь поля объекта в переменные.

* Индексаторы

* `Переменные-константы` - 

* `Поля-константы` - 

* `readonly-поля` - 

* Приведение ссылок

    * `upcacting` и `downcasting`
    * Операторы для приведения (as, is, instance of)