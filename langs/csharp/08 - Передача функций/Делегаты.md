# Делегаты

> Делегат - это объект, который знает, как вызывать метод.

Делегат может использоваться для сохранения функций в переменную. Как следствие, таким образом можно передать функцию в другую функцию, вернуть функцию из функции и прочие подобные вещи, на сколько хватит фантазии.

# Объявление делегата

## Общий синтаксис

```c#
delegate int Transform(int x);
```

* Ключевое слово delegate
* Тип возвращаемого значения у функций, с которыми сможет работать делегат.
* Имя делегата. Используется как тип для переменных \ параметров.
* Параметры у функций, с которыми (функциями) сможет работать делегат.

## Где объявлять и как вызвать делегат

Любой объявляемый нами делегат - это класс-наследник класса `System.Delegate`. Стало быть объявлять его, как и любой класс, можно в двух местах: либо на уровне неймспейса, либо внутри другого класса:

```c#
namespace MainAss.DelegatesFolder
{
    public delegate int Transform(int x);  // 1. Объявление на уровне неймспейса

    internal class DelegatesDemo
    {
        public delegate int Transform(int x);  // 2. Объявление как вложенного класса
        
        // Используется тип, который "ближе" к себе, т.е. внутренний:
        private Transform trInner = Square;
        // Для использования внешнего типа надо написать полное имя, с неймспейсом:
        private MainAss.DelegatesFolder.Transform trOuter = Square;

        // Совместимая с делегатом Transform функция, совпадает тип возврата и параметры:
        private static int Square(int x)  
        {
            return x * x;
        }
        
        // Несовместимая функция - не совпадают параметры:
        private static int Sum(int x, int y)
        {
            return x + y;
        }
        
        // Наш делегат как тип параметра tr позволит передать функцию в этот метод
        private static void doSomeTransform(int x, Transform tr)
        {
            int result = tr(x);
        }
        
        // Демонстрация пользования делегатом:
        public static void Main()
        {
            // Объявили переменную типа делегата, положили функцию в нее:
            Transform math = Square;
            // Вызвали через эту переменную лежащую в ней функцию
            int result = math(4));
            
            // Передаем функцию в другую функцию
            doSomeTransform(5, Square);
            doSomeTransform(5, math);
            
            var dd = new DelegatesDemo();
            result = dd.trInner(2);
        }
    }
}
```

Если бы мы захотели пользоваться делегатами из этого примера в других классах, то:

* "Внешний" был бы доступен как MainAss.DelegatesFolder.Transform

* "Внутренний" как MainAss.DelegatesFolder.DelegatesDemo.Transform

  P.S. Доступен, потому что он объявлен как публичный

## new и Invoke

Подобная запись:

```c#
Transform math = Square;
Console.WriteLine(math(4));
```

Является синтаксическим сахаром для фактически вот такой конструкции:

```c#
Transform math = new Transform(Square);
Console.WriteLine(math.Invoke(4));
```

