## Реализация

```typescript
const Direction = {
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right'
} as const;

type DirectionType = typeof Direction[keyof typeof Direction];

function move(direction: DirectionType): void {
  switch (direction) {
    case Direction.UP:
      console.log('Движение вверх');
      break;
    case Direction.DOWN:
      console.log('Движение вниз');
      break;
    case Direction.LEFT:
      console.log('Движение влево');
      break;
    case Direction.RIGHT:
      console.log('Движение вправо');
      break;
  }
}

move(Direction.UP);
```

## Как работает

### Поля типа - это литеральные типы

Когда TS формирует типы, то их поля оформляются как литеральные типы. Например:

```typescript
type User = {
  name: string;
  age: number;
}
```

Здесь поля name и age станут литеральными типами 'name' и 'age'.

Литеральный тип, грубо говоря, это объект вот такого вида:

```typescript
{ kind: 'Literal', value: 'name' }
```

А сам тип User, грубо говоря, что-то вот такое:

```typescript
{
  "properties": {
    "{ kind: 'Literal', value: 'name' }": "string",
    "{ kind: 'Literal', value: 'age' }": "number"
  }
}
```

Если будет другой тип, в котором будет поле name, или например `let foobar = 'name' as const`, то все это будут разные литеральные типы 'name'. Разные в том плане, что это будут разные объекты, но логически при сравнении они будут считаться одинаковыми. P.S. В качестве оптимизаций наверное TS может как-то повторно использовать литеральные типы, но надо было просто концепцию показать, что как бы концептуально это разные типы, а логически - одинаковые. Как-то так.

### Как as const + typeof + keyof работают вместе

- `as const`, примененный к объекту Direction, приводит к тому, что типы его полей становятся не string 'up', 'down', 'left', 'right', а становятся литеральными типами 'up', 'down', 'left', 'right'.
- `keyof typeof Direction`
  - `typeof Direction` получает тип объекта Direction.
    - Сами поля UP, DOWN, LEFT, RIGHT являются литеральными типами 'UP', 'DOWN', 'LEFT', 'RIGHT', как я объяснял выше.
  - `keyof`, примененный к `typeof Direction`, берет поля этого типа и делает из них union. Поскольку поля - это литеральные типы 'UP', 'DOWN', 'LEFT', 'RIGHT', то получается union из этих типов `'UP' | 'DOWN' | 'LEFT' | 'RIGHT'`.
- Далее целая конструкция `typeof Direction[keyof typeof Direction]`
  - Здесь `typeof Direction` опять получает тип объекта Direction.
  - Квадратные скобки, примененные к типу, это Indexed Access Type.
    - Внутри скобок указывается литеральный тип, например `User['name']`.
    - Здесь 'name' - это не строка, а литеральный тип.
    - TS использует литеральный тип непосредственно как ключ для поиска в User поля.
    - Соответственно, конструкция `User['name']` возвращает в итоге тип поля name.
    - Если передать union из литеральных типов, например `User['name' | 'age']`, тогда вернется union из типов этих полей, например `string | number`.
  - Т.о. получается что внутренняя конструкция `keyof typeof Direction` дала нам union из литеральных типов `'UP' | 'DOWN' | 'LEFT' | 'RIGHT'`, и когда этот union попал во внешнюю конструкцию, то она нам вернула типы соответствующих полей (тоже в виде union).
    - А поскольку мы применяли as const к объекту, то типами являются литеральные типы 'up', 'down', 'left', 'right', соответственно итоговый результат всей конструкции - это union `'up' | 'down' | 'left' | 'right'`
- Т.о. вся конструкция `typeof Direction[keyof typeof Direction]` это то же самое, что `'up' | 'down' | 'left' | 'right'`, плюс за счет объекта Direction у нас есть возможность не писать руками up, down и т.д., а пользоваться этим объектом как источником возможных значений.

P.S. В который раз я убеждаюсь, что понять это проще, чем нормально объяснить. Я клянусь, я не знаю как это можно коротко написать, чтобы было понятно. Чем подробнее пытаешься расписать, тем такое чувство что становится только хуже. Но сейчас вроде нормально получилось. Если не пожалеть 15 минут внимательно прочитать весь файл, то должно быть понятно. Кроме того, затрагиваются смежные темы, что тоже полезно.