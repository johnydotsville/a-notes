# Что такое индекс

Индекс - это специальная структура данных, которая предназначена для ускорения поиска в таблице. Что именно представляет собой индекс, где и как он хранит свои данные - это детали реализации конкретных СУБД, поэтому рассмотреть этот вопрос в отрыве от конкретной СУБД невозможно.

Концептуально, индекс можно представить как клон таблицы с урезанным количеством столбцов. По скольким столбцам проведено индексирование - столько столбцов и будет в индексе. Ускорение поиска происходит за счет того, что строки в индексе хранятся в отсортированном виде и поэтому можно применять двоичный поиск. Таким образом, хороший индекс помогает быстро отбросить как можно больше неподходящих записей с помощью бинарного поиска и минимизировать остаток, который надо просмотреть последовательно.

С каждой строкой индекса связана ссылка на строку реальной таблицы, так что как только поиск по индексу завершен, мы сразу получаем ссылку на полную строку данных.

Можно строить несколько индексов для одной таблицы для ускорения разных запросов. Какое поле \ набор полей выбрать для индекса - зависит от того, какие поля фигурируют чаще всего в запросах в предложениях where и order by. Для построения индексов существует несколько разных алгоритмов. Какие-то работают лучше для определенных типов полей. Например, для строковых и числовых полей хорошо подходит алгоритм B-tree (сбалансированное дерево).

Индекс наиболее эффективен, когда из таблицы выбирается небольшое число строк (относительно общего количества строк в таблице) и менее эффективен, если выбирается много. В последнем случае планировщик может посчитать последовательный перебор более эффективным, чем использование индекса.

# Недостатки индексов

* На обслуживание индексов СУБД тратит время, т.к. их надо периодически пересчитывать из-за добавления \ удаления записей в таблицы.
* Индексы тоже занимают определенный объем хранилища.

Тем не менее, польза от правильно составленных индексов перевешивает эти накладные расходы.

# Пример индекса

Например, есть таблица книг с полями "Автор", "Произведение" и "Год написания". Если на основе поля `Автор` мы создадим индекс, то в нем будет одно это поле, отсортированное по возрастанию. Значит, если в некотором запросе будет присутствовать поле Автор, СУБД сможет за счет индекса быстро отсекать (бинарным поиском) строки с "неправильными" авторами и быстрее выходить на нужное подмножество.

Причем здесь не важно, какие еще поля присутствуют в условии выборки. Сам факт того, что в условии есть поле Автор, уже хорошо ускорит поиск, при наличии индекса по Автору. Т.е. у нас будет хорошо работать не только запрос

```sql
select * from Books
where author = 'Толстой Лев Николаевич'
```

но и запрос по Автору + Году

```sql
select * from Books
where autor = 'Толстой Лев Николаевич' and year = 1856
```

При этом конечно в пределах полученного подмножества СУБД придется последовательно просмотреть все года и скорость поиска в этом подмножестве будет O(n). Т.е. все книги Толстого мы найдем быстро, а вот конкретную его книгу придется искать последовательным перебором.

СУБД обычно самостоятельно создают индекс на основе первичного ключа, т.к. такой индекс помогает поддерживать требование уникальности PK, потому что позволяет быстрее осуществить проверку уникальности ключа.

# Составной индекс

К индексу из предыдущего примера мы можем добавить еще одно поле - год, сделав индекс `Автор + Год` (порядок важен). Это называется **составной индекс**. И тогда записи у нас в индексе будут сортированы в первую очередь по Автору, а в пределах автора еще и по году. И тогда запрос `... where autor = 'Толстой Лев Николаевич' and year = 1856` будет работать еще быстрее, поскольку кроме лишних авторов СУБД сможет двоичным поиском быстрее отбросить и лишние года в пределах автора.

При этом важно понимать, что индекс Автор + Год хорошо ускоряет поиск именно по полю Автор или комбинации полей Автор + Год (или Год + Автор, это одно и то же), но совсем не ускоряет поиск по Году в отдельности. Все потому что первичная сортировка идет именно по автору, а значения в столбце Год, если смотреть на них в отрыве от автора, не отсортированы:

```
// Примерный вид индекса
Автор                     Год     Ссылка на запись таблицы
Гюго Виктор Мари          1882    ...
Толстой Лев Николаевич    1853    ...
Толстой Лев Николаевич    1856    ...
Толстой Лев Николаевич    1903    ...
Толстой Лев Николаевич    1910    ...
Чехов Антон Павлович      1878    ...
Чехов Антон Павлович      1884    ...    
```

Так что порядок включения полей в индекс имеет критичное значение.

# Селективность

Селективность - это показатель, который позволяет понять, какие поля лучше всего подходят для индекса. У какого поля выше селективность, то подходит лучше. Высчитывается так:

````
(количество уникальных значений \ общее количество записей) * 100
````

Например, поле Пол имеет 2 уникальных значения (М и Ж), на 100_000 записей селективность составит (2 \ 100_000) * 100% = 0.002%. А поле Автор имеет очевидно больше уникальных значений, пусть например 1000, его селективность (1_000 \ 100_000) * 100% = 1% Стало быть поле Автор куда более эффективно для использования в индексе.

В индекс включаются поля, которые наиболее часто фигурируют в запросах в предложениях where и order by, а при выборе последовательности полей в индексе можно ориентироваться на селективность (это я правда уже сам такой вывод сделал, а не прочитал где-то, так что инфа не 100%).

# Планировщик

Решение о том, использовать для выполнения запроса индекс или не использовать, принимает планировщик. Один и тот же запрос, но с разными условиями, например

```
select * from bookings where pid = 1
select * from bookings where pid = 2
```

в первом случае может выполниться с использованием индекса, а второй - без. Это не значит, что планировщик ошибся, просто он сделал вывод, что в каком-то случае прямой перебор будет эффективнее, чем использование индекса. Нужно учитывать это, чтобы не задаваться вопросом "почему индекс не работает".