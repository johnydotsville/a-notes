СУБД могут по-разному организовать хранение данных. Несколько примеров обзорно перечислены ниже.

# Куча

Это способ хранения, когда все данные складываются в никак не упорядоченную структуру. Индекса как такового нет. Добавление происходит быстро, потому что данные всегда вставляются в конец этой структуры. Однако все остальные операции происходят медленно, потому что каждый раз требуется просматривать всю кучу целиком, чтобы найти нужные данные.

# Кластеризованный индекс

Это способ хранения, когда все данные организуются в сбалансированное дерево (B-tree). Поиск в такой структуре работает быстро, а другие операции медленнее, потому что они могут потребовать перестраивание структуры.

Важная особенность КИ в том, что данные хранятся непосредственно в узлах индекса. Это может ускорять получение данных, т.к. они хранятся "рядом" с индексом и в случае использования hdd, харду не надо сильно крутиться куда-то, чтобы достать эти данные. Но в то же время в случае изменения значения ключа придется перемещать не только индексированные поля, но и все остальные. А это очевидно медленее. TODO: зачем что-то перемещать? Разве не достаточно просто переставить указатели?

Кластеризованный индекс может быть только один как раз по причине того, что сами данные хранятся непосредственно в индексе. Т.е. по сути, концептуально, КИ можно воспринимать как таблицу данных, отсортированных по каким-то полям.

# Некластеризованный индекс

Это способ хранения, когда в индексе непосредственно хранятся только данные из индексных полей. Основная масса данных хранится в куче, а в индексе на них есть ссылки. Поэтому НКИ может быть сколько угодно.

У НКИ такие же достоинства и недостатки как у КИ, за исключением того, что раз данные хранятся отдельно от индекса, hdd возможно придется покрутиться чуть сильнее. Зато в случае изменения значения ключа придется перемещать не все данные, а только те, что в индексных полях.

# Покрывающий индекс

Это подвид некластеризованного индекса. ПИ характеризуется тем, что в индексе хранятся также и все данные, необходимые для выполнения запроса. Но это не все данные, как в случае с КИ, а только какая-то часть. Например, есть таблица `Сотрудник(id, имя, адрес, телефон, еще с десяток полей)`. Пусть часто используется запрос `select имя, телефон from Сотрудник`. Покрывающий индекс для такого запроса включал бы в себя два поля: имя и телефон. В таком случае данных из индекса хватило бы, чтобы ответить на такой запрос без необходимости тянуть телефон из кучи.