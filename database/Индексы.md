# Основы индексов

Индексы - это специальные структуры данных, которые ускоряют поиск в таблице. Ускорение происходит за счет того, что, во-первых, строк в индексе меньше, чем в таблице (за счет отсутствия дубликатов, ибо в индекс входит мало полей), и, во-вторых, эти строки хранятся в отсортированном виде. Что именно представляет собой индекс, где и как он хранит свои данные - это детали реализации индексов в конкретных СУБД, поэтому рассмотреть этот вопрос в отрыве от конкретной СУБД невозможно.

Пусть у нас таблица книг с автором, произведением и годом написания. Если мы включим в индекс поле Автор, значит у нас будет набор из одного поля (Автор), отсортированный по возрастанию. Значит, если в некотором запросе будет присутствовать поле Автор, СУБД сможет за счет индекса быстро отсекать (бинарным поиском) строки с "неправильными" авторами и быстрее выходить на нужное подмножество.

Причем здесь, насколько я теперь понимаю (но это пока не точно), становится не важно, какие еще поля присутствуют в условии выборки. Сам факт того, что в условии есть поле Автор, уже хорошо ускорит поиск, при наличии индекса по Автору. Т.е. у нас будет хорошо работать не только запрос

```sql
select * from Books
where author = 'Толстой Лев Николаевич'
```

но и вот такой поиск по Автору + Году

```sql
select * from Books
where autor = 'Толстой Лев Николаевич' and year = 1856
```

При этом конечно в пределах конкретного автора СУБД придется последовательно просмотреть все года и скорость поиска в этом подмножестве будет O(n).

Но мы можем добавить в индекс еще одно поле - год, сделав индекс Автор + Год (порядок важен). Это называется **составной индекс**. И тогда записи у нас в индексе будут сортированы в первую очередь по Автору, а в пределах автора еще и по году. И тогда запрос `... where autor = 'Толстой Лев Николаевич' and year = 1856` будет работать еще быстрее, поскольку кроме лишних авторов СУБД сможет двоичным поиском быстрее отбросить и лишние года в пределах автора.

При этом очень важно понимать, что индекс Автор + Год хорошо ускоряет поиск именно по полю Автор или комбинации полей Автор + Год (или Год + Автор, это одно и то же), но совсем не ускоряет по году в отдельности. Все потому что первичная сортировка идет именно по автору:

```
// Примерный вид индекса
Автор                     Год
Гюго Виктор Мари          1882    ...
Толстой Лев Николаевич    1853    ...
Толстой Лев Николаевич    1856    ...
Толстой Лев Николаевич    1903    (ссылки на записи, где Автор = 'Толстой Лев Николаевич' и Год = 1856)
Толстой Лев Николаевич    1910    ...
Чехов Антон Павлович      1878    ...
Чехов Антон Павлович      1884    ...    
```

А год в отрыве от автора, как видно, представляет собой хаос, который необходимо просматривать последовательно. Так что порядок включения полей в индекс имеет критичное значение.

**Селективность** позволяет понять, какие поля лучше всего подходят для индекса. У какого поля выше селективность, то подходит лучше. Высчитывается как `(количество уникальных значений \ общее количество записей) * 100`. Например, поле Пол имеет 2 уникальных значения (М и Ж), на 100_000 записей селективность составит (2 \ 100_000) * 100% = 0.002%. А поле Автор имеет очевидно больше уникальных значений, пусть например 1000, его селективность (1_000 \ 100_000) * 100% = 1% Стало быть Автор куда более эффективен для использования в индексе.

Таким образом, индекс надо строить так, чтобы отбросить как можно больше неподходящих записей с помощью бинарного поиска и минимизировать остаток, который надо просмотреть последовательно. В индекс включаются поля, которые наиболее часто фигурируют в запросах, а при выборе последовательности полей в индексе можно ориентироваться на селективность (это я правда уже сам такой вывод сделал, а не прочитал где-то, так что инфа не 100%).

# Кластерные индексы



# Вопросы

- [ ] Помогают ли индексы, когда дело касается выборки не из одной таблицы, а с использованием соединения нескольких таблиц?