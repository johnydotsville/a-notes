# Проблемы параллельных транзакций

Проблемы академические, они не привязаны к конкретной СУБД и просто рассматривают все возможные ситуации, которые могли бы возникнуть.

## Потерянное обновление (Lost update)

> Две параллельные транзакции выполняют update одной и той же строки и в результат попадает значение последней закоммитившейся транзакции, а значение первой перезаписывается (теряется).

Например:

| Транзакция Т1                           | Транзакция Т2                       |
| --------------------------------------- | ----------------------------------- |
| `begin`                                 |                                     |
| `update emp set sal=sal+500 where id=5` | `begin`                             |
|                                         | `update emp set sal=sal+300`        |
| `commit`                                |                                     |
| :x: lost                                | `commit` :heavy_check_mark: applied |

Допустим, изначально зарплата сотрудника была 2000. Первая транзакция начала изменение 2000+500 и до того как успела закоммититься, вторая транзакция начала изменение 2000+300. Если СУБД такие ситуации не обнаруживает и заставляет вторую транзакцию подождать, то результат будет не 2800, а 2300.

## Грязное чтение (Dirty reads)

> Транзакция видит изменения, которые другая транзакция сделала, но еще не закоммитила.

Под "изменениями" понимается insert, delete или update строк. При грязном чтении проблема возникает, когда транзакция, изменившая строки,  впоследствии делает откат, а не коммит. В этом случае получается, что все транзакции, которые эти "грязные" изменения прочитали и сделали на их основе какие-то предположения, оказались обманутыми. Например:

| Транзакция Т1                           | Транзакция Т2                              |
| --------------------------------------- | ------------------------------------------ |
| `begin`                                 |                                            |
|                                         | `begin`                                    |
|                                         | `update emp set children = 2 where id = 5` |
| `select children from emp where id = 5` |                                            |
|                                         | `rollback`                                 |
| `if (children > 2) set bonus *= 1.4`    |                                            |
| `commit`                                |                                            |

Транзакция 2 ошибочно изменяет у сотрудника с идентификатором 5 количество детей с, например, трех до двух. Транзакция 1 считывает это "грязное" количество (2) для расчета бонуса к зарплате. После этого чтения Т2 откатывается и количество снова становится прежним, однако Т1 это уже не волнует, она производит расчеты, используя грязное значение.

Аналогичные проблемы могут возникнуть не только когда Т2 изменяет имеющиеся строки, но и добавляет новые или удаляет существующие, а потом откатывается. Если Т1 будет использовать грязные данные, ее расчеты никогда не будут точными. Однако производительность грязного чтения максимальная, поэтому если какие-то сценарии предполагают приблизительные расчеты или такие "обманы" не критичны, то грязное чтение может ускорить вычисления.

## Неповторяющееся чтение (Non-repeatable read)

> В транзакции при повторном чтении одной и той же строки, значения полей в ней отличаются.

Такая проблема возникает, когда другая транзакция между этими чтениями успевает внести изменения в строку и закоммититься.

В неповторяющемся чтении упор делается именно на то, что *одна и та же* строка (или несколько строк), если ее прочитать несколько раз в рамках одной транзакции, выглядит по-разному. Например:

| Транзакция Т1                                                | Транзакция Т2                                    |
| ------------------------------------------------------------ | ------------------------------------------------ |
| `begin`                                                      |                                                  |
| `select name from emp where id = 5; -- Напр, Tom Sawyer`     |                                                  |
|                                                              | `begin`                                          |
|                                                              | `update emp set name = 'Huck Finn' where id = 5` |
|                                                              | `commit`                                         |
| `select name from emp where id = 5; -- А теперь уже Huck Finn` |                                                  |
| `commit`                                                     |                                                  |

В этом примере идентичный запрос на выборку в рамках одной транзакции вернул ту же самую строку, но имя в ней уже стало другое по сравнению с первым запросом.

## Чтение фантомов (Phantom read)

> Одна и та же операция чтения, выполненная несколько раз в пределах транзакции, каждый раз возвращает разное количество строк (больше или меньше), чем в предыдущий.

Проблема возникает, когда другая транзакция между этими чтениями вставила \ удалила строки и закоммитилась.

В чтении фантомов упор делается именно на то, что строк становится *больше или меньше*. Например:

| Транзакция Т1                                                | Транзакция Т2                                               |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| `begin`                                                      |                                                             |
| `select name from emp where sal > 1000; -- Пусть таких двое` |                                                             |
|                                                              | `begin`                                                     |
|                                                              | `insert into emp (id, name, sal) values (4, 'Polly', 5000)` |
|                                                              | `commit`                                                    |
| `select name from emp where sal > 1000; -- А теперь уже трое` |                                                             |
| `commit`                                                     |                                                             |

# Уровни изоляции транзакций

Эти уровни изоляции академические, они не привязаны к конкретной СУБД. Реальные СУБД могут обеспечивать не все эти уровни, реализовывать их по-своему и добавлять другие уровни.

Академически, уровни должны решать проблемы таким образом:

|                 | Грязное чтение     | Неповторяющееся чтение | Чтение фантомов    |
| --------------- | ------------------ | ---------------------- | ------------------ |
| Read uncommited | :x:                | :x:                    | :x:                |
| Read committed  | :heavy_check_mark: | :x:                    | :x:                |
| Repeatable read | :heavy_check_mark: | :heavy_check_mark:     | :x:                |
| Serializable    | :heavy_check_mark: | :heavy_check_mark:     | :heavy_check_mark: |

Практически, нужно понимать проблемы, а про уровни изоляции и как они решают эти проблемы - читать в документации к конкретной СУБД.