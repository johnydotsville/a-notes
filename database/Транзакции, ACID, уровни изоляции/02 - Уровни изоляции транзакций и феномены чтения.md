# Проблемы параллельных транзакций

Проблемы академические, они не привязаны к конкретной СУБД и просто рассматривают все возможные ситуации, которые могли бы возникнуть.

## Потерянное обновление (Lost update)

> Две параллельные транзакции выполняют update одной и той же строки и в результат попадает значение последней закоммитившейся транзакции, а значение первой перезаписывается (теряется).

Например:

| Транзакция Т1                           | Транзакция Т2                       |
| --------------------------------------- | ----------------------------------- |
| `begin`                                 |                                     |
| `update emp set sal=sal+500 where id=5` | `begin`                             |
|                                         | `update emp set sal=sal+300`        |
| `commit`                                |                                     |
| :x: lost                                | `commit` :heavy_check_mark: applied |

Допустим, изначально зарплата сотрудника была 2000. Первая транзакция начала изменение 2000+500 и до того как успела закоммититься, вторая транзакция начала изменение 2000+300. Если СУБД такие ситуации не обнаруживает и заставляет вторую транзакцию подождать, то результат будет не 2800, а 2300.

## Грязное чтение (Dirty reads)

> Транзакция видит изменения, которые другая транзакция сделала, но еще не закоммитила.

Под "изменениями" понимается insert, delete или update строк. При грязном чтении проблема возникает, когда транзакция, изменившая строки,  впоследствии делает откат, а не коммит. В этом случае получается, что все транзакции, которые эти "грязные" изменения прочитали и сделали на их основе какие-то предположения, оказались обманутыми. Например:

| Транзакция Т1                           | Транзакция Т2                              |
| --------------------------------------- | ------------------------------------------ |
| `begin`                                 |                                            |
|                                         | `begin`                                    |
|                                         | `update emp set children = 2 where id = 5` |
| `select children from emp where id = 5` |                                            |
|                                         | `rollback`                                 |
| `if (children > 2) set bonus *= 1.4`    |                                            |
| `commit`                                |                                            |

Транзакция 2 ошибочно изменяет у сотрудника с идентификатором 5 количество детей с, например, трех до двух. Транзакция 1 считывает это "грязное" количество (2) для расчета бонуса к зарплате. После этого чтения Т2 откатывается и количество снова становится прежним, однако Т1 это уже не волнует, она производит расчеты, используя грязное значение.

Аналогичные проблемы могут возникнуть не только когда Т2 изменяет имеющиеся строки, но и добавляет новые или удаляет существующие, а потом откатывается. Если Т1 будет использовать грязные данные, ее расчеты никогда не будут точными. Однако производительность грязного чтения максимальная, поэтому если какие-то сценарии предполагают приблизительные расчеты или такие "обманы" не критичны, то грязное чтение может ускорить вычисления.

## Неповторяющееся чтение (Non-repeatable read)

> В транзакции при повторном чтении одной и той же строки, значения полей в ней отличаются.

Такая проблема возникает, когда другая транзакция между этими чтениями успевает внести изменения в строку и закоммититься.

В неповторяющемся чтении упор делается именно на то, что *одна и та же* строка (или несколько строк), если ее прочитать несколько раз в рамках одной транзакции, выглядит по-разному. Например:

| Транзакция Т1                                                | Транзакция Т2                                    |
| ------------------------------------------------------------ | ------------------------------------------------ |
| `begin`                                                      |                                                  |
| `select name from emp where id = 5; -- Напр, Tom Sawyer`     |                                                  |
|                                                              | `begin`                                          |
|                                                              | `update emp set name = 'Huck Finn' where id = 5` |
|                                                              | `commit`                                         |
| `select name from emp where id = 5; -- А теперь уже Huck Finn` |                                                  |
| `commit`                                                     |                                                  |

В этом примере идентичный запрос на выборку в рамках одной транзакции вернул ту же самую строку, но имя в ней уже стало другое по сравнению с первым запросом.

## Чтение фантомов (Phantom read)

> Один и тот же select, выполненный несколько раз в пределах транзакции, каждый раз возвращает разное количество строк (больше или меньше), чем в предыдущий.

Проблема возникает, когда другая транзакция между этими чтениями вставила \ удалила строки и закоммитилась.

В чтении фантомов упор делается именно на то, что строк становится *больше или меньше*. Например:

| Транзакция Т1                                                | Транзакция Т2                                               |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| `begin`                                                      |                                                             |
| `select name from emp where sal > 1000; -- Пусть таких двое` |                                                             |
|                                                              | `begin`                                                     |
|                                                              | `insert into emp (id, name, sal) values (4, 'Polly', 5000)` |
|                                                              | `commit`                                                    |
| `select name from emp where sal > 1000; -- А теперь уже трое` |                                                             |
| `commit`                                                     |                                                             |

## Аномалия сериализации

> Аномалия сериализации - это когда при перемешивании команд из нескольких параллельных транзакций результат получается не такой, как если бы транзакции выполнялись последовательно.

Требование I из ACID говорит нам о том, что суммарный эффект нескольких параллельных транзакций должен быть такой же, как если бы эти транзакции выполнялись последовательно. Однако если действительно выполнять транзакции последовательно, то это будет очень медленно. Поэтому задача СУБД - перемешать команды из параллельных транзакций так, чтобы все в целом работало быстрее, но сделать это аккуратно, чтобы суммарный эффект получился как при последовательном выполнении. При этом порядок транзакций в этом гипотетическом "последовательном" выполнении не важен.

Например, есть число 10. Первая транзакция прибавляет 20, а вторая делит на 2. Следовательно, у нас может быть два сценария: сначала Т1, потом Т2, результат `(10 + 20) / 2 = 15`. Или сначала Т2, потом Т1, результат `(10 / 2) + 20 = 25`. Третьего не дано. СУБД устроит любой из этих двух результатов.

Теперь представим, что в Т1 и Т2 гораздо больше команд. СУБД их перемешала, выполнила и в результате получилось 50, что очевидно не 15 и не 25. Это и будет аномалией сериализации - перемешивание команд привело к какому-то третьему результату, в то время как последовательное выполнение могло дать только два результата.

# Уровни изоляции транзакций

Эти уровни изоляции академические, они не привязаны к конкретной СУБД. Реальные СУБД могут обеспечивать не все эти уровни, реализовывать их по-своему и добавлять другие уровни.

Академически, уровни должны решать проблемы таким образом (:heavy_check_mark: означает, что проблема решается, :x: что проблема присутствует​):

|                 | Потерянное обновление | Грязное чтение     | Неповторяющееся чтение | Чтение фантомов    | Аномалия сериализации |
| --------------- | --------------------- | ------------------ | ---------------------- | ------------------ | --------------------- |
| Read uncommited | :heavy_check_mark:    | :x:                | :x:                    | :x:                | :x:                   |
| Read committed  | :heavy_check_mark:    | :heavy_check_mark: | :x:                    | :x:                | :x:                   |
| Repeatable read | :heavy_check_mark:    | :heavy_check_mark: | :heavy_check_mark:     | :x:                | :x:                   |
| Serializable    | :heavy_check_mark:    | :heavy_check_mark: | :heavy_check_mark:     | :heavy_check_mark: | :heavy_check_mark:    |

Практически, нужно понимать проблемы, а про уровни изоляции и как они решают эти проблемы - читать в документации к конкретной СУБД.

# Уровни изоляции в конкретных СУБД

## PostgreSQL

"До первой команды" и аналогичные формулировки имеют ввиду команды по манипуляции с данными (выборка, модификация). Остальные команды, не работающие с данными (например, настройки транзакции), не считаются.

### Read uncommited

Фактически не существует. Можно использовать, но ведет он себя точно так же как Read commited.

### Read committed

| Потерянное обновление | Грязное чтение     | Неповторяющееся чтение | Чтение фантомов | Аномалия сериализации |
| --------------------- | ------------------ | ---------------------- | --------------- | --------------------- |
| :heavy_check_mark:    | :heavy_check_mark: | :x:                    | :x:             | :x:                   |

Характеристики:

* Транзакция видит только те данные, которые были закоммичены до первой ее команды (выборка, модификация - не важно). Любые модификации в другой транзакции, которые *не закоммичены*, текущая транзакция не увидит.

Более детально:

* Измененные данные - не видит никакие изменения, внесенные в любые данные другой транзакцией.
* Удаленные данные - продолжает видеть данные, которые были удалены в другой транзакции.
* Добавленные данные - не видит добавленные в другой транзакции данные.

Стоит еще раз подчеркнуть, что все это относится только к незакоммиченным данным. Если другая транзакция сделает коммит, то текущая все эти изменения увидит.

### Repeatable read

| Потерянное обновление | Грязное чтение     | Неповторяющееся чтение | Чтение фантомов    | Аномалия сериализации |
| --------------------- | ------------------ | ---------------------- | ------------------ | --------------------- |
| :heavy_check_mark:    | :heavy_check_mark: | :heavy_check_mark:     | :heavy_check_mark: | :x:                   |

Характеристики:

* Транзакция видит только те данные, которые были закоммичены до первой ее команды и работает с ними в этом виде до своего завершения.
* Транзакция блокирует данные, которые затронула первая ее команда (любая, хоть на выборку, хоть на модификацию). Поэтому другим транзакциям при желании модифицировать заблокированные данные придется подождать ее окончания.

Более детально:

* Изменение:
  * Если RR-транзакция Т1 заблокировала какие-то данные, то Т2 не сможет их изменять \ удалять.
  * Т2 может делать что хочет с данными, которые Т1 не заблокировала. Однако Т1 все равно будет до своего окончания видеть эти данные в их исходном виде.
* Добавление данных:
  * Если Т2 добавит новые данные, то Т1 их не увидит.
* Удаление данных:
  * Если Т2 удалит данные, которые не заблокировала Т1, то Т1 продолжит видеть удаленные данные до своего завершения.

### Serializable

| Потерянное обновление | Грязное чтение     | Неповторяющееся чтение | Чтение фантомов    | Аномалия сериализации |
| --------------------- | ------------------ | ---------------------- | ------------------ | --------------------- |
| :heavy_check_mark:    | :heavy_check_mark: | :heavy_check_mark:     | :heavy_check_mark: | :heavy_check_mark:    |

То же самое что Repeatable read, плюс при коммитах происходит проверка на наличие аномалий сериализации и если она есть, то коммитится только одна транзакция, а остальные откатываются.