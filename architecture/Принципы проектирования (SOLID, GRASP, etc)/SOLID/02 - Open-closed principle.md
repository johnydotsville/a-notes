# Предисловие

Изначально принцип OCP (Open-Closed principle) сформулировал Бертран Мейер в своей книге 1988 года "Object-Oriented Software Construction" ("Объектно-ориентированное конструирование программных систем"). Его можно найти в книге (2-е издание) в части B, глава 3: Modularity, параграф 3.3 Five principles, подраздел "The Open-Closed principle", стр 57.

Кроме того, принцип упоминается в статьях и книге Роберта Мартина "Clean architecture" ("Чистая архитектура").

# Бертран Мейер

## Формулировка

Формулировка Бертрана Мейера:

> Modules should be both open and closed.

> Модули должны одновременно быть и открыты, и закрыты.

Оригинальные пояснения к терминам открытости и закрытости:

* Открытость

  > Module is said to be open if it is still available for extension. For example, it should be possible to expand its set of operations or add fields to its data structures.

  > Модуль считается открытым, если есть возможность его *расширения*. Например, есть возможность добавить в набор его операций новые операции, или добавить поля в его структуры данных.

  Хочется обратить внимание на слово *расширение* именно в значении *обогащения* модуля *новыми* операциями, а не просто изменения логики работы уже имеющихся операций. Статьи, попросту сводящие принцип к полиморфизму, как раз грешат тем, что упускают этот момент.

* Закрытость

  > A module is said to be closed if it is available for use by other modules. This assumes that the module has been given a well-defined, stable description. At the implementation level, closure for a module also implies that you may compile it, perhaps store it in a library, and make it available for others (its clients) to use.

  > Вольный перевод: модуль считается закрытым, если им уже спокойно могут пользоваться другие модули. "Спокойно пользоваться" подразумевает, что модуль имеет хорошо определенный, стабильный интерфейс. Закрытый модуль можно компилировать, хранить в библиотеке и раздавать всем нуждающимся.


Одним словом, закрытость подразумевает завершенность, факт того, что модулем уже можно полноценно пользоваться и не бояться, что его вдруг изменят и у клиента модуля все сломается. Под клиентами модуля здесь и далее подразумевается код, котороый пользуется этим модулем, а не люди. А открытость подразумевает, что модуль можно править и не бояться, что эти правки сломают клиентов.

Т-о формулировка "модуль должен быть одновременно и открытым, и закрытым" поднимает вопрос "Как *расширять* функциональность модуля так, чтобы не сломать уже написанный код?".

## Применение

Необходимость для модулей быть одновременно открытыми и закрытыми продиктована двумя вещами:

* С течением времени для ПО характерно появление изменений, потому что заранее предусмотреть все операции, все структуры данных, которые могут понадобиться в будущем, практически невозможно. Поэтому модули должны быть открыты и разработчики должны иметь возможность вносить изменения в них, чтобы они отвечали актуальным требованиям.
* В то же время, распределенная разработка многомодульного ПО невозможна или крайне затруднительна, если модули не закрыты, потому что из-за зависимости модулей друг от друга, разработчики модуля *А* были бы вынуждены ждать, пока нужный им модуль *В* окончательно доработают. Иначе внесенные в *В* изменения могут быть настолько существенными, что вызовут целый каскад изменений в модуле *А*, а они, в свою очередь, могут повлечь такие же масштабные изменения в каком-нибудь модуле *С* и т.д. Доработка же до "финальной" версии, если соблюдать требование открытости, в принципе невозможна.

Без объектно-ориентированного подхода (ООП) существует всего два решения этой проблемы, и оба недостаточно хороши:

* Все-таки внести в исходный модуль нужные изменения. Последствия, как указывалось выше, могут быть печальными - необходимость внесения изменений во множество других модулей, некоторые их которых, возможно, никто не трогал годами. Еще хуже, если внесенные изменения технически не сломают другие модули, но сломают их логически, т-е старые модули будут работать, но выдавать некорректные результаты из-за того, что новые требования, ради которых вносились изменения, конфликтуют со старыми.
* Создать копию исходного модуля, внести в него изменения и отдать новым клиентам. Плюс в том, что не приходится трогать уже работающий код. Недостаток в том, что при большом потоке запросов на изменения, количество таких копий одного модуля может сильно вырасти, будет много дублирующегося кода.

ООП позволяет адаптировать второй подход и сделать его вполне приемлемым. Используя наследование, мы, по сути, получаем ту же копию исходного объекта, но без физического дублирования кода. Те операции, которые нам подходят, оставляем как есть; операции, требующие изменений в связи с требованием новых клиентов, мы переопределяем; отсутствующую функциональность - дописываем.

## Некоторые уточнения

Иногда можно встретить такой вопрос:

* А как исправлять ошибки в уже работающих модулях, если их нельзя изменять?

Вот что на этот счет говорит Бертран Мейер:

> Neither the Open-Closed principle nor redefinition in inheritance is a way to address design flaws, let alone bugs. If there is something wrong with a module, you should fix it - not leave the original as it is and try to correct the problem in a derived module. (The only potential exception to this rule is the case of flawed software
> which you are not at liberty to modify.) The Open-Closed principle and associated techniques are intended for the adaptation of healthy modules: modules that, although they may not suffice for some new uses, meet their own well-defined requirements, to the satisfaction of their own clients.

> Вольный перевод: принцип открытости-закрытости и наследование не являются средством исправления плохой архитектуры или ошибок. Если в модуле есть ошибка - вы должны поправить ее именно в нем, а не создавать новый правильный. Единственное исключение - если у вас нет возможности \ права изменять код с ошибкой.
>
> Принцип открытости-закрытости и связанные техники направлены на адаптацию *исправных* модулей, которые корректно выполняют свою задачу, но просто не подходят некоторым новым клиентам.

Т-е не нужно возводить принцип в абсолют - если у вас есть возможность редактировать готовый модуль и вы уверены, что это не приведет к каскаду сопутствующих изменений или ошибкам (или вы сможете поправить и их тоже), то можете редактировать.

# Роберт Мартин

## Формулировка

Формулировка из книги "Чистая архитектура" Роберта Мартина:

> The Open-Closed Principle (OCP) was coined in 1988 by Bertrand Meyer.1 It says:
>
> > A software artifact should be open for extension but closed for modification.
>
> In other words, the behavior of a software artifact ought to be extendible, without having to modify that artifact.

Однако Мейер так не говорил. В своем [блоге](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html) Роберт Мартин пользуется оригинальными формулировками Мейера. Также у Мартина есть другая, более интересная [статья](https://web.archive.org/web/20060822033314/http://www.objectmentor.com/resources/articles/ocp.pdf), переведенная на [хабре](https://habr.com/ru/companies/tinkoff/articles/472186/).

По Мартину, модули, отвечающие принципу открытости-закрытости, имеют два главных признака:

* Открыты для расширения.

  > They are “Open For Extension”. This means that the behavior of the module can be extended. That we can make the module behave in new and different ways as the requirements of the application change, or to meet the needs of new applications.

  > Это означает, что поведение модуля может быть расширено. То есть мы можем добавить модулю новое поведение в соответствии с изменившимися требованиями к приложению или для удовлетворения нужд новых приложений.

* Закрыты для изменений. 

  > They are “Closed for Modification”. The source code of such a module is inviolate. No one is allowed to make source code changes to it.

  > Исходный код такого модуля неприкасаем. Никто не вправе вносить в него изменения.

Формулировка Мартина "A software artifact should be open for extension but closed for modification" содержит в себе намек на то, что значит открытый-закрытый.

Однако формулировка закрытости выражена слишком категорично и плюс такое чувство, что в определение принципа внедрен совет технической реализации - не изменяйте код и все. При этом нет пояснений, что, например, для исправления ошибок модуль изменять не только можно, но и нужно (если у вас есть к нему доступ) и это не является нарушением принципа. У Мейера в самой концепции закрытости нет ни слова о том, что модуль нельзя изменять. У него неизменяемость идет как один из вариантов реализации принципа и показаны исключения, при которых изменения допустимы.

Открытость у Мартина, что в блоге, что в книге, сведена к обычному полиморфизму: просто говорится о том, что надо использовать интерфейсы в местах, где возможны изменения, и подставлять разные реализации для изменения поведения.

Но подмена реализаций не является подлиным *расширением* функциональности, потому что мы по сути делаем то же самое, просто другим способом. На примере калькулятора: мы можем выделить абстракцию для выполняемой операции и реализовать сложение, вычитание, умножение, деление, возведение в степень, извлечения корня и прочее в виде отдельных компонентов. С виду это дает программе "расширяемость", но по сути мы делаем одно и то же - манипулируем числами, просто по-разному. Подлинной возможности расширить функциональность, например, сохранить историю вычислений, эта абстракция нам не даст.

Поэтому, если у существующих клиентов вдруг появляется необходимость хранить историю вычислений, то нам, скорее всего, придется менять и код самого модуля калькулятора, и код его клиентов. По Мейеру это не является нарушением ОСР. Однако у Мартина этот интересный вопрос о том, что делать, если вдруг требуется изменить сам интерфейс, аккуратно обходится стороной.

## Полная закрытость невозможна

Мартин высказывает мысль, что "ни одна программа не может быть закрыта на 100%". По его мнению, решение проблемы расширения без изменения кода кроется в абстракциях. Но расширение функциональности и подмена реализации - не одно и то же. Полиморфизм лишь позволяет в конкретных местах защититься от изменений, которые удалось предвидеть заранее, но он не позволяет вводить принципиально новую функциональность, а только по-разному выполнить концептуально одно и то же действие.

Чем опытнее проектировщик программы, чем больше у него знаний и опыта в предметной области, тем больше таких "изменчивых" мест он может предвидеть и закрыть абстракциями. Через ввод абстракции и подмену реализации мы можем обезопасить ("закрыть") модуль от какого-то *конкретного* изменения.  Но защититься от всех потенциальных изменений обычно все-таки невозможно, можно только приблизиться к этому.

# Резюме

Формулировки открытого и закрытого модуля обозначают проблему, выводят наружу противоречие, но сам принцип лежит позади этих формулировок и выливается в несколько практических советов. Соединив мысли Мейера и Мартина, для себя я увидел эти советы такими такими:

Основной, который и можно рассматривать как суть ОСР:

> Введенный в эксплуатацию готовый модуль \ класс, который отлажен и не содержит логических ошибок, не следует изменять, дабы избежать возможных каскадных изменений в его клиентах и появления в них скрытых ошибок.

Несколько дополнительных:

* Не вторгайтесь в модуль ради изменения логики его работы, *если она правильная* и корректно реализует требования уже существующих клиентов модуля. Если появляются новые клиенты с отличающимися требованиями, предоставьте им *новую* реализацию модуля. Как вы это сделаете технически - на основе существующей реализации, используя, например, наследование, или как-то иначе - зависит от вас.

  В случае изменения логики исходного модуля в угоду требований новых клиентов вы рискуете получить скрытые ошибки в уже существующих клиентах, если их требования конфликтуют с новыми. Технически все может работать, но результат для кого-то окажется неправильный.

* Если в модуле есть логическая ошибка, то исправляйте ее прямо в этом модуле (если у вас есть такая возможность). Создание наследника с целью исправить ошибки допустимо в случае, если править исходный модуль по каким-то причинам невозможно.

* Расширение функциональности и подмена реализации - не одно и то же. В случае, когда существующим клиентам модуля требуется принципиально новая функциональность, придется изменять и код модуля, и код клиентов. Это не является нарушением ОСР.

* Если для подмены реализации вам приходится не только написать новую реализацию, но и изменить какой-то код, чтобы она полноценно заработала, то вы делаете что-то не так. Пример:

  ```csharp
  // При вводе новой реализации IAsset приходится что-то где-то дописывать,
  // чтобы полноценно встроить ее в работу
  public void method(IAsset asset) {
      if (asset is A) {
          ...
      }
      if (asset is B) {
          ...
      }
  }
  ```

  ```csharp
  // При вводе новой реализации IAsset все работает без дополнительных усилий
  public void method(IAsset asset) {
      asset.doSome();
  }
  ```