# Предисловие

Потомки могут добавлять родителям новые методы, а могут переопределять существующие. В результате такого переопределения и использования потомков вместо родителей в клиенте могут появиться скрытые логические ошибки. Чтобы они не появлялись, нужно придерживаться нескольких правил, выраженных в принципе подстановки. Правила касаются только переопределенных методов.

# Формулировка

Формулировка из книги "Program development in Java. Abstraction, Specification, and Object-Oriented Design" (2001), авторы - Barbara Liskov и John Guttag, раздел 7 "Type hierarchy":

> Subtype objects can be substituted for supertype objects without affecting the behavior of the using code.

Для себя я бы сформулировал LSP следующим образом:

> Писать потомков надо так, чтобы их использование вместо родителей не порождало логических ошибок.

Сделать это можно, если соблюдать несколько условий:

* Предусловия в методе потомка могут быть ослаблены, но не могут быть усилены.
* Постусловия в методе потомка не могут быть ослаблены, но могут быть усилены.
* Инварианты родителя должны быть соблюдены и в потомке.
* Метод потомка не может выбрасывать более общие исключения, чем метод родителя.

Осталось только разобраться, что такое пред-, постусловия и инварианты.

# Терминология

Понять эти термины проще на примере.

## Пример

Пусть у нас есть тип `Box` и его потомок `SortedBox`. Это, соответственно, некий контейнер для данных и его версия, в которой данные хранятся в отсортированном виде. Пусть у него есть два метода - `insert` и `all`, первый добавляет один элемент в контейнер, а второй - возвращает все элементы. При этом не важно, что именно это за элементы и в каком виде они возвращаются, пусть это будут какие-то надуманные операции.

## Предусловия

Предусловия - это требования, которые должен соблюсти клиент, чтобы метод отработал.

Например у метода Box.insert могут быть такие требования (предусловия):

```java
class Box {
    // Предусловия:
    //   * Data не может быть null
    //   * Data не может быть отрицательным числом
    public int insert(Data item)
```

Если мы хотим переопределить метод в потомке SortedBox.insert, то должны сделать это так, чтобы новый код не вызвал логических ошибок у клиентов, которые пользуются родительским методом Box.insert.

Усилить предусловие - это значит добавить в метод потомка какое-то новое ограничение, из-за которого он может не выполниться. Ослабить предусловие - это по сути значит отказаться от какого-то ограничения, убрать его. Например, если мы изменим требования для SortedBox.insert вот так:

```java
class SortedBox {
    // Предусловия:
    //   x Первое предусловие, про null, уберем ("ослабим")
    //   v Второе, про отрицательное число, оставим как есть
    //   + Data не может быть нулём - добавим новое, которого не было у родителя ("усилим")
    public int insert(Data item)
```

То это считается *усилением* предусловия, потому что сужает набор ситуаций, при которых клиент сможет воспользоваться классом. При пользовании родителем он спокойно мог добавлять нули, а при пользовании потомком - теперь не сможет. То, что мы убрали одно предусловие, здесь уже роли не играет, потому что по итогу появляется ситуация, при которой старый код работал, а новый не будет.

Если бы мы просто убрали одно (или оба) требование родителя из метода потомка и не добавляли новое, тогда это бы считалось *ослаблением* предусловия, поскольку расширило бы количество ситуаций, при которых клиент смог бы успешно поработать с потомком. Допустим, потомок в случае null мог бы добавлять элемент 0 или как-то еще обрабатывать null. Важно, что метод бы отработал.

## Постусловия

Постусловия - это требования, которые накладываются на результат работы метода. Причем результат - это не обязательно возвращаемое из метода значение. Это именно "эффект" работы метода. Допустим, результат метода void sort() - это то, что после его работы элементы в коллекции располагаются в сортированном порядке. Сам метод void - а результат есть. "Элементы после выполнения метода располагаются в сортированном порядке" - это же и есть постусловие.

Вот еще пример:

```java
class Box {
    // Постусловия ("эффекты"):
    //   * Если критерий не задан, то возвращает все элементы из контейнера
    //   * Если задан, то возвращаются только соответствующие критерию элементы
    //   * Элементы возвращаются в произвольном порядке
    public Data[] all(Criteria criteria)
```

Ослабить постусловие - например, игнорировать переданный criteria, - нельзя. Потому что если клиент передает его, то ожидает, что ему вернутся только "правильные" элементы. Поэтому мы не можем, переопределяя метод потомка SortedBox.all, игнорировать требование применить к результату критерий отбора, если он задан.

"Элементы возвращаются в произвольном порядке" - это не ограничение, а наоборот - свобода. Т-е клиент, пользуясь родительским методом, никак на порядок элементов не опирается, потому что знает, что они могут возвращаться в каком попало порядке. Это позволяет нам в потомке ввести свое собственное ограничение на порядок элементов, "усилить" постусловие:

```java
class SortedBox {
    // Постусловия:
    //   v Если критерий не задан, то возвращает все элементы, хранящиеся в контейнере
    //   v Если задан, то возвращаются только соответствующие критерию элементы
    //   + Элементы возвращаются в отсортированном порядке  // <-- Добавили
    public Data[] all(Criteria criteria)
```

Теперь, когда кто-то будет пользоваться классом SortedBox и ему понадобится выбрать минимальный элемент, он может выбрать все элементы и взять первый, потому что знает, что они хранятся в отсортированном порядке. Если у SortedBox появится потомок, то он уже не сможет отказаться от условия, что элементы возвращаются в сортированном порядке, потому что на эту логику может опираться какой-то клиент.

## Инварианты

Инварианты - это условия, которые должны оставаться истинными на протяжении всей жизни объекта. Обычно они связаны с состоянием объекта.

Например, если у нас есть тип "Вес":

```java
class Weight {
    double amount = 5.0d;
    Units units = Units.Kilogramm;
}
```

То его инвариантом является условие `amount > 0`, потому что вес не может быть нулевой или отрицательный.

Когда объект создается, он обязательно должен создаться в корректном состоянии. Все проверки должны быть выполнены, например, в конструкторе или в фабрике объектов. После создания, все методы (и унаследованные, и собственные) должны предохранять инварианты.

# Вопросы

- [ ] Каким образом технически соблюдать пост- и предусловия в потомках?

  Например, у родителя есть требование, чтобы входной параметр метода был больше нуля. Как перенести это требование в потомка? Если просто копировать, то это выглядит не надежно, потому что можно забыть это сделать. Если же сделать какие-нибудь обертки над методами, чтобы это условие автоматически соблюдалось в потомках, то это некорректно, потому что потомки имеют право ослабить предусловие.

  Говорят, что Бертран Мейер в своем паттерне "проектирование по контракту" (или как-то так) предлагал подобные вещи вообще возлагать на клиента. Т-е сам метод исходит из того, что ему уже передают правильные входные данные. Но мне это кажется ненадежным.