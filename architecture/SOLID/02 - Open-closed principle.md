# Предисловие

Изначально принцип OCP (Open-Closed principle) сформулировал Бертран Мейер в своей книге 1988 года "Object-Oriented Software Construction" ("Объектно-ориентированное конструирование программных систем"). Его можно найти в книге (2-е издание) в части B, глава 3: Modularity, параграф 3.3 Five principles, подраздел "The Open-Closed principle", стр 57.

Кроме того, принцип упоминается в статьях и книге Роберта Мартина "Clean architecture" ("Чистая архитектура").

# Бертран Мейер

## Формулировка

Формулировка Бертрана Мейера:

> Modules should be both open and closed.

> Модули должны одновременно быть и открыты, и закрыты.

Оригинальные пояснения:

* Открытость

  > Module is said to be open if it is still available for extension. For example, it should be possible to expand its set of operations or add fields to its data structures.

  > Модуль считается открытым, если есть возможность его *расширения*. Например, есть возможность добавить в набор его операций новые операции, или добавить поля в его структуры данный.

  Хочется обратить внимание на слово *расширение* именно в значении *обогащения* модуля *новыми* операциями, а не просто изменения логики работы уже имеющихся операций. Статьи, попросту сводящие принцип к полиморфизму, как раз грешат тем, что упускают этот момент.

* Закрытость

  > A module is said to be closed if it is available for use by other modules. This assumes that the module has been given a well-defined, stable description. At the implementation level, closure for a module also implies that you may compile it, perhaps store it in a library, and make it available for others (its clients) to use.

  > Вольный перевод: модуль считается закрытым, если им уже спокойно могут пользоваться другие модули. "Спокойно пользоваться" подразумевает, что модуль имеет хорошо определенный, стабильный интерфейс. Закрытый модуль можно компилировать, хранить в библиотеке и раздавать всем нуждающимся.

  Одним словом, закрытость подразумевает завершенность, факт того, что модулем уже можно полноценно пользоваться.

## Применение

Необходимость для модулей быть одновременно открытыми и закрытыми продиктована двумя вещами:

* С течением времени для ПО характерно появление изменений, потому что заранее предусмотреть все операции, все структуры данных, которые могут понадобиться в будущем, практически невозможно. Поэтому модули должны быть открыты и разработчики должны иметь возможность вносить изменения в них, чтобы они отвечали актуальным требованиям.
* В то же время, распределенная разработка многомодульного ПО невозможна или крайне затруднительна, если модули не закрыты, потому что из-за зависимости модулей друг от друга, разработчики модуля *А* были бы вынуждены ждать, пока нужный им модуль *В* окончательно доработают. Иначе внесенные в *В* изменения могут быть настолько существенными, что вызовут целый каскад изменений в модуле *А*, а они, в свою очередь, могут повлечь такие же масштабные изменения в каком-нибудь модуле *С* и т.д. Доработка же до "финальной" версии, если соблюдать требование открытости, в принципе невозможна.

Без объектно-ориентированного подхода (ООП) существует всего два решения этой проблемы, и оба недостаточно хороши:

* Все-таки внести в исходный модуль нужные изменения. Последствия, как указывалось выше, могут быть печальными - необходимость внесения изменений во множество других модулей, некоторые их которых, возможно, никто не трогал годами. Еще хуже, если внесенные изменения технически не сломают другие модули, но сломают их логически, т-е старые модули будут работать, но выдавать некорректные результаты из-за того, что новые требования, ради которых вносились изменения, конфликтуют со старыми.
* Создать копию исходного модуля, внести в него изменения и отдать новым клиентам (под клиентами подразумевается код, которому нужен этот модуль, а не люди). Плюс в том, что не приходится трогать уже работающий код. Недостаток в том, что при большом потоке запросов на изменения, количество таких копий одного модуля может сильно вырасти, будет много дублирующегося кода.

ООП позволяет адаптировать второй подход и сделать его вполне приемлемым. Используя наследование, мы, по сути, получаем ту же копию исходного объекта, но без физического дублирования кода. Те операции, которые нам подходят, оставляем как есть; операции, требующие изменений в связи с требованием новых клиентов, мы переопределяем; отсутствующую функциональность - дописываем.

## Некоторые уточнения

Иногда можно встретить такой вопрос:

* А как исправлять ошибки в уже работающих модулях, если их нельзя изменять?

Вот что на этот счет говорит Бертран Мейер:

> Neither the Open-Closed principle nor redefinition in inheritance is a way to address design flaws, let alone bugs. If there is something wrong with a module, you should fix it — not leave the original as it is and try to correct the problem in a derived module. (The only potential exception to this rule is the case of flawed software
> which you are not at liberty to modify.) The Open-Closed principle and associated techniques are intended for the adaptation of healthy modules: modules that,although they may not suffice for some new uses, meet their own well-defined requirements, to the satisfaction of their own clients.

> Вольный перевод: принцип открытости-закрытости и наследование не являются средством обхода плохой архитектуры или исправления ошибок. Если в модуле есть ошибка - вы должны поправить ее именно в нем, а не создавать новый правильный. Единственное исключение - если у вас нет возможности \ права изменять код с ошибкой.
>
> Принцип открытости-закрытости и связанные техники направлены на адаптацию исправных модулей, которые корректно выполняют свою задачу, но просто не подходят некоторым новым клиентам.

Т-е не нужно возводить принцип в абсолют - если у вас есть возможность редактировать готовый модуль и вы уверены, что это не приведет к каскаду сопутствующих изменений или ошибкам (или вы сможете поправить и их тоже), то можете редактировать.

# Роберт Мартин

## Формулировка

Формулировка из книги "Чистая архитектура" Роберта Мартина:

> The Open-Closed Principle (OCP) was coined in 1988 by Bertrand Meyer.1 It says:
>
> > A software artifact should be open for extension but closed for modification.
>
> In other words, the behavior of a software artifact ought to be extendible, without having to modify that artifact.

В своем [блоге](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html) Роберт Мартин пользуется оригинальными формулировками Мейера. Что в блоге, что в книге принцип сведен к обычному полиморфизму: просто говорится о том, что надо использовать интерфейсы в местах, где возможны изменения, и подставлять разные реализации для изменения поведения.

Но подмена реализаций, по-моему, не является расширением функциональности, потому что мы по сути делаем то же самое, просто другим способом. Т-е внешне для клиента ничего не меняется - меняется внутренняя реализация. А самый интересный вопрос о том, что делать, если требуется изменить сам интерфейс, вообще не рассматривается.

Также у Мартина есть другая, более интересная [статья](https://web.archive.org/web/20060822033314/http://www.objectmentor.com/resources/articles/ocp.pdf), переведенная на [хабре](https://habr.com/ru/companies/tinkoff/articles/472186/).

Модули, отвечающие принципу открытости-закрытости, имеют два главных признака:

* Открыты для расширения.

  > They are “Open For Extension”. This means that the behavior of the module can be extended. That we can make the module behave in new and different ways as the requirements of the applica- tion change, or to meet the needs of new applications.

  > Это означает, что поведение модуля может быть расширено. То есть мы можем добавить модулю новое поведение в соответствии с изменившимися требованиями к приложению или для удовлетворения нужд новых приложений.

* Закрыты для изменений. 

  > They are “Closed for Modification”. The source code of such a module is inviolate. No one is allowed to make source code changes to it.

  > Исходный код такого модуля неприкасаем. Никто не вправе вносить в него изменения.

При такой формулировке, во-первых, явно видно противоречие между двумя требованиями. Вы не можете расширить функциональность класса, если не можете править его исходный код. Расширять - это добавлять новое, а не делать старое другим способом.

Во-вторых, формулировка закрытости выражена слишком категорично и плюс такое чувство, что в определение принципа внедрен совет технической реализации - не изменяйте и все. При этом нет пояснений, что, например, для исправления ошибок модуль изменять не только можно, но и нужно (если у вас есть к нему доступ) и это не является нарушением принципа. У Мейера в самой концепции закрытости нет ни слова о том, что модуль нельзя изменять. У него неизменяемость идет как один из вариантов реализации принципа и показаны исключения, при которых изменения допустимы.

## Полная закрытость невозможна

Мартин высказывает мысль, что "ни одна программа не может быть закрыта на 100%". По его мнению, решение проблемы расширения без изменения кода кроется в абстракциях. Мы вводим абстракции в местах потенциальных изменений и когда эти изменения приходят, то подменяем реализацию. Таким образом, мы можем обезопасить ("закрыть") модуль от *этого конкретного изменения*. Чем опытнее проектировщик программы, чем больше у него знаний и опыта в предметной области, тем больше таких мест он может предвидеть и закрыть абстракциями. Но защититься от всех потенциальных изменений обычно все-таки невозможно, можно только приблизиться к этому.

# Резюме

По-моему, не стоит концентрироваться на определениях, что такое "открытый" и "закрытый" модули. Обе формулировки, и Мейера, и Мартина, не способствуют пониманию общей идеи принципа и введены больше для того, чтобы оправдать название принципа. Вместо этого я предлагаю сконцентрироваться на принципе в целом и для себя вывел такую формулировку OCP:

> Введенный в эксплуатацию готовый модуль \ класс, который отлажен и не содержит логических ошибок, не следует изменять, дабы избежать возможных каскадных изменений в его клиентах и появления в них скрытых ошибок.

Несколько дополнительных выводов:

* Не вторгайтесь в модуль ради изменения логики его работы, *если она правильная* и корректно реализует требования уже существующих клиентов модуля. Если появляются новые клиенты с отличающимися требованиями, предоставьте им *новую* реализацию модуля. Как вы это сделаете технически - на основе существующей реализации, используя, например, наследование, или как-то иначе - зависит от вас.

  В случае изменения логики исходного модуля в угоду требований новых клиентов вы рискуете получить скрытые ошибки в уже существующих клиентах, если их требования конфликтуют с новыми. Технически все может работать, но результат для кого-то окажется неправильный.

* Если в модуле есть логическая ошибка, то исправляйте ее прямо в этом модуле (если у вас есть такая возможность). Создание наследника с целью исправить ошибки допустимо в случае, если править исходный модуль по каким-то причинам невозможно.

* Расширение функциональности и подмена реализации - не одно и то же. Полиморфизм позволяет в конкретных местах защититься от изменений, которые удалось предвидеть заранее, но он не позволяет вводить принципиально новую функциональность, он лишь позволяет по-разному выполнить концептуально одно и то же действие.

  На примере калькулятора: мы можем выделить абстракцию для выполняемой операции и реализовать сложение, вычитание, умножение, деление, возведение в степень, извлечения корня и прочее в виде отдельных компонентов. С виду это дает программе "расширяемость", но по сути мы делаем одно и то же - манипулируем числами, просто по-разному. Подлинной возможности расширить функциональность, например, сохранить историю вычислений, эта абстракция нам не даст.

  Поэтому, если у существующих клиентов вдруг появляется необходимость хранить историю вычислений, то нам, скорее всего, придется менять и код самого модуля калькулятора, и код его клиентов. И такие изменения не противоречат ОСР.