# Технологии взаимодействия микросервисов

Вкратце про несколько самых популярных.

## RPC

RPC - Remote Procedure Call, удаленный вызов процедур. Основная идея - сделать так, чтобы удаленный вызов выглядел как локальный. Существуют RPC-фреймворки. TODO: чтобы более детально понять, надо гуглить отдельно, но общая суть, насколько я понял, такая что после настройки мы можем, грубо говоря, в одном сервисе вызывать какой-то метод на объекте, но при этом произойдет запрос к другому сервису. Технология скроет всю подноготную возню, и для нас такой вызов будет выглядеть как локальный.

Упоминаются gRPC, SOAP, формат сериализации Protocol buffers язык описания интерфейса (interface definition language, IDL), язык описания веб-сервисов (web service definition language, WSDL). Эти языки описания еще фигурируют под названием "схема".

Недостатки:

* Потенциальная технологическая привязка. Некоторые реализации RPC, например Java RMI, привязывают сервисы к JVM. Т.е. оба сервиса должны использовать одну и ту же платформу. Правда есть и другие реализации, без такой привязки, например gRPC, SOAP, Apache Thrift.
* Удаленные вызовы дороже локальных и менее надежны. Фреймворк может уравнять их только внешне, однако нельзя забывать, что они - не одно и то же.
* Сложность изменения интерфейса. Передаваемые данные сериализуются в источнике и десериализуются в получателе. Соответственно, если в источнике меняются данные (например, добавляется новое поле), то этот же тип нужно менять и в получателе, иначе не десериализуется. Отсюда появляется более жесткая связь между источником и получателем - в случае каких-то изменений, нужно повторно разворачивать обоих. Аналогичное касается и интерфейсов. Нельзя просто добавить новый метод в источнике, не добавив его же и в получателе, даже если он этим методом не пользуется.

При использовании RPC важно не абстрагироваться полностью от сети, и делать так, чтобы было видно, что вызов все же удаленный. А еще писать так, чтобы интерфейс сервера можно было развивать отдельно, без необходимости обязательного обновления клиентов. Хорошая реализация - технология gRPC от Google. RPC хорошо подходит для реализации синхронной модели "запрос-ответ".

## REST

Про рест сильно понятнее не написано, чем уже известно. Упоминается: имеется возможность применять прокси-серверы кэширования HTTP, например Varnish, балансировщики нагрузки mod_proxy и многие инструменты мониторинга, уже с поддержкой HTTP. Эти инструменты позволяют обрабатывать большие объемы HTTP-трафика и маршрутизировать их разумно и довольно прозрачно.

### HATEOAS

"ReST в стиле HATEOAS" - т.е. hateoas это одна из возможностей организовать рест?

Hypermedia as the engine of application state. Гипермедиа - это концепция, в которой контент может содержать ссылки на другой контент в разных форматах (текст, изображения, видео, звуки). Пока трудно понять, в чем суть. Чел рассказывает на примере корзины в интернет-магазине. Т.е. есть вот концепция корзины и пользователь ее понимает. Соответственно, если мы изменим внешний вид корзины, ее расположение на экране или ссылку, по которой в нее можно перейти, для пользователя это все не имеет значения, потому что зная концепцию и ее возможности, он сможет ею пользоваться несмотря на все наши изменения.

Т.е. как бы основная идея HATEOAS в том, чтобы перенести эту идею на интерфейс между сервисами. Правда не очень понятно, как в этом случае нам абстрагироваться от ссылок. Ведь сервис не человек, который глазами поищет значок корзины на экране и пофигу, какая там ссылка. Сервисы делают запросы по конкретным ссылкам. В общем, мути нагоняют, надо отдельно будет гуглить.

Упоминается OpenAPI спецификация и проект Swagger. Как будто бы его можно использовать не только для описания эндпоинтов, но и генерации клиентского кода для взаимодействия с сервисом.

ReST хорошо подходит для предоставления доступа внешним клиентам, потому что позволяет кэшировать запроса.

# GraphQL

Опять же, требуется дополнительное гугление. GQL - это, насколько я понял, прежде всего язык (или спецификация, хз). Основная идея - уменьшить количество запросов для получения нужной информации. Например, требуется базовая информация о клиенте и его последних заказах. Эта выборка задействует два сервиса, да к тому же информация из каждого нужна не полностью, а только частично. С помощью GQL можно скрыть два запроса за одним, создав таким образом новую точку входа для клиента, которому нужна эта "финальная, объединенная информация", и которому абсолютно не хочется собирать ее по кусочкам самостоятельно.

# Брокеры сообщений

Брокеры - это промежуточное ПО (middleware), которое используется для реализации асинхронной связи между сервисами. В брокер уходит сообщение, которое в качестве нагрузки может содержать запрос, ответ или событие.

Брокеры организуют сообщения двумя стилями:

* Очереди - модель point-to-point, т.е. для связи одного экземпляра мс с одним экземпляром другого мс.
* Топики - модель, при которой сообщение могут получить много консюмеров. Например, несколько микросервисов подписываются на топик и каждый из них получает сообщения из топика.

Плюсы брокеров:

* Гарантированная доставка - большинство брокеров обладают этой характеристикой, очень полезной для асинхронной работы. Отправитель отправляет сообщение и не заботится лично о том, дошло оно или нет. Если получатель сейчас не доступен, то брокер хранит сообщение до тех пор, пока получатель его не заберет. Без брокера отправителю пришлось бы либо пытаться повторно слать сообщение, либо отказаться от отправления вообще.
* Гарантия порядка доставки - получатель читает сообщения в том порядке, в котором они пришли брокеру.
* Транзакции? Брокер удаляет сообщение только тогда, когда получатель его успешно обработал.

Примеры брокеров: RabbitMQ, ActiveMQ и Kafka.

В AWS есть Simple Queue Service (SQS), Simple Notification Service (SNS) и Kinesis.