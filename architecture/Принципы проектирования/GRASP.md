# GRASP

GRASP (general responsibility assignment software pattern) - общие шаблоны распределения ответственностей. Впервые введены в книге Крейга Лармана "Applying UML and Patterns".

Всего GRASP включает 9 шаблонов. Это шаблоны общего характера. Вообще распрелять их по группам можно по-разному. Например, Soer выделяет такие шаблоны как Information expert, Creator, Controller, Pure fabrication, Indirector в группу и называет их "Ролями". В другой группе он объединяет Polymorphism, Low coupling, High cohesion и называет их "Принципами", а Protected variations он называет "Свойством". Мне такая группировка понравилась и я использовал его в этом конспекте.

# Роли

Как запомнить? `СПИЧКа`. **С**оздатель **П**осредник **И**нформационный-эксперт **Ч**истая-выдумка **К**онтроллер.

## C.оздатель (Creator)

> Это обязанность по созданию объектов.

Здесь я нашел два сценария создания объектов:

* Созданный объект отправляется в свободное плавание. Создатель просто сконструировал его и отдал клиенту.
* Созданный объект остается в создателе и там и используется.

Первый сценарий распространяется на шаблоны вроде абстрактной фабрики и предполагает создание самостоятельных объектов, обычно весьма серьезных.

Второй больше для создания вспомогательных внутренних объектов, вроде `LineItem` (позиция в чеке, где указан товар и количество). Такой объект очевидно сам по себе не имеет смысла, но внутри условного объекта "Чек" помогает компоновать информацию, поэтому "Чек" как раз может выполнять функцию по созданию LineItem.

## П.осредник (Indirection)

Или "Посредник", "Перенаправление", "Косвенность". Часто один объект пользуется другим объектом для решения задачи. Например, контроллер принимает запрос и вызывает метод какого-то прикладного объекта, передавая ему пришедшие данные. Задача посредника - снизить зависимость между объектами за счет того, что он берет на себя функции по обеспечению их взаимодействия друг с другом. Типичное решение - паттерн Медиатор. Из плюсов - два компонента общаются друг с другом, при этом не имея понятия, кто конкретно является "собеседником". Из минусов - дополнительный уровень косвенности усложняет понимание программы.

По ощущениям, это куда выше, чем обеспечение гибкости через интерфейс, потому что здесь мы можем конфигурировать посредника и обеспечивать взаимодействие вообще любых объектов. Допустим, если мы объявили бы интерфейс `I ` и отдали бы его объекту `A`, то он смог бы работать только с объектами, реализующими `I`, а с помощью медиатора это ограничение снимается.

## И.нформационный эксперт (Information expert)

> Обязанность должна быть назначена тому, у кого есть максимум информации для ее выполнения.

Применительно к архитектуре, примером информационных экспертов являются модели в паттерне MVC, потому что у них есть доступ к данным, а следовательно методы обработки этих данных логичнее всего размещать именно в моделях, а не в контроллерах и уж тем более не в представлениях.

Применительно к коду это значит, что функциональность должна размещаться в том классе, который имеет больше всего информации для ее реализации. Например, если есть класс "Корзина", в котором хранится список выбранных для оформления заказа товаров, то логично будет разместить функциональность по рассчету общей стоимости заказа именно в корзине, а не где-то еще.

## Ч.истая выдумка (Pure fabrication)

Это классы, которые не подпадают под остальные четыре роли, но реализуют нужный программе функционал, например, разные технические утилиты. Пишут, что это очень похоже или даже то же самое, что паттерн "Сервис" из DDD. Правда приводят еще пример репозитория, однако сервис и репозиторий в DDD это разные вещи.

## К.онтроллер (Controller)

> Принимает управляющие воздействия от UI или от других систем и передает их исполнителям.

Основной задачей контроллера является "встретить" запрос к системе и адресовать его исполнителю. Если для выполнения задачи требуется задействовать несколько исполнителей, контроллер может также взять на себя координацию между ними.

Например, в MVC все так и происходит - контроллер принимает запрос и использует средства модели для его выполнения.

# Принципы

Как запомнить? `HeLP`

## H.igh cohesion

Подробно описано в конспекте по ООП. Вкратце: под cohesion понимается логическая связь между элементами, составляющими модуль, и эта связь должна быть как можно сильнее, тогда в модуле не будет ничего лишнего. Если какой-то элемент (метод класса, или сам класс) выбивается из общей логики, то его следует переместить в другой модуль.

## L.ow coupling

Подробно описано в конспекте по ООП. Вкратце: под coupling понимается связь между программными модулями и эта связь должна быть как можно слабее, чтобы модификация одного модуля по минимуму влияла на работу другого.

## P.olymorphism

> Должна быть возможность повторно использовать код с помощью выделения интерфейсов.

Полиморфное поведение является одним из столпов ООП, на котором строятся такие шаблоны, как например "Стратегия". Определение интерфейса для какой-либо операции позволяет нам писать сколько угодно реализаций для нее и заменять эти реализации друг на друга без необходимости править клиентский код, который этими операциями пользуется.

# Свойства

## Protected variations

Или "Устойчивость к изменениям". В книге Лармана такого принципа я не нашел, а в интернете есть две трактовки:

> Элементы должны быть защищены от влияния на них изменений в других элементах.

> Система должна быть устойчива к изменениям.

В первой трактовке под элементами традиционно понимается все что угодно - от классов до целых модулей, и трактовка говорит, что проектировать элементы надо так, чтобы изменения одного элемента не приводили к вееру изменений в других. Для понимания как это реализовать на практике существуют более конкретные принципы вроде High Cohesion, Low Coupling, SOLID и т.д.

Вторая трактовка подразумевает, что в случае изменения \ добавления новых требований, дизайн системы позволяет эти новые требования удовлетворить без каких-то больших сложностей и глобального переписывания системы. Такие вещи обычно решаются введением абстракций в потенциальных точках изменений системы.

В общем можно сказать, что устойчивость к изменениям не может быть абсолютной. Так или иначе получится система, которая устойчива к одним видам изменений, но не устойчива к другим.