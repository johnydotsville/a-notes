# KISS

> Keep it simple, stupid.

Изначально фразу приписывают Келли Джонсону, авиационному инженеру, который предлагал проектировать самолеты так, чтобы пилот "в поле" мог отремонтировать его, имея базовые знания и простые инструменты.

Применительно к ПО принцип означает, что код нужно писать так, чтобы в результате он получился максимально простым для понимания и модификации. Для этого программист должен применять устоявшиеся в индустрии стандарты и хорошие практики, шаблоны проектирования и т.д. В этом случае, если программист обладает достаточными знаниями и опытом, то для него и для других программистов получившийся код не будет представлять проблем в будущем. Т.е. простота здесь не означает "примитивность", не означает что код должен быть понятен даже совсем слабому программисту, который не знаком с принципами проектирования.

KISS является широким взглядом на хороший код. Поэтому существует ряд других принципов, таких как DRY, YAGNI, SoC, Information hiding и т.д., которые дают более конкретные рекомендации по написанию хорошего кода.

# DRY

> Don't repeat youself. Не повторяйся.

Также существует под акронимом DIE - duplication is evil. Принцип напоминает о необходимости избегать дублирования кода. Когда код не DRY, он WET (Write Everything Twice, "Пиши все дважды"). Плохое дублирование порождается несколькими способами:

* Copy-paste programming - когда *одинаковая* задача решается копированием кода из одного места программы (системы) в другое место этой же программы. В итоге получается два *независимых* фрагмента кода, решающих *одну и ту же* задачу. Поэтому когда эта логика меняется, приходится править ее не в одном месте, а в нескольких. При активной копипасте таких мест может быть много и чем их больше, тем выше вероятность забыть поменять где-то. Поэтому одна и та же задача будет в разных частях системы решаться по-разному и это приведет к ошибкам.

  Например проверка, принял ли пользователь условия договора. Вместо того, чтобы оформить эту проверку в виде отдельного элемента и вызывать его каждый раз, когда требуется выполнить проверку, можно каждый раз копировать код и таким образом плодить дублирование.

* Magic strings \ numbers - когда конкретные строки \ числа *напрямую* используются в коде (обычно больше одного раза) и на них опирается какая-то логика. В итоге, если вдруг требуется изменить такую строку \ число, то приходится делать это во многих местах и опять появляется опасность пропустить какое-то место и получить неправильное поведение.

  Например, каждый раз писать ключ в словаре непосредственно строкой "username" вместо того чтобы оформить ее в виде константы и далее пользоваться константой. Или определить количество допустимых повторных попыток как 3 и везде писать цифру 3, вместо оформления этого параметра в виде константы.

Следуя принципу DRY, главное не "пересушить" код. Иногда дублирование может быть хорошим. Например, у нас есть отдел бухгалтерии и отдел менеджмента, которые рассчитывают вознаграждение работнику за его труды. Оба отдела для этого используют отработанные часы. Предположим, что изначально они пользовались одинаковым алгоритмом учета часов. Мы можем написать метод calcHours для расчета этих часов и вызывать его в модулях бухгалтерии и менеджмента, чтобы те рассчитали вознаграждение. Потом нам приходит информация, что отдел менеджмента решил учитывать часы по-другому (например, учитывать часы, потраченные на работу "неофициально", неважно). Мы открываем модуль менеджмента и видим, что там вызывается метод calcHours. Если мы забыли (или даже не знали), что calcHours используется не только менеджментом, но и бухгалтерией, то после исправления этого метода мы повлияем и на работу бухгалтерии, хотя она никаких изменений не просила. Этот пример демонстрирует то, что не достаточно просто выделять общий код в отдельные элементы, надо думать шире. В данном случае нам следовало бы изначально ввести абстракцию "расчет часов" и две реализации "расчет часов для бухгалтерии" и "расчет часов для менеджмента" и в каждую реализацию скопипастить идентичный код. Это впоследствии защитило бы нас от описанной ситуации, когда изменения для одного отдела влияют и на другие отделы.

# Information hiding

Принцип предполагает, что все детали компонента, которые не нужны клиенту для пользования компонентом, должны быть от клиента скрыты. Клиенту должен быть доступен только API. Это дает следующие преимущества:

* Можно менять внутреннюю реализацию компонента без необходимости переписывать клиентов, потому что с точки зрения API ничего не поменялось.
* Клиент не имеет возможности повлиять на работу компонента по незапланированному разработчиком компонента сценарию. Проще говоря, меньше деталей доступно - меньше шансов все сломать.

# YAGNI

> You aren't gonna need it. Тебе это не понадобится.

Принцип призывает реализовывать какую-то функциональность только тогда, когда в ней возникает реальная необходимость, а не потому что вам кажется, что она понадобится в будущем. "Функции будущего" являются пустой тратой времени и средств, потому что могут так и не понадобиться.

Этот принцип обычно не относится к *архитектурным* решениям. Если какой-то код нужен для того, чтобы упростить последующие изменения, то он не относится к напрасным тратам. Условно говоря, введение абстракции, которая позволит заменить способ выполнения некоторого действия на другой - это нормально. А вот реализация этого "другого" способа заранее - это плохо. Реализуем только тот, который нужен сейчас.

# SoC

Separation of concerns или принцип разделения ответственности. Заключается в декомпозиции крупной системы на более мелкие модули, каждый из которых выполняет четко определенную задачу. Применимо на все уровнях. На уровне архитектуры приложения в целом в качестве примера можно привести разделение системы на пользовательский интерфейс, прикладной слой, слой бизнес-логики и слой инфраструктуры. На уровне пониже - форматирование ввода и его валидация не должны быть совмещены. Например, один класс ответственнен за перевод тела сообщения из формата json в объект определенного типа, а другой класс - за проверку этого объекта на предмет корректности содержимого с точки зрения приложения.

# BDUF

> Big Design Up Front. "Проектирование прежде всего".

Частично перекликается с моделью разработки Waterfall, когда сперва программа полностью продумывается, от А до Я, и только потом пишется. Это не стыкуется с agile-методикой и в целом не совместимо с естественной природой требований изменяться в процессе разработки.

Поэтому проектирование должно быть не всеобъемлющим, а только обозначить ключевые моменты, как например выбор технологий (язык программирования, фреймворки, протоколы), а не конкретные элементы программы (компоненты, классы и т.д.).