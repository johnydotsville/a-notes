# Отношения между классами

Все три понятия - наследование, агрегация и композиция - выражают отношения между классами \ объектами. У каждого вида этих отношений есть специфические черты. В UML обозначаются следующим образом:

![arrows-agregation-composition-inheritance.drawio](img/arrows-agregation-composition-inheritance.drawio.svg)

> Вариант, как запомнить обозначение агрегации и композиции: пустой ромб похож на букву О, а слово агрегация вполне можно произнести как "Огрегация".
>
> Закрашенный ромб можно просто назвать *К*рашеный, а композиция как раз начинается с буквы "К".

# Наследование

Когда класс `C` является наследником класса `P`,  то отношение между ними выражается как `c-IS-p` ("*C является P*").

Это связь на уровне компиляции. Ее невозможно разорвать или заменить при выполнении программы, поэтому она считается самой прочной. 

# Композиция и агрегация

Композиция и агрегация являются подвидами *ассоциации*. Они характеризуются тем, что в них связь между классами организуется по принципу *контейнера* и *вложения*. Один класс `I` как бы вкладывается в другой класс `C` и получается отношение `c-HAS-i` ("*C содержит I*"). 

Эта связь гораздо более гибкая, чем наследование, поскольку задать тип вложения можно во время выполнения программы, а не только при компиляции.

Отличия между ними заключаются во влиянии контейнера на временя жизни вложения:

* При композиции контейнер влияет на время жизни вложения. Сколько живет контейнер, столько же живет и вложение, потому что оно создается непосредственно в контейнере.
* При агрегации время жизни контейнера не влияет на время жизни вложения. Контейнер и вложение имеют независимое время жизни, поскольку вложение создается *вне* контейнера и просто передается ему уже в готовом виде.

Как запомнить? "Композиция" ассоциируется с художественной картиной. Картина - это контейнер, а все, что на ней нарисовано - вложения. Сжигаешь картину и исчезают все вложения, как и происходит при композиции. Агрегация - ассоциируется с каким-то нагромождением вещей, "гора". Как корзина яблок. Если сжечь корзину, яблоки останутся.

## Композиция

Пример композиции:

```java
interface Repo { }
class PostgresRepo implements Repo { }

class Service {  // Service явлется "контейнером"
    private final Repo repo = new PostgresRepo();  // Repo выступает в роли "вложения"
    
    public void save(Person p) {
        repo.save(p);  // Для решения какой-то задачи контейнера используем функциональность вложения
    }
}
...
void main() {
    var s = new Service();
    // При утрате ссылки на сервис потеряется также и ссылка на репо
    // и оба объекта будут уничтожены.
}
```

Можно сделать композицию более гибкой, заменив конкретный тип вложения фабрикой:

```java
interface Repo { }
interface RepoFactory { }

class PostgresRepo { }
class PostgresRepoFactory { }

class Service {
    private final Repo repo;
    // private final RepoFactory repoFactory;
    
    public Service(RepoFactory repoFactory) {
        // this.repoFactory = repoFactory;  // Опционально можно сохранить и фабрику
        this.repo = repoFactory.create();
    }
    
    public void save(Person p) {
        repo.save(p);
    }
}
...
void main() {
    var rf = new PostgresRepoFactory();
    var s = new Service(rf);
    // Ссылка на репо все также потеряется при утрате ссылки на сервис
    // и оба объекта будут уничтожены.
}

```

В данном случае, если сохранить фабрику внутри сервиса, то между ними будет отношение агрегации. Когда исчезнет ссылка на сервис, это никак не повлияет на фабрику, потому что она передавалась в сервис извне. Но вот между сервисом и репозиторием остается отношение композиции, поскольку репозиторий все еще создается внутри сервиса, а значит, когда исчезнет ссылка на сервис, то и репозиторий исчезнет тоже.

## Агрегация

Пример агрегации:

```java
interface Repo { }
class PostgresRepo implements Repo { }

class Service {  // Service является "контейнером"
    private final Repo repo;
    
    public Service(Repo repo) {  // Контейнер лишь получает вложение, а не создает его сам
        this.repo = repo;
    }
    
    public void save(Person p) {
        repo.save(p);
    }
}
...
void main() {
    var r = new Repo();
    var s = new Service(r);
    // Репо продолжит жить после утраты ссылки на сервис, потому что создан независимо от сервиса.
}
```

# Применение

В целом считается, что агрегация предпочтительнее композиции, т.к. более гибкая. Считается, что увлечение композицией нарушает принцип инверсии зависимостей. Некоторые даже говорят об преимуществах КиА над наследованием.

Мне кажется, что такие утверждения смысла не имеют, потому что все эти вещи используются для разных целей, а не одно вместо другого.

Наследование нужно для постепенного наращивания "собственной" функциональности иерархии классов. С помощью наследования можно удобно организовывать ветвление функциональности. На примере коллекций: любая коллекция предоставляет итерацию по элементам. Это первая ступень наследования. Любая коллекция также позволяет узнать свой размер. Это вторая ступень наследования. Далее идет специализация коллекций - списки хранят элементы в порядке добавления, множества хранят элементы без дублирования, очереди могут хранить элементы в порядке, зависящем от их приоритета и т.д. Подобная функциональность естественным образом наращивается через наследование.

С помощью агрегации и композиции можно снабдить объект функциональностью, которая ему нужна, но не является его непосредственной обязанностью. Например, объект контроллера и репозиторий. Репозиторий может сохранить \ выбрать из БД нужные данные, а контроллер может принять запрос от пользователя. Абсурдно было бы снабжать сам контроллер возможностью подключения к БД или учить репозиторий разбирать веб-запросы. Поэтому с помощью ассоциации мы просто связываем два объекта с принципиально разной функциональностью и полученная комбинация позволяет нам решить задачу "обработать запрос пользователя и вернуть ему нужные данные". При этом мы можем использовать как композицию, так и агрегацию.

