# Сервисы

Обычно сущности включают в себя какие-то операции, которые естественным образом вписываются в их концепцию. Но иногда попадаются операции, которые трудно с логической точки зрения вписать в какую-нибудь сущность или VO. В этом случае, вместо того, чтобы искусственно, через силу, искать такой операции место в сущностях, можно просто ввести понятие *сервиса*.

Сервис - это операция, которая представлена самостоятельным объектом и располагается в доменном слое. Имя сервиса обычно выражает его "деятельную" природу, т.е. больше походит на глагол, чем на существительное, и это имя должно быть взято из общего языка (ubiquitous language).

Однако, прежде чем оформлять операцию в виде сервиса, нужно сначала максимально честно попытаться найти ей место в подходящем объекте, а если это никак не удается, тогда уже оформлять ее в сервис. Иначе можно скатиться в процедурное программирование, когда в итоге окажется, что половина объектов - это объекты с данными, без какого-либо поведения, а другая половина объектов - это объекты с командами, без какого-либо состояния.

Хороший сервис обладает тремя характеристиками:

* Операция является одной из концепций домена, но при этом естественным образом не ложится ни в одну из сущностей или VO.
* Интерфейс операции выражается в терминах домена, т.е. параметры операции или ее результат являются доменными объектами.
* Операция не имеет состояния. Отсутствие состояния в данном случае означает, что клиент может использовать экземпляр сервиса независимо от индивидуальной истории сервиса. Т.е. должно быть не важно, кто и как раньше с этим экземпляром работал.

Сервис при выполнении может использовать информацию, которая доступна глобально, и изменять эту информацию, т.е. иметь сайд-эффекты. Но в себе он эту информацию содержать не должен.

Сервисы нужны, чтобы не переусложнять сущности и VO сложными операциями, которые, например, могут задействовать в себе несколько доменных объектов. Помещение таких сложных операций в сущности и VO ведет к появлению лишних зависимостей между сущностями, размывает их назначение и связывает концепции, которые вполне можно было бы понять в отрыве друг от друга.

# Сервисы с разных слоев

Сервисы бывают трех видов:

* Сервисы доменного слоя.
* Сервисы слоя приложения.
* Сервисы инфраструктурного слоя.

Их нужно уметь отличать друг от друга. Сервис инфраструктурного слоя не имеет бизнес-значения и является простой утилитой, выполняющей чисто техническую функцию. Пример: банковское приложение должно отсылать клиенту уведомление по e-mail, если баланс на счете снизится до определенного значения. Сервис, который инкапсулирует логику отправки e-mail, является инфраструктурным. Аналогичный сервис может слать смс, писать в телеграм и т.д. Все это тоже инфраструктура - она ничего не знает и не должна знать ни о какой бизнес-логике.

Сервис доменного слоя и сервис слоя приложения может быть сложнее отличить друг от друга. На том же примере с уведомлением, если предположить, что определение границы баланса, при которой надо высылать уведомление, реализовано в виде сервиса, то это - сервис доменного слоя. А сервис слоя приложения выполнял бы связующую функцию между инфраструктурным сервисом и доменным. Эта функция заключалась бы в опросе доменного сервиса на предмет "Нужно ли слать уведомление?" и если нужно, то отдать инфраструктурному сервису команду выслать это уведомление.

В данном примере определение границы баланса могло быть выполнено не обязательно как сервис, а просто как операция самой сущности "БанковскийСчет". Но принципиально это бы ничего не изменило - сервис приложения все равно запросил бы информацию о том, нужно ли уведомление, у этой сущности, т.е. по сути у доменного слоя, а не решал бы этот вопрос сам.

Более удачный пример доменного сервиса - это операция перевода денежных средств с одного счета на другой. В ней задействуются два банковских счета, у которых может быть две простых операции - увеличить баланс и уменьшить баланс. Тогда сервис мог бы просто использовать для выполнения целостной операции перевода функционал самих счетов - вызвать на одном счете команду увеличения, а на другом - команду уменьшения. Это идеальный сервис доменного слоя, потому что "ПереводСредств" - это термин из предметной области, и потому что работа заключается исключительно в выполнении чисто бизнесовых операций - уменьшение и увеличение баланса.

Многие сервисы прикладного и доменного слоев действуют подобным образом, как "менеджеры". Их собственная работа строится поверх функционала, предоставляемого доменными объектами. Сервисы организуют, связывают, координируют объекты домена таким образом, чтобы эти объекты в своей совокупности выполнили нужную бизнес-работу. Такая организация нужна, потому что хорошо спроектированные сущности не делают ничего лишнего, стало быть их работа слишком конкретна и детализирована, чтобы выполнить какую-то более крупную, масштабную работу. Организованные вместе с помощью сервисов, они способны выполнять любой сложный пользовательский сценарий (use-case).

Организация хитрой функциональности в виде сервисов, во-первых, упрощает переиспользование этой функциональности, т.к. сервис инкапсулирует всю нужную логику и поэтому может быть перенесен целиком как есть. Во-вторых, бизнес не просачивается в уровень приложения, а если бы просачивался, то там недалеко и до просачивания в уровень интерфейса, что совсем уж печально. Сущности обеспечивают предельную детализацию функциональности, сервисы - среднюю детализацию.

Итого, список возможных действий:

* Сервис "Перевод" прикладного слоя:
  * Получает ввод из внешнего мира, например, в формате XML.
  * :question: Поднимает все необходимые для выполнения команды объекты доменного слоя: например, создает экземпляр сервиса "Перевод" доменного слоя, извлекает из хранилища объекты счетов, между которыми происходит перевод.
  * Посылает команду сервису "Перевод" доменного слоя.
  * Ждет подтверждения выполнения команды.
  * На основе этого подтверждения принимает решение об отправке уведомлений с помощью инфраструктурного сервиса.
* Сервис "Перевод" доменного слоя:
  * Вызывает нужные команды на сущностях, например, уменьшает и увеличивает баланс.
  * Отдает результат работы прикладному сервису, например, операция отклонена или прошла успешно.
* Сервис "Уведомление" инфраструктурного слоя:
  * Посылает e-mail, смс или иным способом выполняет конкретное оповещение пользователя.

TODO: Пункт, помеченный знаком вопроса, я дописал сам. В принципе как будто бы все указывает на то, что прикладной слой должен сконструировать кусок домена, чтобы выполнить задачу: создать нужный доменный сервис, вытащить из БД с помощью репозиториев нужные сущности, передать их доменному сервису и т.д. Но прямо явно про это еще написано не было, поэтому все-таки я помечаю этот пункт как сомнительный.

Из собственных размышлений могу добавить, что в прикладном сервисе не следует соединять работу нескольких сущностей - для этого нужно создать доменный сервис и сделать это там. А вот если команда простая и ее можно выполнить всего лишь с помощью одной сущности, тогда можно это сделать прямо в прикладном сервисе. Словом, любые сколько-нибудь сложные операции уровня бизнес-логики, требующие взаимодействия больше чем одной сущности, нужно оформлять именно в слое бизнес-логики. Это как, грубо говоря, если нужно просто вытащить информацию из БД о пользователе и вернуть как есть, то можно использовать репозиторий прямо в методе контроллера. А если требуется какое-то преобразование этой информации, фильтрация и т.д., тогда это нельзя писать в методе контроллера, нужно оформить это где-то "глубже", а контроллеру отдать результат, который он просто вернет клиенту.

# Связь с внешним миром

В оригинале написано так:

We might like to create a Funds Transfer object to represent the two entries plus the rules and history around the transfer. But we are still left with calls to SERVICES in the interbank networks. What's more, in most development systems, it is awkward to make a direct interface between a domain object and external resources. We can dress up such external SERVICES with a FACADE that takes inputs in terms of the model, perhaps returning a Funds Transfer object as its result. But whatever intermediaries we might have, and even though they don't belong to us, those SERVICES are carrying out the domain responsibility of funds transfer.

В переведенной книге так:

Теоретически можно было бы создать объект Перевод (Funds Transfer), представляющий два банковских счета плюс регламентные правила и история перевода. Но в межбанковских сетях все равно никуда не деться от вызова СЛУЖБ. Более того, в большинстве сред разработки создавать прямой интерфейс между объектом предметной области и внешними ресурсами - это нарушение стиля программирования. Внешние СЛУЖБЫ можно "задрапировать" ФАСАДНЫМ МЕТОДОМ ( FACADE), на вход которого поступают объекты модели, а возвращается в качестве результата, например объект Перевод. Но какие бы у нас ни были посредники (пусть даже не из нашей системы), эти СЛУЖБЫ все равно выполняют обязанности из предметной области по переводу денежных средств.

TODO: Не могу сказать точно, что это значит, но по ощущениям говорится о том, что как бы мы ни оформляли ПереводСредств, в виде сервиса или сущности, нам все равно придется иметь дело с какими-то внешними сервисами, т.е. можно сказать с чисто технической стороной, которая вне нашей юрисдикции и ничего про нашу модель не знает. Решением может послужить создание фасада, у которого вход и выход выражен объектами нашей модели, а внутри фасада уже идет перевод этих объектов в понятный внешней системе формат и вызов ее команд.