



# Предварительно

EntityManager - основной интерфейс в JPA для обращения с данными.

В хибере есть 4 состояния, в которых может находиться объект:

* Временное

  Это новый объект, который мы еще не сохранили и контекст о нем ничего не знает.

* Хранимое (persist)

  Это сохраненный объект и за изменениями в нем наблюдает контекст. Сохранение выполняется методом persist(). Это и правда сохранение - после вызова этой команды выполняется sql insert. Последующие изменения объекта приведут к выполнению sql update.

  ```java
  Actor actor = new Actor();
  actor.setName(new Name("Tom", "Sawyer"));
  manager.getTransaction().begin();
  manager.persist(actor);  // insert
  actor.setName(new Name("Huck", "Finn"));  // update
  manager.getTransaction().commit();
  ```

  

* Отсоединенное (detach)

* Удаленное

Единица работы - это последовательность операций, которые переводят объект из одного состояния в другое, и выполняются атомарно. Грубо говоря, что-то вроде транзакции, а может это и есть просто другое название транзакции.

Контекст хранения - это служба, отслеживающая все изменения в *хранимом* объекте, которые выполняются в рамках единицы работы.

# EntityManager

 EntityManager - это по сути и есть контекст.

```java
import jakarta.persistence.Persistence;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.EntityManager;

EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
manager = factory.createEntityManager();
```

Когда объект выбран из БД, он помещается в контекст. И перед следующей выборкой хибер всегда сначала смотрит контекст, нет ли в нем объекта, который мы пытаемся найти. Если есть, то повторного обращения к БД не происходит. Изменить эту механику нельзя:

```java
Actor actor = manager.find(Actor.class, 224);  // select ...
Actor actor2 = manager.find(Actor.class, 224);  // Не будет повторного select
```

По-хорошему, наверное нужно все операции проводить внутри try-catch, но я буду говнить и писать без них, чтобы не раздувать примеры.

## Сохранение

Здесь напишу любопытные наблюдения. Вот код сохранения нового актера в БД:

```java
Actor actor = new Actor();
actor.setName(new Name("Tom", "Sawyer"));
manager.getTransaction().begin();
manager.persist(actor);  // select nextval('actor_actor_id_seq')
actor.setName(new Name("Huck", "Finn"));
manager.getTransaction().commit();
// insert into actor (first_name, last_name, actor_id) values (?, ?, ?)
// select a1_0.last_update from actor a1_0 where a1_0.actor_id=?
// update actor set first_name=?, last_name=? where actor_id=?
// select a1_0.last_update from actor a1_0 where a1_0.actor_id=?
```

id в таблице актеров генерируется последовательностью. В момент вызова persist хибер запрашивает у БД id для нового актера, а все остальные операции производятся только при вызове commit. Причем как видно, persist приводит к выполнению insert + select (потому что поле last_update автоматически заполняется на стороне БД и хибер должен его выбрать, чтобы заполнить сохраненный объект), а следующее изменение имени приводит к выполнению update + select.

Т.е. получается два запроса, хотя имхо логичнее было бы, чтобы не генерировались лишние запросы, а просто бралось последнее состояние объекта.

Вот еще пример. Тоже грязь, но показывает, что нужно выполнять работу внутри try и откатывать транзакцию в случае ошибок:

```java
Actor actor = new Actor();
actor.setName(new Name("Tom", "Sawyer"));

EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
EntityManager manager = factory.createEntityManager();
EntityTransaction tr = manager.getTransaction();
try {
    tr.begin();
    manager.persist(actor);
    actor.setName(new Name("Huck", "Finn"));
    tr.commit();
} catch (Exception ex) {
    System.out.println("Откат транзакции");
    tr.rollback();
} finally {
    if (manager != null && manager.isOpen()) {
        manager.close();
    }
}
```

Поскольку это грязь, тут создается и factory, но вообще она должна создаваться где-то гораздо выше и быть единственной на все время работы приложения. manager может создаваться чаще, например, на каждый веб-запрос. В каком-то локальном приложении я не знаю как правильно его создавать.

## Обновление



# Вопросы

* JDBC Connection пул соединений, поподробнее, как создается, как управляется, какая связь с EntityManager

* Что такое текущая системная транзакция?

* EntityManager.flush() - для чего?

* EntityTransaction и UserTransaction

  Из того, что удалось примерно понять (но это не точно, мб это ложь, пиздеж и провокация): есть два варианта: либо у нас транзакция выполняются в рамках одной БД ("обычная" транзакция, так назову), либо транзакция может затрагивать несколько БД (распределенная транзакция). Так вот, чтобы работать с распределенными транзакциями, используется интерфейс UserTransaction из JTA (Java Transaction API), а чтобы с обычными - интерфейс EntityTransaction из JPA.

* persist(), генерация id и insert. После выполнения perisist объект получает id, но еще не вставляется как я понял. А как он тогда id получает? Но кроме того, он все-таки может вставляться при persist, т.е. может вставляться, а может нет, зависит от способа генерации id?



# Черновик

EntityManager - основной интерфейс для создания единиц работы. Создается с помощью EntityManagerFactory. EMF - это по сути одна логическая база данных или как еще говорят "единица хранения" (persistence unit). На все приложение обычно существует только один, общий, объект EMF. А EntityManager создается обычно для каждого запроса.



# Некие факты

* EM не извлекает из пула соединение до тех пор, пока не надо выполнить запрос.

  