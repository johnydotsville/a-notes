Может быть немного больно.

# Зависимости

Нужна зависимость хибера и конкретного провайдера. Мне хватило вот таких:

```xml
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.1.0.Final</version>
</dependency>
```

```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.3.6</version>
</dependency>
```

# Два стиля конфигурирования

Хибер можно использовать как самостоятельную технологию, а можно как реализацию JPA. При этом как минимум отличается способ конфигурирования.

## Hibernate-стиль

Конфигурация кладется в папку resources/META-INF/hibernate.cfg.xml

Конкретно этот стиль я пока не использовал, не буду про него ничего писать.

## JPA-стиль

Конфигурация кладется в папку resources/META-INF/persistence.xml

```xml
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
             version="3.0">
    <persistence-unit name="dvdrental-pu">
        <description>JPA s ru4koi</description>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <properties>
            <property name="jakarta.persistence.jdbc.driver" value="org.postgresql.Driver" />
            <property name="jakarta.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/dvdrental" />
            <property name="jakarta.persistence.jdbc.user" value="postgres" />
            <property name="jakarta.persistence.jdbc.password" value="j123" />

            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
        </properties>
    </persistence-unit>
</persistence>
```

Собственно все понятно и так, это минимальная конфигурация.

Здесь явно написаны данные для подключения к БД, но еще их можно вынести в какой-то отдельный то ли файл, то ли что, я не знаю, при этом задействуется JNDI, а я совсем не понял, что это такое.

Кроме того, в некоторых примерах тут же написаны классы, которые участвуют в хранении, и была настройка, чтобы убрать автоматическое сканирование классов. Но у меня явное перечисление классов вызвало только проблемы. Я удалил весь этот треш и начало хоть как-то работать.

# Объявление сущности

Здесь на примере класса и подкласса покажу как я сохранил в БД актера. Особенность в том, что поля, которые должны сохраняться в одну таблицу, тут размазаны по двум классам: базовая абстрактная сущность имеет id, а имя и фамилия - в классе актера.

Кроме того, есть такие особенности:

* Не все поля потребуется сохранять - некоторые надо игнорировать
* Поле Id в разных таблицах называется по-разному

Базовая сущность: в ней мы зададим поле идентификатора, укажем стратегию генерации идентификатора, но не будем указывать, на какой столбец таблицы это поле должно проецироваться, т.к. у каждой конкретной сущности есть своя таблица и там id-поле называется по-разному:

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Transient;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;

@MappedSuperclass
public abstract class AbstractEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Transient
    private LocalDate createdAt;
    @Transient
    private LocalDate modifiedAt;

    public AbstractEntity() {
        createdAt = LocalDate.now();
        modifiedAt = LocalDate.now();
    }
    ...
}
```

Класс актера:

```java
import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Entity;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import javax.validation.constraints.Size;

@Entity
@Table(name = "actor")
@AttributeOverride(name = "id", column = @Column(name = "actor_id"))
public class Actor extends AbstractEntity {
    @Column(name = "first_name", length = 45)
    @Size(min = 2, max = 45)
    private String firstName;
    @Column(name = "last_name", length = 45)
    @Size(min = 2, max = 45)
    private String lastName;

    public Actor() {
        super();
    }
    ...
}
```

# Объяснения

* @Entity - с помощью этой аннотации мы сообщаем, что класс участвует в хранении.

* @Id - каждая сущность, сохраняемая в БД, обязана иметь идентификатор. Обычно это суррогатный ключ, который генерирует или приложение, или СУБД.

* @GeneratedValue - для генерации этого суррогатного ключа есть несколько стратегий. На момент написания я детально в них не разбирался. Знаю, что можно использовать отдельные созданные в БД последовательности, но в моем случае заработал обычный автоинкремент.

  UPD. Заработал он только благодаря тому, что в БД была создана последовательность для генерации. Как хибер ее отыскал, я не знаю. В этом буду разбираться потом.

* @Table - с помощью этой аннотации явно задаем, с какой таблицей мы сопоставляем сущность.

* @Column - через эту аннотацию можно задать несколько параметров. В данном случае я использовал два: к какому столбцу мы хотим привязать поле и какой максимальный размер поля. Причем максимальный размер в данном случае не выполняет валидацию в том смысле, что он просто даст ошибку при попытке сохранить что-то длинное, но в самом процессе валидации не участвует.

* @Size - валидирующая аннотация. Вот она как раз заполнит ошибки валидации при валидировании объекта.

Комбинация @MappedSuperclass, @Transient и @AttributeOverride:

* @MappedSuperclass

  При наследовании поля суперкласса не подлежат сохранению. Да и вообще для суперкласса не положено иметь отдельную таблицу. Но поскольку мы конечно хотим сохранять поле Id для каждой сущности-наследника, то должны аннотировать родителя @MappedSuperclass - т.о. хибер поймет, что поля родителя участвуют в хранении.

* @Transient - позволяет игнорировать поле при сохранении. Поскольку на момент написания у меня в БД было поле last_update и СУБД заполняла его автоматически, а поля под дату создания вообще нигде не было, но при этом поля в классах хотелось сохранить, т.к. их идея мне нравится, то я просто поставил их игнорирование. Двойная польза.

* @AttributeOverride - поскольку у каждой таблицы под сущности в БД поле идентификатора называется по-разному (actor_id, country_id и т.д.), но при этом свойство Id находится в базовом классе сущности, то с помощью этой аннотации мы можем переопределить, к какой колонке каждая конкретная сущность должна привязывать свой id. А вот стратегия генерации ключа для всех сущностей одинаковая - она как написана в базовой сущности, так мы ее в потомках и оставляем.

# Как сохранить

Вот грязный пример сохранения актера в БД:

```java
EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
EntityManager manager = factory.createEntityManager();

Actor huck = new Actor();
huck.setFirstName("Tom");
huck.setLastName("Sawyer");

System.out.println("Пытаемся сохранить Тома");
manager.getTransaction().begin();
manager.persist(huck);
manager.getTransaction().commit();
manager.close();
```

Грязный - потому что не понятно, нужна транзакция вообще или нет, а если нужна, то надо ли вот так явно ее начинать\заканчивать или для этого есть специальные средства.

Но по крайней мере все это запускается и работает.