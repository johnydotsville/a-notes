Может быть немного больно.

# Зависимости

Нужна зависимость хибера и конкретного провайдера. Мне хватило вот таких:

```xml
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.1.0.Final</version>
</dependency>
```

```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.3.6</version>
</dependency>
```

# Два стиля конфигурирования

Хибер можно использовать как самостоятельную технологию, а можно как реализацию JPA. При этом как минимум отличается способ конфигурирования.

## Hibernate-стиль

Конфигурация кладется в папку resources/META-INF/hibernate.cfg.xml

Конкретно этот стиль я пока не использовал, не буду про него ничего писать.

## JPA-стиль

Конфигурация кладется в папку resources/META-INF/persistence.xml

```xml
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
             version="3.0">
    <persistence-unit name="dvdrental-pu">
        <description>JPA s ru4koi</description>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <properties>
            <property name="jakarta.persistence.jdbc.driver" value="org.postgresql.Driver" />
            <property name="jakarta.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/dvdrental" />
            <property name="jakarta.persistence.jdbc.user" value="postgres" />
            <property name="jakarta.persistence.jdbc.password" value="j123" />

            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
        </properties>
    </persistence-unit>
</persistence>
```

Собственно все понятно и так, это минимальная конфигурация.

Здесь явно написаны данные для подключения к БД, но еще их можно вынести в какой-то отдельный то ли файл, то ли что, я не знаю, при этом задействуется JNDI, а я совсем не понял, что это такое.

Кроме того, в некоторых примерах тут же написаны классы, которые участвуют в хранении, и была настройка, чтобы убрать автоматическое сканирование классов. Но у меня явное перечисление классов вызвало только проблемы. Я удалил весь этот треш и начало хоть как-то работать.

*Persistense Unit* - трудно сказать, *что* это такое. С виду это раздел в файле persistence.xml. Имеет ли он еще какие-то инкарнации, я не знаю. Но понятно, *для чего* он нужен - информация из него используется для создания EntityManager. Самое смешное, что, блять, что такое EntityManager, ты узнаешь только сильно впереди.

# Объявление сущности

Здесь на примере класса и подкласса покажу как я сохранил в БД актера. Особенность в том, что поля, которые должны сохраняться в одну таблицу, тут размазаны по двум классам: базовая абстрактная сущность имеет id, а имя и фамилия - в классе актера.

Кроме того, есть такие особенности:

* Не все поля потребуется сохранять - некоторые надо игнорировать
* Поле Id в разных таблицах называется по-разному

Базовая сущность: в ней мы зададим поле идентификатора, укажем стратегию генерации идентификатора, но не будем указывать, на какой столбец таблицы это поле должно проецироваться, т.к. у каждой конкретной сущности есть своя таблица и там id-поле называется по-разному:

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Transient;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;

@MappedSuperclass
public abstract class AbstractEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Transient
    private LocalDate createdAt;
    @Transient
    private LocalDate modifiedAt;

    public AbstractEntity() {
        createdAt = LocalDate.now();
        modifiedAt = LocalDate.now();
    }
    ...
}
```

Класс актера:

```java
import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Entity;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import javax.validation.constraints.Size;

@Entity
@Table(name = "actor")
@AttributeOverride(name = "id", column = @Column(name = "actor_id"))
public class Actor extends AbstractEntity {
    @Column(name = "first_name", length = 45)
    @Size(min = 2, max = 45)
    private String firstName;
    @Column(name = "last_name", length = 45)
    @Size(min = 2, max = 45)
    private String lastName;

    public Actor() {
        super();
    }
    ...
}
```

# Объяснения

* @Entity - с помощью этой аннотации мы сообщаем, что класс участвует в хранении.

* @Id - каждая сущность, сохраняемая в БД, обязана иметь идентификатор. Обычно это суррогатный ключ, который генерирует или приложение, или СУБД.

  После сохранения объекта, в свойстве id появляется идентификатор, который сгенерировала БД. Ничего дополнительно для этого делать не надо.

* @GeneratedValue - для генерации этого суррогатного ключа есть несколько стратегий. На момент написания я детально в них не разбирался. Знаю, что можно использовать отдельные созданные в БД последовательности, но в моем случае заработал обычный автоинкремент.

  UPD. Заработал он только благодаря тому, что в БД была создана последовательность для генерации. Как хибер ее отыскал, я не знаю. В этом буду разбираться потом.

  UPD2. Identity вообще не понятно почему работает. Теоретически, оно должно работать, если таблица создана с identity-столбцом. Но эти таблицы все созданы без него - id можно в них вставлять руками. Так что самый логичный способ, который я пока вижу, - это руками создавать sequence'ы и назначать их явно через аннотации.

* @Table - с помощью этой аннотации явно задаем, с какой таблицей мы сопоставляем сущность.

* @Column - через эту аннотацию можно задать несколько параметров. В данном случае я использовал два: к какому столбцу мы хотим привязать поле и какой максимальный размер поля. Причем максимальный размер в данном случае не выполняет валидацию в том смысле, что он просто даст ошибку при попытке сохранить что-то длинное, но в самом процессе валидации не участвует.

* @Size - валидирующая аннотация. Вот она как раз заполнит ошибки валидации при валидировании объекта.

Комбинация @MappedSuperclass, @Transient и @AttributeOverride:

* @MappedSuperclass

  При наследовании поля суперкласса не подлежат сохранению. Да и вообще для суперкласса не положено иметь отдельную таблицу. Но поскольку мы конечно хотим сохранять поле Id для каждой сущности-наследника, то должны аннотировать родителя @MappedSuperclass - т.о. хибер поймет, что поля родителя участвуют в хранении.

* @Transient - позволяет игнорировать поле при сохранении. Поскольку на момент написания у меня в БД было поле last_update и СУБД заполняла его автоматически, а поля под дату создания вообще нигде не было, но при этом поля в классах хотелось сохранить, т.к. их идея мне нравится, то я просто поставил их игнорирование. Двойная польза.

* @AttributeOverride - поскольку у каждой таблицы под сущности в БД поле идентификатора называется по-разному (actor_id, country_id и т.д.), но при этом свойство Id находится в базовом классе сущности, то с помощью этой аннотации мы можем переопределить, к какой колонке каждая конкретная сущность должна привязывать свой id. А вот стратегия генерации ключа для всех сущностей одинаковая - она как написана в базовой сущности, так мы ее в потомках и оставляем.

# UPD: базовая сущность

В итоге пока что делаю вывод, что размещать id в базовой сущности - это плохо. Потому что, во-первых, приходится в каждой сущности переопределять столбец, с которым этот id сопоставляется. А, во-вторых, похоже, если захочется переопределить стратегию генерации id, то сделать это будет непросто. Через @AttributeOverride, похоже, это вообще не делается, а делается через файл orm.xml и у меня не заработало.

В общем, из базовой сущности id убираем и, например, id в Actor получается такой:

```java
@Entity
@Table(name = "actor")
public class Actor extends AbstractEntity {
    @Id
    @Column(name = "actor_id")
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "actor_id_gen")
    @SequenceGenerator(name = "actor_id_gen", sequenceName = "actor_actor_id_seq", allocationSize = 1)
    private Long id;
```

* @SequenceGenerator
  * name - имя генератора для обращения внутри java-программы
  * sequenceName - имя последовательности на стороне СУБД
  * allocationSize - там что-то про резервирование, но на практике, похоже, это просто приращение. Даже если оно указано на стороне СУБД, здесь тоже надо указывать почему-то, иначе ошибка
* @GeneratedValue
  * strategy - на этот раз указываем явно, что надо использовать последовательность
  * generator - ссылаемся на последовательность, описанную через @SequenceGenerator, по имени внутри java-программы

# Как сохранить

Чел, никогда не забывай в куски вставлять импорты... Все эти классы могут быть в разных пакетах, хз поймешь, из какого.

Вот грязный пример сохранения актера в БД:

```java
EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
EntityManager manager = factory.createEntityManager();

Actor huck = new Actor();
huck.setFirstName("Tom");
huck.setLastName("Sawyer");

System.out.println("Пытаемся сохранить Тома");
manager.getTransaction().begin();
manager.persist(huck);
manager.getTransaction().commit();
manager.close();
```

Грязный - потому что не понятно, нужна транзакция вообще или нет, а если нужна, то надо ли вот так явно ее начинать\заканчивать или для этого есть специальные средства.

Но по крайней мере все это запускается и работает.

Вот еще пример. Тоже грязь, но показывает, что нужно выполнять работу внутри try и откатывать транзакцию в случае ошибок:

```java
Actor actor = new Actor();
actor.setName(new Name("Tom", "Sawyer"));

EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
EntityManager manager = factory.createEntityManager();
EntityTransaction tr = manager.getTransaction();
try {
    tr.begin();
    manager.persist(actor);
    actor.setName(new Name("Huck", "Finn"));
    tr.commit();
} catch (Exception ex) {
    System.out.println("Откат транзакции");
    tr.rollback();
} finally {
    if (manager != null && manager.isOpen()) {
        manager.close();
    }
}
```

Поскольку это грязь, тут создается и factory, но вообще она должна создаваться где-то гораздо выше и быть единственной на все время работы приложения. manager может создаваться чаще, например, на каждый веб-запрос. В каком-то локальном приложении я не знаю как правильно его создавать.

# Дополнительно

## Способ доступа к свойствам

Хибер может обращаться к полям класса двумя способами:

* Прямой (через рефлексию, еще называется field-access)
* Через геттеры\сеттеры (еще называется property-access)

То, как он это будет делать, определяется положением аннотации @Id:

* Если она над полем, то используется прямой доступ
* Если она над геттером, то для доступа к полю используются геттеры\сеттеры (над сеттером аннотации никогда не ставятся)

Кроме того, есть возможность с помощью аннотации `@Access` явно указать, какой способ нужно использовать. Синтаксис:

```java
import jakarta.persistence.Access;
import jakarta.persistence.AccessType;

@Access(AccessType.FIELD | PROPERTY)
```

Аннотацию можно применить к классу, тогда правило распространится на все свойства, а можно к конкретному свойству. Если она на уровне класса, тогда все остальные аннотации, вроде @Id, @Column и т.д. должны располагаться соответствующим образом, т.е. если в @Access задали .FIELD, все аннотации располагаем над полями.

Стратегия доступа распространяется на родителя сущности и на embeddable-классы.

Преимущества прямого доступа:

* Выглядит симпатичнее

* Прямой доступ позволяет избежать создания геттеров\сеттеров, если они нам вообще-то в программе и не нужны вовсе (например, какое-нибудь поле мы хотим сделать только для чтения, соответственно, сеттер бы только мешал, но был бы необходим хиберу в случае использования AccessType.Property)

* Если использовать property-access, тогда хибер наложил бы на геттеры\сеттеры дополнительные ограничения. Например, хибер не знает ничего про тип Optional и написать геттер вот так было бы невозможно:

  ```java
  public Optional<Publisher> getPublisher() {
      return Optional<Publisher>.ofNullable(this.publisher);
  }
  ```

  А используя field-access мы можем реализовывать геттеры\сеттеры как хотим.

* Класс может содержать не только геттеры и сеттеры, но и другие методы, например бизнес-логику или просто какие-то утилитарные вещи. В случае использования property-access нам бы пришлось все эти методы помечать аннотацией @Transient, чтобы хибер их игнорировал.

* property-access потенциально создает проблемы при использовании ленивой загрузки. Ленивая загрузка предполагает, что данные подгружаются только в момент обращения к ним. Значит, если мы используем property-access стратегию, то они будут подгружаться только если мы обратимся к геттеру. А если обратимся просто к полю, то они не подгрузятся и это может создать проблемы.

  Например в методах equals и hashCode обычно мы обращаемся напрямую к полям, а не через геттеры\сеттеры, т.к. поля доступны нам напрямую внутри класса. Соответственно, эти поля запросто могут оказаться пустыми в случае ленивой загрузки.

## Встроенные классы

Встроенные (embeddable) классы используются, когда, например, два Java-класса хранятся в БД в одной таблице. Обычно это речь про Value-Object'ы. Например, адрес, имя - все это можно представить отдельным объектом на стороне ООП, но при этом бывает нет смысла хранить это в отдельной таблице. На примере сущности актера и его имени:

```java
@Embeddable  // <-- Основное
public class Name {
    @Column(name = "first_name", nullable = false)
    private String firstName;
    @Column(name = "last_name", nullable = false)
    private String lastName;

    protected Name() {
    }

    public Name(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() ...
    public void setFirstName(String firstName) ...
    public String getLastName() ...
    public void setLastName(String lastName) ...

    @Override
    public boolean equals(Object o) {
        Name name = (Name) o;
        return Objects.equals(firstName, name.firstName) && Objects.equals(lastName, name.lastName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(firstName, lastName);
    }
}
```

```java
@Entity
@Table(name = "actor")
@AttributeOverride(name = "id", column = @Column(name = "actor_id"))
public class Actor extends AbstractEntity {
    private Name name;  // <-- Всего-то объявляем поле типа embedded-класса

    public Actor() {
        super();
    }

    public Name getName() {
        return name;
    }

    public void setName(Name name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object that) {
        if (!super.equals(that)) return false;

        Actor actor = (Actor) that;
        return Objects.equals(name, actor.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), name);
    }
}
```

```java
Actor actor = new Actor();
actor.setName(new Name(firstName, lastName));

System.out.println("Пытаемся сохранить актера");
manager.getTransaction().begin();
manager.persist(actor);
manager.getTransaction().commit();
...
Actor actor = manager.find(Actor.class, actorId);
System.out.println(String.format("%s %s", actor.getName().getFirstName(), actor.getName().getLastName()));
```

* Встроенный класс отмечаем аннотацией @Embeddable, поля мапим как обычно через @Column, при этом таблица задается в "содержащем" классе и для пользования встроенным классом надо всего лишь объявить поле этого типа, дальше все происходит автоматически.
* Встроенный класс существует столько же, сколько и содержащий, не имеет собственного id и в общем не является самостоятельным.
* Важно переопределить методы equals и hashCode у встроенного класса.
* Можно делать встроенные классы во встроенных классах и т.д. Степень вложения не ограничена.
* Если у встроенного объекта поля равны null и мы его сохраняем, то если БД допускает null в соответствующих столбцах, хибер сохранит объект нормально. Но при загрузке встроенного объекта, если в полях БД лежат null'ы, хибер не создаст объект, а вернет null. На примере имени актера: можно сохранить актера, у которого в Name поля имени и фамилии равны null, но если мы попробуем потом загрузить этого актера, то объект Name создан не будет, хибер вернет вместо него null. Т.е. имеется ввиду, что вместо объекта Name с полями имя, фамилия == null, мы получим null вместо самого объекта Name.

## БД-генерация значений

При сохранении объектов некоторые поля может генерировать БД. Например, время создания\последнего изменения объекта. Id сюда не относится, это отдельная тема. Чтобы поместить эти "автозначения" сразу в сохраняемый объект, а не тащить их как-то отдельно, делаем вот так:

```java
import jakarta.persistence.Column;
import jakarta.persistence.Temporal;

@MappedSuperclass
public abstract class AbstractEntity {
    @Column(name = "last_update", insertable = true, updatable = true)  // 1
    @Temporal(TemporalType.TIMESTAMP)  // 2
    @org.hibernate.annotations.Generated(  // 3
            value = org.hibernate.annotations.GenerationTime.ALWAYS)  // .INSERT, .NEVER
    private LocalDateTime modifiedAt;
```

Здесь у нас базовый класс сущности, который сам по себе не сохраняется, но содержит общие поля, которые есть у всех сущностей. Среди них - как раз дата последней модификации.

### 3 

@Generated - когда используем аннотации хибера, рекомендуют писать полностью вместе с пакетом. Этой аннотацией помечаем автогенерируемое свойство. С помощью параметра *value* задаем, при каких операциях хибер должен выполнять запрос для получения из БД этого свойства. При значении ALWAYS хибер будет вытягивать сгенерированное значение при выполнении и insert-операций, и update-операций.

### 1

@Column - помимо мапинга на столбец БД, указываем при каких операциях хибер должен исключать из запроса этот столбец, т.к. если столбец формируется автоматически базой, мы не должны передавать значение для него в операциях вставки и обновления. В данном случае мы говорим с помощью *insertable = true, updatable = true*, что хибер должен *исключать* столбец last_update в запросе и при вставках, и при обновлениях.

UPD. Што? А не наоборот? Логичнее что insertable = false значит, что вставлять в проге не надо, БД сама вставит, нет разве?

### 2

@Temporal - возможные значения TIMESTAMP, DATE, TIME. Этой аннотацией нужно обязательно помечать автосвойства, у которых тип - разновидность времени, чтобы хибер корректно заполнял их. По значениям и так понятно что для чего. У нас тип LocalDateTime, т.е. дата со временем, значит и в Temporal указываем дату со временем.