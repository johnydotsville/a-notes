# EntityManager

EntityManager - основной интерфейс в JPA для обращения с данными.

EntityManager еще называют "контекстом". Его получают с помощью фабрики, имеющий интерфейс EntityManagerFactory. EMF - это по сути одна логическая база данных или как еще говорят "единица хранения" (persistence unit). Фабрика создается на основе настроек, лежащих в указанном persistence-unit'е:

```java
import jakarta.persistence.Persistence;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.EntityManager;

EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
manager = factory.createEntityManager();
```

Создание фабрики - тяжелый процесс, поэтому фабрику создают единожды на старте программы, а контекст можно вполне создавать почаще, например, для каждого веб-запроса. Хотя зависит конечно от обстоятельств. Например, в спринге EM напрямую недоступен и кто знает, как с ним там внутри организована работа.

Когда объект сохранен\выбран в\из БД, он помещается в контекст. И перед следующей выборкой хибер всегда сначала смотрит контекст, нет ли в нем объекта, который мы пытаемся найти. Если есть, то повторного обращения к БД не происходит. Изменить эту механику нельзя:

```java
Actor actor = manager.find(Actor.class, 224);  // select ...
Actor actor2 = manager.find(Actor.class, 224);  // Не будет повторного select
```

> По-хорошему, наверное нужно все операции проводить внутри try-catch, но я буду и писать без них, чтобы не раздувать примеры.

Контест реализует паттерн Unit of Work и отслеживает все происходящие с *хранимым* объектом изменения, а потом формирует запросы, которые эти изменения отражают в БД.

Контекст работает с пулом соединений и не извлекает соединение из пула до тех пор, пока не надо выполнить запрос.

# Состояние объекта

В хибере есть 4 состояния, в которых может находиться объект:

* Временное

  Это новый объект, который мы еще не сохранили и контекст о нем ничего не знает.

* Хранимое (persist)

  Это сохраненный объект и за изменениями в нем наблюдает контекст. Сохранение выполняется методом persist(). Это и правда сохранение - после вызова этой команды выполняется sql insert. Последующие изменения объекта приведут к выполнению sql update.

  ```java
  Actor actor = new Actor();
  actor.setName(new Name("Tom", "Sawyer"));
  manager.getTransaction().begin();
  manager.persist(actor);  // insert
  actor.setName(new Name("Huck", "Finn"));  // update
  manager.getTransaction().commit();
  ```

* Отсоединенное (detach)

* Удаленное



