# Сохранение

Вот демонстрация того, что происходит при сохранении объекта:

```java
Actor actor = new Actor();
actor.setName(new Name("Tom", "Sawyer"));
manager.getTransaction().begin();
manager.persist(actor);  // select nextval('actor_actor_id_seq')
actor.setName(new Name("Huck", "Finn"));
manager.getTransaction().commit();
// insert into actor (first_name, last_name, actor_id) values (?, ?, ?)
// select a1_0.last_update from actor a1_0 where a1_0.actor_id=?
// update actor set first_name=?, last_name=? where actor_id=?
// select a1_0.last_update from actor a1_0 where a1_0.actor_id=?
```

> Действия конечно зависят от мэппинга и если такого поля last_update нет или для него не указано, что оно БД-генерируемое, то и запросов таких не будет, но тем не менее. 

id для таблицы актеров генерируется последовательностью. В момент вызова persist хибер запрашивает у БД id для нового актера, а все остальные операции производятся только при вызове commit. Причем как видно, persist приводит к выполнению insert + select (потому что поле last_update автоматически заполняется на стороне БД и хибер должен его выбрать, чтобы дополнить объект), а следующее изменение имени приводит к выполнению update + select.

# Простая транзакция

Вот еще пример. Тоже грязь, но показывает, что нужно выполнять работу внутри try и откатывать транзакцию в случае ошибок:

```java
Actor actor = new Actor();
actor.setName(new Name("Tom", "Sawyer"));

EntityManagerFactory factory = Persistence.createEntityManagerFactory("dvdrental-pu");
EntityManager manager = factory.createEntityManager();
EntityTransaction tr = manager.getTransaction();  // <--
try {
    tr.begin();
    manager.persist(actor);
    actor.setName(new Name("Huck", "Finn"));
    tr.commit();
} catch (Exception ex) {
    System.out.println("Откат транзакции");
    tr.rollback();
} finally {
    if (manager != null && manager.isOpen()) {
        manager.close();
    }
}
```



# Вопросы

* Что такое текущая системная транзакция?

* EntityManager.flush() - для чего?

* EntityTransaction и UserTransaction

  Из того, что удалось примерно понять (но это не точно): есть два варианта: либо у нас транзакция выполняются в рамках одной БД ("обычная" транзакция, так назову), либо транзакция может затрагивать несколько БД (распределенная транзакция). Так вот, чтобы работать с распределенными транзакциями, используется интерфейс UserTransaction из JTA (Java Transaction API), а чтобы с обычными - интерфейс EntityTransaction из JPA.
