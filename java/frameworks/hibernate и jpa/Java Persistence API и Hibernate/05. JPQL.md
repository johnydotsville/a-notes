# JPQL и HQL

И то, и другое - sql'еподобный язык для оформления запросов в сущностям. HQL - это хиберовская версия, а JPQL - стандартизированная. Отношения между ними такие же как между хибером и JPA - в HQL побольше функционала.

Полезные ссылки:

```
https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/chapters/query/hql/HQL.html
```

# Обычные запросы

Главное помнить, что jpql-запросы создаются к *сущностям*, а не к таблицам БД, поэтому и думать надо при составлении запросов, отталкиваясь именно от сущностей.

Запросы создаются на EntityManager'е. Запросы можно писать либо **непосредственно** в методе создания запроса:

```java
import jakarta.persistence.TypedQuery;

TypedQuery<Country> tquery = manager.createQuery(
    "select c from Country c " +
    "where name like :name", Country.class
);
tquery.setParameter("name", name + "%");  // <-- Задаем параметры для запроса
List<Country> countries = tquery.getResultList();  // Когда ожидаем несколько строк
```

Либо использовать т.н. **именованные запросы**, named query:

```java
import jakarta.persistence.TypedQuery;

TypedQuery<Country> tquery = manager
    .createNamedQuery("GET_COUNTRY_BY_EXACT_NAME", Country.class)  // <-- Имя именованного запроса вместо текста
    .setParameter("name", searchName);
Country country = tquery.getSingleResult();  // Когда ожидаем только одну строку (иначе исключение)

// Еще есть .getResultStream();
```

Вместо *TypedQuery* можно использовать *Query*, например, когда запрос не возвращает никакого типа (например, при update):

```java
public void updateNamedQuery(String name, String newName) {
    manager.getTransaction().begin();
    Query tq = manager
        .createNamedQuery("UPDATE_COUNTRY")
        .setParameter("name", name)
        .setParameter("newName", newName);
    int updated = tq.executeUpdate();
    manager.getTransaction().commit();
    System.out.println("Обновлено записей: " + updated);
}
```

# Именованные запросы

Можно объявлять их через аннотацию *@NamedQuery*, но мне такой способ не нравится, т.к. еще больше захламляет классы. Так что я опишу только способ через xml, который посмотрел у броадлифов.

Создаем файл в resources/named-queries/Country.orm.xml (непосредственно папка с запросами может иметь любое имя, главное класть ее в ресурсы. orm в названии тоже не обязательно, но так понятнее, что файл связан с orm темой):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_2_0.xsd" version="2.0">

    <named-query name="GET_COUNTRY_BY_EXACT_NAME" >
        <query>select c from johny.dotsville.domain.entities.Country c
            where c.name = :name</query>
    </named-query>
    
    <named-query name="UPDATE_COUNTRY" >
        <query>update johny.dotsville.domain.entities.Country c
            set c.name = :newName
            where c.name = :name</query>
    </named-query>

    <named-query name="GET_COUNTRY_BY_LIKE_NAME" >
        <query>select c from johny.dotsville.domain.entities.Country c
            where c.name like :name</query>
    </named-query>

</entity-mappings>
```

И указываем этот файл в resources/META-INF/persistence.xml

```xml
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
             version="3.0">
    <persistence-unit name="dvdrental-pu">
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <mapping-file>named-queries/Country.orm.xml</mapping-file>  <!-- Туть -->

        <properties>
            <property name="jakarta.persistence.jdbc.driver" value="org.postgresql.Driver" />
            <property name="jakarta.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/dvdrental" />
            <property name="jakarta.persistence.jdbc.user" value="postgres" />
            <property name="jakarta.persistence.jdbc.password" value="j123" />

            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
        </properties>
    </persistence-unit>
</persistence>
```

Расположение mapping-file важно - если поместить его до провайдера или после свойств, будет ошибка.

# Выбор одного столбца

Если вдруг нужно выбрать не весь объект, а только один столбец:

```xml
select fa.id.filmId from johny.dotsville.domain.entities.FilmActor fa
where fa.id.actorId = :actorId
```

```java
public void getActorsFilms(long actorId) {
    TypedQuery<Long> tqry = manager
        .createNamedQuery("get_actor_genres", Long.class)
        .setParameter("actorId", actorId);
    List<Long> fa = tqry.getResultList();
    int filmsCount = 1;
    for (Long item : fa) {
        System.out.println(String.format("Фильм #%d: %d", filmsCount, item));
        filmsCount++;
    }
}
```

# inner join

Делается немного нетипично - при соединении указывается не вторая сущность, а поле первой сущности, указывающее на вторую сущность, а on вообще не нужен (команда on есть, но используется, с виду, как where, поэтому не пишу ее сюда):

```xml
<named-query name="get_country_cities">
    <query>
        select ct City
        from johny.dotsville.domain.entities.City ct
            inner join ct.country cr  <!-- Здесь имя поля, а не класса -->
        where cr.name = :name
    </query>
</named-query>
```

```java
public class City {
    ...
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)
    @JoinColumn(name = "country_id", nullable = false)
    private Country country;
    ...
}
```

## Соединение нескольких сущностей

Задача "Выбрать все жанры, в которых снимался заданный актер":

```xml
<named-query name="get_actor_genres" >
    <query>
        select fc.category from johny.dotsville.domain.entities.FilmCategory fc
        inner join fc.film f
        inner join f.filmActor fa
        where fa.id.actorId = :actorId
        order by fc.category.name
    </query>
</named-query>
```

```java
public void printActorsGenres(long actorId) {
    TypedQuery<Category> tqry = manager
        .createNamedQuery("get_actor_genres", Category.class)
        .setParameter("actorId", actorId);
    List<Category> categories = tqry.getResultList();
    for (Category cat : categories) {
        System.out.println(cat.getName());
    }
}
```

Cуть такова, что мэпинг у нас уже есть - в сущностях, и там уже указано, по каким полям БД они друг с другом соединяются. Поэтому в inner join мы просто указываем *поле* одной сущности, которое содержит объект (или коллекцию объектов) второй сущности, с которой мы хотим соединиться. Фрагменты классов для наглядности:

```java
public class FilmCategory {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", insertable = false, updatable = false)
    private Category category;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "film_id", insertable = false, updatable = false)
    private Film film;
...
public class Film {
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "film")
    private Set<FilmActor> filmActor = new HashSet<>();
...
public class FilmActor {
    @EmbeddedId
    private Id id = new Id();
    ...
    @Setter @Getter
    public static class Id implements Serializable {
        @Column(name = "actor_id")
        private long actorId;
```

# Нативные запросы

Если запрос не удается написать на jpql, можно отправить в БД обычный sql-код. Это называется *нативные запросы*. Их тоже можно оформлять разными способами, но мне понравилось через xml. В них уже используем полноценные поля таблиц и названия таблиц, как если бы писали запрос просто в sql-редакторе. Т.е. если у нас есть сущность ClientCurrentStatus и в БД ей соответствует таблица client_current_status, то в нативном запросе мы должны писать именно client_current_status.

На выполнение они вызываются методом manager.create**Named**Query, а не .createNativeQuery.

## "Сырые" запросы

Это когда не указывается возвращаемый тип. Можно выбрать какие угодно поля, а потом руками сделать с ними что нужно:

```xml
<!-- Фильм, который не брали в аренду ни разу -->
<named-native-query name="get_no_rental_films_raw">
    <query>
        select f.film_id, f.title
        from Film f
            inner join inventory i
                on f.film_id = i.film_id
            left join rental r
                on i.inventory_id = r.inventory_id
        where r.rental_id is null
    </query>
</named-native-query>
```

```java
public void noRentalFilmsNativeQueryRaw() {
    Query qry = manager
        .createNamedQuery("get_no_rental_films_raw");
    List<Object[]> result = qry.getResultList();
    for (Object[] info : result) {
        System.out.println(info[0] + " " + info[1]);
    }
}
```

## Типизированные

Указываем тип и из результирующих полей  нужный объект формируется автоматически:

```xml
<!-- Фильм, который не брали в аренду ни разу -->
<named-native-query name="get_no_rental_films_typed" 
                    result-class="johny.dotsville.domain.entities.Film">  <!-- Указываем тип результата (пакет обязателен) -->
    <query>
        select f.*
        from Film f
            inner join inventory i
                on f.film_id = i.film_id
            left join rental r
                on i.inventory_id = r.inventory_id
        where r.rental_id is null
    </query>
</named-native-query>
```

```java
public void noRentalFilmsNativeQueryTyped() {
    Query qry = manager
            .createNamedQuery("get_no_rental_films_typed");
    List<Film> films = qry.getResultList();
    for (Film film : films) {
        System.out.println(film.getTitle());
    }
}
```

## Параметры для запроса

Можно выставлять параметры. JPA поддерживает вроде только позиционные, но хибер умеет в именованные:

```xml
<!-- Все жанры, в которых актер НЕ снимался -->
<named-native-query name="get_actor_skipped_genres"
                    result-class="johny.dotsville.domain.entities.Category">
    <query>
        select cat.*
        from category cat
        where cat.category_id not in
        (
            select distinct fc.category_id
            from actor ac
                inner join film_actor fa
                    on ac.actor_id = fa.actor_id
                inner join film_category fc
                    on fa.film_id = fc.film_id
            where ac.actor_id = :actorId  <!-- Стильно, модно, молодежно -->
        )
    </query>
</named-native-query>
```

```java
public void actorSkippedGenres(long actorId) {
    Query qry = manager
            .createNamedQuery("get_actor_skipped_genres")
            .setParameter("actorId", actorId);
    List<Category> categories = qry.getResultList();
    for (Category cat : categories) {
        System.out.println(cat.getName());
    }
}
```

## Когда несколько schema

Если у нас таблицы лежат не в дефолтной схеме, тогда мы можем либо явно писать схему в запросах перед именем таблицы (например, ... from bl.client_current_status), либо переназначить дефолтную схему.

Для этого понадобится две вещи:

* В persistence.xml в разделе properties указать имя нужной схемы:

  ```xml
  <properties>
      ...
      <property name="hibernate.default_schema" value="bl"/>
      ...
  </properties>
  ```

* В запросах писать {h-schema} перед именами таблиц:

  ```xml
  select ccs.*
  from {h-schema}client_current_status ccs
  where ccs.client_id = :clientId
  ```

  



## Сложный мэппинг

Результат нативных запросов можно мэпить как угодно, для этого есть специальные средства. Сейчас оно мне пока не надо, но вот тут можно почитать, когда понадобится https://thorben-janssen.com/jpa-native-queries/ в разделе "Use JPA’s *@SqlResultSetMapping*"

# Hints

Хинты - это особые параметры, которые можно добавить к запросу, чтобы провайдер выполнил запрос как-то по-особенному. Выглядит как тема, раскрывающаяся исключительно на практическом примере, поэтому просто напишу как добавить хинт, а зачем каждый конкретный нужен - потом разберусь:

```java
import org.hibernate.jpa.QueryHints;
import org.hibernate.CacheMode;

public void implicitHintSetting(String searchName) {
    TypedQuery<Country> tquery = manager
        .createNamedQuery("GET_COUNTRY_BY_EXACT_NAME", Country.class)
        .setHint("org.hibernate.readOnly", true)
        // .setHint("org.hibernate.cacheable", true)
        .setHint(QueryHints.HINT_CACHEABLE, true)
        // .setHint(QueryHints.HINT_CACHE_MODE, CacheMode.GET)
        .setHint("org.hibernate.cacheMode", CacheMode.GET)
        .setParameter("name", searchName);
    Country country = tquery.getSingleResult();
    System.out.println(country.getName());
}
```

Это не единственный способ задать их, но именно так делали в броадлифе, а я на них ориентируюсь.

Из интересного, в этом примере видно, что можно использовать непосредственно имя хинта, а можно пользоваться enum'ом. Но енумы объявлены как депрекейтед.

Некоторых хинтов, которые есть у хибера, может не быть в jpa.







# Черновик



# Неизвестные вещи

```JAVA
.setFlushMode( FlushModeType.COMMIT ); на объекте query
@SqlResultSetMapping(name="updateResult", columns = { @ColumnResult(name = "count")})
@NamedNativeQuery
```