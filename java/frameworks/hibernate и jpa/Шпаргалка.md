```java
jakarta.persistence
    @MappedSuperclass
    @Column(name = "last_update", insertable = true, updatable = true)
    @Entity
    @Table(name = "actor")
    @Id
    
    @OneToOne(cascade = CascadeType.PERSIST, fetch = FetchType.LAZY)
    @JoinColumn(name = "country_id", nullable = false)
    
    
    
    c Persistence
        .createEntityManagerFactory("dvdrentalPU") : i EntityManagerFactory
    i EntityManagerFactory
        .createEntityManager() : i EntityManager
    i EntityManager
        .find(Actor.class, id) : <T>
        .getTransaction() : i EntityTransaction
    
    i EntityTransaction
        .begin()
        .commit()
        .rollback()
 
```

```java
jakarta.persistence.spi
    i PersistenceProviderResolver
        .getPersistenceProviders()
```



# Фрагменты

* Поле (не идентификатор), заполняемое автоматически на стороне БД

```java
import jakarta.persistence.Column;
import jakarta.persistence.Temporal;
import jakarta.persistence.TemporalType;
import org.hibernate.annotations.Generated;
import org.hibernate.annotations.GenerationTime;

@Column(name = "last_update", insertable = true, updatable = true)
@Temporal(TemporalType.TIMESTAMP)
@org.hibernate.annotations.Generated(
    value = org.hibernate.annotations.GenerationTime.ALWAYS)
private LocalDateTime lastUpdate;

enum GenerationTime { 
    ALWAYS,
    INSERT,
    NEVER
}

enum TemporalType {
    TIMESTAMP,
    DATE,
    TIME
}
```

* Генерация id на стороне БД с помощью sequence

```java
@Entity
@Table(name = "actor")
public class Actor extends AbstractEntity {
    @Id
    @SequenceGenerator(name = "actor_id_gen", sequenceName = "actor_actor_id_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "actor_id_gen")
    private Long id;
    
enum GenerationType { 
    SEQUENCE,
    AUTO,
    IDENTITY,
    TABLE,
    UUID
}
```

* Составной ключ (в промежуточной таблице при связи ММ)