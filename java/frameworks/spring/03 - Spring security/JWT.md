# Структура JWT

JWT (Json Web Token) выглядит примерно так:

```java
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.jf2KO8euMPShHr7cmEKjMhsroHxbFMC2br3DhreOeKM
// Сгенерировано на https://jwt.io/
```

В нем три элемента, разделенных точками:

* Header
* Payload (нагрузка)
* Signature (подпись)

Хедер и нагрузка - это строки в формате JSON, *закодированные* через Base64. Base64 использует для кодирования любой информации набор из 64 символов - латинские буквы, цифры и два дополнительных символа. Так что даже "странные" символы в итоге превращаются во вполне съедобные ([онлайн](https://base64-encode.online/)).

*Кодировка* - это не *шифрование*. Кодировка подразумевает просто перевод информации из одного вида в другой. Соответственно, закодированную инфу можно легко раскодировать обратно. Например, раскодированный хедер из этого токена выглядит так:

```java
// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
{"alg":"HS256","typ":"JWT"}
```

А вот нагрузка:

```java
// eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
{"sub":"1234567890","name":"John Doe","iat":1516239022}
```

Подпись формируется следующим образом:

* Закодированный хедер и закодированная нагрузка конкатенируются, разделитель - точка `.`

* Полученная строка хэшируется алгоритмом, указанным в хедере. Хэшируется не просто, а с использованием секрета - строки, которая известна только сервису, выдающему токены, и сервисам, которые токенами пользуются (TODO: ??? уточнить потом, так ли это)

  В данном примере для шифровки использовался секрет QeShVmYq3t6w9z$C&F)J@NcRfUjWnZr4 (сгенерирован был [тут](https://allkeysgenerator.com/Random/Security-Encryption-Key-Generator.aspx))

# Механика работы токенов

## Access и Refresh токены

TODO: ??? отредактировать этот раздел, когда точнее узнаю что к чему.

В механизме авторизации через токены обычно используется два вида токенов:

* access token

  Многоразовый, живет мало (от нескольких минут до нескольких дней). Используется непосредственно для получения *доступа* к защищенным ресурсам.

* refresh token

  Одноразовый, живет долго (например, неделю, месяц), должен надежно храниться. Используется для получения новой пары access token + refresh token ("обновления" AT).

Пользователь отправляет запрос со своим логином и паролем сервису аутентификации. Тот генерирует два токена - AT и RT. AT отправляет клиенту, а RT например сохраняет у себя (возможны детали, но об этом не сейчас). Теперь клиент может посылать AT в сервисы с защищенными ресурсами, эти сервисы будут извлекать из AT права пользователя и понимать, можно давать ему доступ или нет. Т.о. AT "многоразовый" - используется при каждом запросе.

Допустим, AT живет 10 минут. Значит после этого времени он приходит в негодность и пользователю нужен новый, а значит надо снова обращаться к сервису аутентификации. В обычной ситуации пользователю снова пришлось бы ввести логин и пароль, но за счет RT (??? вот тут заполнить пробел, как именно за счет RT, где он хранится, как проверяется и т.д.) он может их не вводить, а просто получить новый AT и работать дальше. Т.о. RT "одноразовый" - он используется только после истечения AT для получения новой пары AT + RT.

В случае, если AT будет украден, вор сможет пользоваться им только до тех пор, пока не истечет срок действия AT. Поэтому срок действия AT делают коротким - от нескольких минут до нескольких дней, в зависимости от необходимости баланса между нагрузкой на сервис аутентификации и критичностью безопасности.

Если же и RT украдут, то когда вор воспользуется им и получит новую пару AT + RT, то можно при этом инвалидировать предыдущую пару (как один из вариантов) и тогда легальный пользователь со своими токенами будет вынужден повторно пройти аутентификацию. Соответственно, он снова введет логин \ пароль, получит AT + RT и тогда уже пара вора перестанет работать.



