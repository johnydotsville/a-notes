# Сервлеты, контейнеры сервлетов, фильтры

## Исходники

[Исходники спецификации сервлетов](https://github.com/jakartaee/servlet)

## Сервлеты

*Сервлеты* (Http-сервлет в данном случае), если опустить детали и оставить самую суть, - это объекты, в которые мы можем поместить логику обработки Http-запроса, отдать эти объекты *контейнеру сервлетов* и когда придет запрос, контейнер по url поймет, какой сервлет нужно вызвать для его обработки.

## Контейнер сервлетов

Это программа, которая управляет жизненным циклом сервлетов: создает их, вызывает их методы, создает потоки для обработки поступающих запросов и много чего еще (например, из Http-запроса создает программные объекты запроса и ответа, передает их сервлету; читает конфиг приложения и по нему создает объект контекста). Одним словом, контейнер сервлетов формирует среду, необходимую для работы сервлетов.

Одним из самых популярных контейнеров сервлетов является Tomcat. Контейнер сервлетов и веб-сервер - разные вещи. Запрос, в общих чертах, проходит такой путь:

```
Клиент > Веб-сервер > Контейнер сервлетов > Сервлет > Контейнер сервлетов > Веб сервер > Клиент
```

Т.е. идет от клиента до сервлета и обратно. Контейнер берет на себя заботу о преобразовании этого запроса в объекты удобного вида, чтобы нам было комфортно с ними работать в сервлетах.

> Немного дополнительной информации: есть так называемая Java EE (которая в данный момент переименована в Jakarta EE). Это "спецификация серверной платформы" - набор API, которым должна обладать гипотетическая реализация, чтобы построить супер-пупер-крутое-и-сложное веб-приложение. В эту спецификацию входят много других спецификаций, например, транзакции, валидация, хранение и остальные непонятные технологии (см. википедию). Примером конкретной реализации Java EE является Glassfish - это *сервер приложений* (application server). Т.е. предполагается, что сервер приложений реализует все спецификации.
>
> Среди этой кучи спецификаций, составляющих сервер приложений, есть *спецификация сервлетов* - компонентов, предназначенных для обработки http-запросов. Так вот *контейнером сервлетов* называется программа, которая реализует только спецификацию сервлетов.

## Фильтры

Фильтры - это компоненты, которые предназначены для обработки запроса *до того*, как запрос попадет в сервлет. Также они могут обрабатывать ответ от сервлета до того, как этот ответ уйдет клиенту. Фильтры можно объединять в цепочку и таким образом конфигурировать набор действий, который поможет выполнить дополнительные вещи, вроде аутентификации, логирования и чего угодно. Нет фильтров только "до" или только "после" - запрос проходит каждый фильтр дважды - на пути "туда" и на пути "обратно". А будет ли он что-либо делать с объектом запроса или объектом ответа - уже зависит от программиста.

Фильтры тоже управляются контейнером сервлетов.

# Архитектура

## Общая картина, контекст и конфиг

У нас может быть много сервлетов, вместе формирующих "приложение". У каждого из них могут быть свои *собственные* "параметры", которые не доступны другим сервлетам, а также *общие* "параметры", которые наоборот - доступны всем сервлетам, относящимся к одному приложению. Набор "собственных" называются *конфиг*, а набор "общих" - *контекст*.

И конфиг, и контекст - это *объекты*, которые создает контейнер сервлетов. Контекст создается при старте приложения, а конфиг - при создании сервлета. В зависимости от настроек контейнера, сервлеты могут создаваться либо сразу при старте приложения, либо при первом реальном обращении к сервлету. В любом случае, при создании сервлета контейнер сначала создает конфиг, помещает в него ссылку на контекст и отдает сервлету его конфиг через метод инициализации, который есть в интерфейсе сервлета. Таким образом сервлет получает доступ к контексту через свой конфиг.

Конфиг по своей природе неизменяемый и служит только для начальной инициализации сервлета. А вот контекст изменяться может.

![servlet-config-context-together.drawio](img/servlet-config-context-together.drawio.svg)

Когда клиент посылает http-запрос на веб-сервер, то он передает его контейнеру сервлетов. Контейнер на основе этого "сырого" запроса создает *объект запроса со стандартным интерфейсом*, а также объект ответа, которые будут понятны сервлетам. Таким образом, для каждого пришедшего http-запроса формируются свои собственные объекты запроса и ответа. Далее контейнер передает эту пару объектов в нужные методы фильтров, сервлетов и так они путешествуют по всей цепочке обработки и в итоге опять возвращается контейнеру. Он преобразует объект ответа в "сырой" ответ, отдает его веб-серверу, а веб-сервер - клиенту.

Каждый запрос обрабатывается в отдельном потоке. Организацией потоков занимается контейнер. Например, создает пул потоков. Несмотря на множество потоков, каждый сервлет существует в *единственном экземпляре*.

### ServletContext

Контекст представлен интерфейсом [ServletContext](https://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html). Контейнер создает контекст при запуске приложения. Контекст существует *один на все приложение*, т.е. все сервлеты получают один и тот же объект контекста. Сервлеты, относящиеся к разным приложениям, не видят контекст другого приложения. Контекст *не потокобезопасный*.

Параметры контекста можно задать только через xml, через аннотации - нельзя.

Интерфейс весьма обширный, но вот самые необходимых методы, связанные с начальными параметрами контекста и добавленными в процессе работы:

```java
// Начальные параметры
String getInitParameter(String name)
Enumeration<String> getInitParameterNames()

// Добавленные в процессе работы ("атрибуты")
void setAttribute(String name, Object object)
Object getAttribute(String name)
void removeAttribute(String name)
Enumeration<String> getAttributeNames()
```

Еще есть методы логирования средствами контейнера:

```java
void log(String msg)
void log(String message, Throwable throwable)
```

### ServletConfig

Конфиг представлен интерфейсом [ServletConfig](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletConfig.html). Когда контейнер создает сервлет, он:

* Сперва считывает параметры из xml или аннотаций и формирует объект конфига
* Создает объект сервлета с помощью конструктора
* Передает сервлету его конфиг через параметризованную версию метода `.init(ServletConfig)`

Изменить этот конфиг или как-то "перечитать" обновленные значения параметров нельзя - для этого нужно перезапускать сервлет целиком. Но ServletConfig и не предназначен для хранения каких-то часто изменяющихся значений. Это именно что-то конфигурационное плюс-минус стабильное. У каждого сервлета свой конфиг, недоступный другим сервлетам.

Интерфейс довольно компактный. Основной функционал по сути - добраться до контекста, да получить значение параметра:

```java
String getInitParameter(String name)
ServletContext getServletContext()
Enumeration<String> getInitParameterNames()
String getServletName()
```

## Объекты запроса и ответа

### ServletRequest и ServletResponse

На основе "сырого" Http-запроса контейнер создает объект запроса, реализующий интерфейс [ServletRequest](https://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html) из спецификации сервлетов ([исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/ServletRequest.java)), а также создает объект для ответа, реализующий интерфейс [ServletResponse](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html) ([исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/ServletResponse.java)). Какие именно типы кроются за этими интерфейсами, зависит от контейнера - в спецификации конкретных реализаций нет. Но сервлетам, фильтрам и прочим пользователям это безразлично, т.к. они потребляют именно интерфейс.

> Чтобы узнать, какие именно классы использует контейнер, можно на объектах запроса \ ответа вызвать метод getClass() и затем найти полученный класс в исходниках. Например, в tomcat интерфейс HttpServletRequest реализует класс org.apache.catalina.connector.Request

![servlet-request-response-wrapper.drawio](img/servlet-request-response-wrapper.drawio.svg)



Для ответа и запроса есть Http-версии интерфейсов - [HttpServletRequest](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html) ([исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpServletRequest.java)) и [HttpServletResponse](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html) ([исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpServletResponse.java)). В них есть методы, с помощью которых из запроса легко извлечь заголовки, куки и прочие вещи.

### Обертки для запроса и ответа

Но в спецификации зато есть реальные классы-обертки с этими интерфейсами:

* ServletRequestWrapper ([спека](https://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequestWrapper.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/ServletRequestWrapper.java)), ServletResponseWrapper ([спека](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponseWrapper.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/ServletResponseWrapper.java))
* HttpServletRequestWrapper ([спека](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequestWrapper.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpServletRequestWrapper.java)), HttpServletResponseWrapper ([спека](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponseWrapper.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpServletResponseWrapper.java)) 

Они используют паттерн декоратор и вся их суть - это делегировать работу реальному объекту запроса \ ответа, который нам дает контейнер:

```java
public class ServletRequestWrapper implements ServletRequest {
    private ServletRequest request;

    public ServletRequestWrapper(ServletRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Request cannot be null");
        }
        this.request = request;
    }
    ...
    @Override
    public Object getAttribute(String name) {
        // Делегируем работу реальному объекту запроса, который нам дает контейнер
        return this.request.getAttribute(name);
    }
}
```

Так что если мы хотим как-то самостоятельно доработать объект запроса \ ответа, то можем унаследоваться от класса-обертки, дописать нужный функционал в свой класс, а потом просто завернуть в него объект запроса \ ответа, созданный контейнером. В итоге получим весь функционал исходного объекта, плюс собственные расширения.

Выглядит примерно так: допустим, мы хотим запретить сбрасывать буфер в ответе. Метод для этого действия определен в интерфейсе ServletResponse, значит объект ответа, который мы получаем от контейнера, наверняка содержит реализацию. Тогда мы:

* Создаем свой класс ответа, наследуясь от обертки:

  ```java
  class DisallowFlushResponseWrapper extends HttpServletResponseWrapper {
      public DisallowFlushResponseWrapper(HttpServletResponse response) {
          // Сохраняем исходный объект ответа, который создал контейнер,
          // чтобы не потерять его (объекта ответа) функционал
          super(response);
      }
  
      @Override
      // Переопределяем реализацию "контейнерного" ответа, касающуюся сброса буфера
      public void flushBuffer() {
          throw new UnsupportedOperationException("Don't call this!");
      }
  }
  ```

* В месте потребления запроса \ ответа (например, в фильтре или в сервлете) подменяем объект ответа, полученный от контейнера, путем оборачивания его в свою реализацию. И дальше по цепочке идет уже наша собственная реализация, обладающая всем функционалом исходного (контейнерского) объекта ответа, но с учетом наших правок:

  ```java
  class DisallowFlushFilter implements Filter {
      public void doFilter(ServletRequest request, ServletResponse response,
              FilterChain chain) {
          if (response instanceof HttpServletResponse) {
              HttpServletResponse newResponse =
                  new DisallowFlushResponseWrapper((HttpServletResponse) response);
              chain.doFilter(request, newResponse);
          }
          ...
      }
      ...
  }
  ```


## Сервлеты

Синим - интерфейсы, красным - абстрактные классы.

![servlets.drawio](img/servlets.drawio.svg)

### Интерфейс Servlet

В основе лежит интерфейс [Servlet](https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html). В нем не так уж много:

```java
void init(ServletConfig config)
void service(ServletRequest req, ServletResponse res)
ServletConfig getServletConfig()
void destroy()
String getServletInfo()
```

Метод init, чтобы контейнер мог передать сервлету его конфиг. Метод getServletConfig для получения конфига. Метод service, чтобы получить от контейнера объекты запроса и ответа.

### Класс GenericServlet

[Исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/GenericServlet.java) Абстрактный класс [GenericServlet](https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html) реализует интерфейс Servlet  и ServletConfig. Из полезного - реализован метод `init(ServletConfig config)` и введен метод `init()` без параметров. Базовая суть инициализации - просто сохранить в сервлете ссылку на его конфиг:

```java
 @Override
public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}

public void init() throws ServletException {
    // Тут по умолчанию пусто
}
```

Такая организация позволяет нам дополнять инициализацию своим кодом, переопределяя именно этот пустой метод. Это полезно, потому что иначе нам пришлось бы переопределять параметризованный init и не забывать самим класть конфиг в поле config. А так нам не нужно об этом помнить.

### Класс HttpServlet

[Исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpServlet.java) Абстрактный класс [HttpServlet](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html) расширяет класс GenericServlet. От предка получает удобство с init(), плюс добавляет ряд удобных методов:

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp)
protected void doPost(HttpServletRequest req, HttpServletResponse resp)
protected void doPut(HttpServletRequest req, HttpServletResponse resp)
protected void doPatch(HttpServletRequest req, HttpServletResponse resp)
protected void doDelete(HttpServletRequest req, HttpServletResponse resp)
```

В общем, на самые распространенные методы Http-протокола тут есть свой метод, который можно переопределить и он будет срабатывать только на соответствующий тип запроса.

Реализовано это так: у класса HttpServlet переопределен метод `service(ServletRequest req, ServletResponse res)` - он принимает объекты интерфейсов ServletRequest и ServletResponse, приводит их к Http-версиям и передает в метод `service(HttpServletRequest req, HttpServletResponse resp)`. Там из запроса извлекается вид метода, анализируется обычными if-else и вызывается либо doGet, либо doPost и т.д. В исходниках весьма наглядно.

### Жизненный цикл сервлета

Примерно таков:

* Сервлет не существует

* Сервлет находится в процессе инициализации:

  * Выполняется конструктор, получается объект будущего сервлета
  * Выполняется метод `.init(ServletConfig config)` этого объекта и он становится настоящим сервлетом

  Объект становится полноценным сервлетом, только когда контейнер передает ему через метод init ссылку на конфиг. Поэтому в конструкторе сервлета не рекомендуется ничего писать, а всю начальную настройку, если она нужна, делать именно в init.

* Сервлет инициализирован (initialized)

* Сервлет находится в процессе уничтожения (выполняется метод `.destroy`)

## Listener'ы

Обычно фреймворкоподобные программы предоставляют нам *систему событий*, чтобы мы могли в нужные моменты "вклиниться" в работу фреймворка и что-то сделать. Например, было бы полезно создать соединение с БД и положить его в контекст, чтобы все сервлеты приложения могли обращаться к БД.

Вопрос в том, *где* и *в какой момент* мы можем создать этот объект соединения, ведь мы не управляем контейнером. И вот для таких целей в спецификации сервлетов определены интерфейсы *слухачей*, на все случаи жизни. Мы пишем слухача, отдаем его контейнеру и он в нужный момент вызывает метод слухача, передавая туда интересующие нас данные.

В данном случае нам нужен слухач с интерфейсом `ServletContextListener`. У него метод `contextInitialized(ServletContextEvent event)`. Когда ServletContext прошел инициализацию, контейнер вызывает этот метод и передает туда контекст. Так что если мы, например, разместим в xml-конфиге строку соединения, объявленную как параметр контекста, то она попадет в контекст при его создании и мы сможем в методе слухача прочитать ее, создать объект соединения и тут же положить его в контекст. Соответственно, после этого все сервлеты смогут брать соединения из контекста.

Конкретный пример будет дальше. Вот список интерфейсов слухачей из спецификации:

```java
AsyncListener
HttpSessionActivationListener
HttpSessionAttributeListener
HttpSessionBindingListener
HttpSessionIdListener
HttpSessionListener
ReadListener
ServletContextAttributeListener
ServletContextListener
ServletRequestAttributeListener
ServletRequestListener
WebListener
WriteListener
```

## Фильтры

![filter.drawio](img/filter.drawio.svg)

### FilterConfig

[Спека](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/FilterConfig.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/FilterConfig.java)

У фильтров, как и у сервлетов, могут быть свои собственные параметры инициализации, которые при создании экземпляра фильтра оформляются в объект конфига. Соответственно, интерфейс FilterConfig предоставляет средства для получения их значений. Кроме того, конфиг фильтра имеет ссылку на контекст.

> Хотя контекст формально представлен интерфейсом ServletContext, но название не очень удачное, т.к. фактически это контекст приложения, а не только сервлетов, а значит все участники приложения имеют право к нему обращаться, в том числе конечно же и фильтры.

```java
String getFilterName()
String getInitParameter(String name)
Enumeration<String> getInitParameterNames()
ServletContext getServletContext()
```

### Filter

[Спека](https://docs.oracle.com/cd/E17802_01/products/products/servlet/2.3/javadoc/javax/servlet/Filter.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/Filter.java)

Интерфейс фильтра довольно прост и сильно похож на интерфейс сервлета, за исключением того, что в рабочий метод еще передается объект с интерфейсом FilterChain:

```java
void init(FilterConfig filterConfig)
void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
void destroy()
```

### FilterChain

[Спека](https://docs.oracle.com/javaee/7/api/javax/servlet/FilterChain.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/FilterChain.java)

Интерфейс состоит всего из одного метода:

```java
void doFilter(ServletRequest request, ServletResponse response)
```

Контейнер объединяет найденные фильтры в цепочку по определенным правилам (пример рассмотрен дальше, в практическом разделе). Поскольку фильтры являются самостоятельными и ничего не знают о других фильтрах, то нужен дополнительный объект, который бы хранил в себе их порядок.

Вот для этого и нужен интерфейс FilterChain. Контейнер предоставляет его реализацию, создает объект цепочки, кладет в него фильтры в нужном порядке и передает цепочку первому фильтру. Фильтр делает свое дело и вызывает на цепочке метод doFilter и она уже вызывает следующий фильтр. Выглядит это примерно так:

```java
public class SampleHttpFilter extends HttpFilter {
	@Override
    protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
        throws IOException, ServletException {
        // Сначала фильтр делает свое дело

        // Потом передает объекты запроса\ответа цепочке, а она уже вызывает следующий фильтр
        chain.doFilter(req, res);
    }
}
```

Цепочка всегда заканчивается сервлетом или JSP. TODO: Выяснить, сервлет прямо как-то вставляется в цепочку или это образное выражение и сервлет идет отдельно.

### GenericFilter

[Спека](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/GenericFilter.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/GenericFilter.java)

GenericFilter по сути выполняет то же назначение, что и GenericServlet - предоставляет метод init() без параметров для удобного расширения инициализации. Ну и дублирует методы конфига по получению из него значений, чтобы было меньше писанины.

### HttpFilter

[Спека](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpFilter.html), [исходники](https://github.com/jakartaee/servlet/blob/master/api/src/main/java/jakarta/servlet/http/HttpFilter.java)

HttpFilter просто приводит объекты ServletRequest \ ServletResponse к HttpServletRequest \ HttpServletResponse и передает их в метод, который мы уже переопределяем:

```java
@Override
// Класс выполняет для нас приведение запроса\ответа к нужным интерфейсам
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {
    if (!(req instanceof HttpServletRequest && res instanceof HttpServletResponse)) {
        throw new ServletException("non-HTTP request or response");
    }
	// вот тут, и вызывает метод, который
    this.doFilter((HttpServletRequest) req, (HttpServletResponse) res, chain);
}

// нам остается переопределить
protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
        throws IOException, ServletException {
    // вписав сюда какую-нибудь обработку
    chain.doFilter(req, res);
}
```

# Tomcat

## Установка

Для установки Tomcat нужно просто [скачать zip-архив](https://tomcat.apache.org/) и распаковать его в удобное место. Например, [девятая версия](https://tomcat.apache.org/download-90.cgi).

## Запуск и остановка

Для запуска\остановки открываем консоль, переходим в `tomcat/bin` и вызываем `startup` \ `shutdown`.

После успешного запуска на `localhost:8080/` должна быть страница приветствия.

## Деплой приложения

Чтобы развернуть приложение, достаточно скомпилировать его в .war-архив и положить этот архив в папку `tomcat\webapps`. Останавливать томкэт не надо - он автоматически видит изменения. После этого приложение становится доступно по адресу

```
localhost:8080/appname
```

Т.е. если файл приложения называется servlet-1.war, то оно будет доступно по адресу `localhost:8080/servlet-1`

## Логи tomcat

Если вдруг что-то пошло не так, логи можно посмотреть в папке `tomcat\logs`, файлы называются catalina.2022-05-18.txt по дате логирования.

# Зависимости

Используем maven проект. Для компиляции нам понадобится зависимость, содержащая классы сервлетов. Но поскольку мы будем деплоить на Tomcat, который в своем составе имеет эту зависимость, то скоуп поставим provided:

```xml
<dependency>
      <groupId>jakarta.platform</groupId>
      <artifactId>jakarta.jakartaee-api</artifactId>
      <version>8.0.0</version>
      <scope>provided</scope>
</dependency>
```

Можно использовать старую зависимость:

```xml
<dependency>
    <groupId>javax</groupId>
    <artifactId>javaee-api</artifactId>
    <version>7.0</version>
    <scope>provided</scope>
</dependency>
```

Чтобы развернуть программу на Tomcat, мы должны упаковать ее в war. Для этого в pom рядом с описанием проекта добавим вид упаковки war с помощью тега <packaging>:

```xml
<groupId>johny.dotsville</groupId>
<artifactId>my-servlet</artifactId>
<version>1</version>
<packaging>war</packaging>
```

и подключим плагин, который собственно и занимается упаковкой (если уже есть другой плагин для упаковки, надо его убрать):

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.3.2</version>
    <configuration>
    	<failOnMissingWebXml>false</failOnMissingWebXml>
        <outputDirectory>C:/tmp</outputDirectory>  <!-- Если хотим в какое-то свое место класть архив -->
    </configuration>
</plugin>
```

# Простой сервлет

## Класс сервлета

Создадим вот такой класс сервлета (создание и настройку логгера смотри в отдельном мануале):

```java
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

// name должен быть уникален среди других сервлетов программы
@WebServlet(
    name = "bar",
    urlPatterns = { "/bar" },
    initParams = {
            @WebInitParam(name = "developer", value = "JohNy Dotsville", description = "hello"),
            @WebInitParam(name = "email", value = "come.as@you.are", description = "world")
    }
)
public class BarServlet extends HttpServlet {
    private static final Logger logger = LogManager.getLogger();
    private String message;
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        logger.info("Работает сервлет BarServlet");
        logger.info("Выполняем метод doGet");
        resp.getWriter().println(String.format("Developer: %s (%s)\nLocation: %s, %s\n%s",
                // Персональные параметры сервлета
                getServletConfig().getInitParameter("developer"),
                getServletConfig().getInitParameter("email"),
                // Глобальные параметры приложения
                getServletContext().getInitParameter("country"),
                getServletContext().getInitParameter("city"),
                // Демонстрируем, что наше дополнение к инициализации работает
                message));
    }
    
    @Override
    public void init() {
        // Расширяем базовую инициализацию чем-то своим
        message = "This message set inside init() method of servlet";
    }
}
```

Собственно все. Благодаря аннотации `@WebServlet` томкэт сможет обнаружить наш сервлет и использовать его для обработки GET-запросов, приходящих по адресу `localhost:8080/my-servlet/bar`:

* my-servlet - потому что мы упаковали программу в war-архив именно с таким именем
* bar - потому что это указано в параметре urlPatterns аннотации @WebServlet

Мы можем создать много подобных сервлетов в одной программе, по сервлету на каждый url например и все они будут нормально работать под управлением контейнера сервлетов. В получившейся программе не нужен метод main, потому что программа сама по себе ничего не делает, она просто описывает сервлеты.

TODO: Про writer в ответе бы еще почитать.

## Конфиг через xml

Настраивать сервлеты можно через xml. Для этого:

* Если это maven-проект, то в директории main создаем директорию `webapp\WEB-INF`
* Кладем туда файл `web.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>bar</servlet-name>
        <servlet-class>johny.dotsville.BarServlet</servlet-class>
        <init-param>
            <param-name>developer</param-name>
            <param-value>JohNy Dotsville</param-value>
            <description>Имя разработчика, ответственного за сервлет</description>
        </init-param>
        <init-param>
            <param-name>email</param-name>
            <param-value>come.as@you.are</param-value>
            <description>Почта разработчика, ответственного за сервлет</description>
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>bar</servlet-name>
        <url-pattern>/bar</url-pattern>
    </servlet-mapping>

    <context-param>
        <param-name>country</param-name>
        <param-value>Russia</param-value>
        <description>Страна, в которой разработано приложение</description>
    </context-param>
    <context-param>
        <param-name>city</param-name>
        <param-value>Moscow</param-value>
        <description>Город, где расположен головной офис компании</description>
    </context-param>

</web-app>
```

Из плюсов такого подхода:

* Параметры находятся вне кода, поэтому можно просто открыть .war, поменять значение в xml файле, томкэт сам перезагрузит сервлет и новые значения окажутся в программе. В случае аннотаций так не получится.

Замечания:

* Можно смешивать конфиги через аннотации и xml (но по ощущениям лучше этого не делать, а писать все в xml). Например, чтобы вынести параметры сервлета в xml для гибкого изменения, мы можем сделать так:
  * Полноценно описываем сервлет в xml тегом servlet, указывая имя и класс, а также параметры
  * В аннотациях тоже указываем имя (должно совпадать с xml'ным) и url.
  * Получается, что в коде наглядно видно имя сервлета и url, а параметры лежат в xml и их можно легко менять после деплоя без необходимости перекомпилировать класс сервлета
  * Недостаток - необходимость два раза указывать одинаковое имя в разных местах
* Для context-параметров не существует способа задания через аннотации, только xml

# Простой слухач

## Класс слухача

Просто реализуем нужный интерфейс. Для сценария, описанного выше в теории, когда хотим положить объект соединения с БД в контекст, нам нужен интерфейс ServletContextListener:

```java
@WebListener  // Чтобы контейнер увидел слухача, используем аннотацию или xml-конфиг
public class MyServletContextListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent event) {
        // Из события извлекаем контекст
        ServletContext context = event.getServletContext();
        // Получаем строку соединения из параметра
        String connectionString = context.getInitParameter("connection-string");
        // Создаем объект соединения
        DbDummy dbDummy = new DbDummy(connectionString);
        // И кладем это соединение в контекст
        context.setAttribute("database", dbDummy);
    }

    @Override
    public void contextDestroyed(ServletContextEvent event) {
        // Тут можно было бы например закрыть соединение или сделать что-то еще при необходимости
    }
}
```

Класс, имитирующий БД:

```java
public class DbDummy {
    private static final List<String> data = new ArrayList<>(List.of("tom", "huck", "sid", "mary"));
    private final String connectionString;

    public DbDummy(String connectionString) {
        this.connectionString = connectionString;
    }

    public List<String> getData() {
        if (connectionString.isEmpty()) {
            throw new RuntimeException("Database connection failed: connection string is undefined");
        }
        return data;
    }
}
```

## xml конфиг

Вносим параметр контекста со строкой соединения и регистрируем слухача (если вдруг не использовали аннотацию @WebListener):

```xml
...
    <context-param>
        <param-name>connection-string</param-name>
        <param-value>localhost:41337//databasedummy</param-value>
        <description>Представим, что это и правда строка соединения</description>
    </context-param>
...
	<listener>
        <listener-class>
            johny.dotsville.MyServletContextListener
        </listener-class>
    </listener>

</web-app>
```

## Использование в сервлете

В сервлете бесхитростно достаем нужный объект и пользуемся:

```java
public class BarServlet extends HttpServlet {
    ...
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        // Извлекаем объект соединения, приводя его к нужному типу
        DbDummy db = (DbDummy) getServletContext().getAttribute("database");
        // ??? PROFIT! Пользуемся
        String result = String.join(", ", db.getData());

        resp.getWriter().println(String.format("Data: %s", result));
    }
    ...
}
```

# Простой фильтр

## Класс фильтра

Просто поместим в запрос сообщение, которое потом сможет прочитать сервлет:

```java
public class GreetHttpFilter extends HttpFilter {
    
    @Override
    protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        String fname = getClass().getSimpleName();  // GreetHttpFilter
        getServletContext().log(String.format("%s in action.", fname));

        req.setAttribute("greet-message", getFilterConfig().getInitParameter("message"));

        chain.doFilter(req, res);
    }
}
```

## Конфиг через xml

Необходимо:

* Каждый фильтр описать тегом `filter`. Назначение внутренних тегов очевидно. Если надо несколько параметров, просто используем несколько раз тег init-param.
* Для каждого фильтра с помощью тега `filter-mapping` задать, на что фильтр должен реагировать:
  * Через тег `filter-name` указываем имя фильтра, для которого пишется правило.
  * Через тег `url-pattern` задаем паттерн, при котором будет срабатывать фильтр. Либо через тег `servlet-name` *явно* указываем имя сервлета, на который должен срабатывать фильтр. Если фильтр должен срабатывать на несколько паттернов или сервлетов, то просто несколько раз используем соответствующий тег. Можно одновременно использовать и servlet-name, и url-pattern.

```xml
...
    <filter>
        <filter-name>greet</filter-name>
        <filter-class>johny.dotsville.filters.GreetHttpFilter</filter-class>
        <init-param>
            <param-name>message</param-name>
            <param-value>Hello! This is greet filter from xml!</param-value>
        </init-param>
    </filter>

    <filter-mapping>
        <filter-name>greet</filter-name>
        <!--<url-pattern>/*</url-pattern>-->
        <!--<url-pattern>/some/*</url-pattern>-->
        <servlet-name>bar</servlet-name>
        <servlet-name>foo</servlet-name>
    </filter-mapping>
...
</web-app>
```

## Через аннотации

```java
@WebFilter(
    filterName = "greet",
    urlPatterns = { "/*" },
    initParams = {
        @WebInitParam(name = "message", value = "Hello! This is greet filter!")
    })
public class GreetHttpFilter extends HttpFilter {
    ...
}
```

Проблема аннотаций в том, что с их помощью невозможно задать последовательность выполнения фильтров, потому что она определяется исключельно тем, в каком порядке идут теги `filter-mapping` в xml. Соответственно, придется все равно смешивать xml и аннотации, причем не самым очевидным образом, а поэтому лучше в случае фильтров все целиком делать в xml.

## Последовательность фильтров

Фильтры собираются в цепочку. Итоговая последовательность определяется так:

* Сначала обрабатываются фильтры, у которых задан url-pattern
  * Они собираются в последовательность так, в какой очереди идут в xml
* Потом обрабатываются фильтры, у которых задан servlet-name
  * Они тоже собираются в последовательность так, в какой очереди идут в xml
* Оба фрагмента цепочки соединяются вместе

Допустим, у нас такие фильтры (взято из книги Head First Servlets and JSP):

```xml
<filter-mapping>
    <filter-name>Filter1</filter-name>
    <url-pattern>/Recipes/*</url-pattern>
</filter-mapping>

<filter-mapping>
    <filter-name>Filter2</filter-name>
    <servlet-name>/Recipes/HopsList.do</servlet-name>
</filter-mapping>

<filter-mapping>
    <filter-name>Filter3</filter-name>
    <url-pattern>/Recipes/Add/*</url-pattern>
</filter-mapping>

<filter-mapping>
    <filter-name>Filter4</filter-name>
    <servlet-name>/Recipes/Modify/ModRecipes.do</servlet-name>
</filter-mapping>

<filter-mapping>
    <filter-name>Filter5</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

Задача - понять, какая последовательность фильтров применится к каждому url:

```
/Recipes/HopsReport.do
/Recipes/HopsList.do
/Recipes/Modify/ModRecipes.do
/HopsList.do
/Recipes/Add/AddRecipes.do
```

Решение:

* Смотрим на url-pattern и servlet-name и осознаем, какие фильтры в принципе должны примениться к url
* По очередности описания фильтров в xml определяем последовательность применения фильтров

```
/Recipes/HopsReport.do
Сначала смотрим по url-pattern, подходит к паттерну f1 /Recipes/* и f5 /*
Значит фильтры 1, 5 подходят.
Поскольку в xml они идут в очередности 1, 5, то значит их порядок 1, 5
По servlet-name совпадений нет
> Значит итоговый порядок всех фильтров для этого url будет 1, 5

/Recipes/HopsList.do
Подходит к паттерну f1 /Recipes/* и f5 /* => 1, 5
Подходит под f2, потому что в нем сервлет вообще указан явно /Recipes/HopsList.do => 2
> Итого 1, 5, 2

/Recipes/Modify/ModRecipes.do
Подходит к паттерну f1 /Recipes/* и f5 /* => 1, 5
Сервлет явно указан в f4 /Recipes/Modify/ModRecipes.do => 4
> Итого 1, 5, 4

/HopsList.do
Подходит только под паттерн f5 /* => 5
Под сервлет /Recipes/HopsList.do не подходит, потому что не начинается с /Recipes
> Итого 5

/Recipes/Add/AddRecipes.do
Подходит под паттерн f1 /Recipes/* и f3 /Recipes/Add/* и f5 /* => 1, 3, 5
> Итого 1, 3, 5
```

TODO: вписать пример преобразования ответа на обратном пути

TODO: Разобраться что такое request dispatchers (стр. 711 книжная)

# Некоторые термины

Не разбирал, но возможно полезно, просто оставлю тут список:

```
Deployment Descriptor (web.xml file)
```



# TODO

Когда читал про фильтры, там было что-то про dispatcher. Потом почитать, что это такое применительно к сервлетной теме.

```
You can have from 0 to 4 <dispatcher> elements.
é A REQUEST value activates the filter for client
requests. If no <dispatcher> element is present,
REQUEST is the default.
é An INCLUDE value activates the filter for request
dispatching from an include() call.
é A FORWARD value activates the filter for request
dispatching from a forward() call.
é An ERROR value activates the filter for resources
called by the error handler.
```

TODO: Про потокобезопасность атрибутов контекста и сессии еще предстоит выяснить, но позже, в специализированных конспектах.

TODO: Еще бы про JSP сам сделать. Какую-нибудь простую страницу и вообще понять место JSP во всей этой схеме.