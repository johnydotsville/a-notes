* Деплоить будем на Tomcat
* Создадим простой сервлет

# Сервлеты и контейнеры сервлетов

## Сервлет

*Сервлет*, если опустить детали и оставить самую суть, - это Java-класс, в который мы можем поместить логику обработки Http-запроса. Если затем мы предоставим этот класс *контейнеру сервлетов*, то когда придет запрос, контейнер по url сможет понять, какой сервлет нужно вызвать для обработки этого запроса.

## Контейнер сервлетов

Это программа, которая управляет жизненным циклом сервлетов: создает их, вызывает их методы, создает треды для обработки поступающих запросов и много чего еще. Одним словом, контейнер сервлетов формирует среду, необходимую для работы сервлетов.

Одним из самых популярных контейнеров сервлетов является Tomcat. Контейнер сервлетов и веб-сервер - разные вещи. Запрос, в общих чертах, проходит такой путь:

```
Клиент > Веб-сервер > Контейнер сервлетов > Сервлет > Контейнер сервлетов > Веб сервер > Клиент
```

Т.е. идет от клиента до сервлета и обратно. Контейнер берет на себя заботу о преобразовании этого запроса в объекты удобного вида, чтобы нам было комфортно с ними работать в сервлетах.

> Немного дополнительной информации: есть так называемая Java EE (которая в данный момент переименована в Jakarta EE). Это "спецификация серверной платформы" - набор API, которым должна обладать гипотетическая реализация, чтобы построить супер-пупер-крутое-и-сложное веб-приложение. В эту спецификацию входят много других спецификаций, например, транзакции, валидация, хранение и остальные непонятные технологии (см. википедию). Примером конкретной реализации Java EE является Glassfish - это *сервер приложений* (application server). Т.е. предполагается, что сервер приложений реализует все спецификации.
>
> Среди этой кучи спецификаций, составляющих сервер приложений, есть *спецификация сервлетов* - компонентов, предназначенных для обработки http-запросов. Так вот *контейнером сервлетов* называется программа, которая реализует только спецификацию сервлетов.

# Архитектура вкратце

TODO: ??? Нарисовать потом картинкой это все и сделать ссылки на доку. Не перепутать только простые и Http-версии. Родство классов отобразить обязательно.

Есть [абстрактный класс](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html) `HttpServlet`, реализующий интерфейсы `Servlet` и `ServletConfig`. У него есть метод `service(ServletRequest req, ServletResponse res)`, доставшийся от Servlet'а, как видно с двумя параметрами - под [запрос](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html) и под [ответ](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html). Кроме того у HttpServlet есть свои методы doPost, doGet, doDelete, doPut, в общем, по имени основных типов запросов. У метода service есть дефолтная реализация, которая на основании типа запроса вызывает соответствующий метод. Если запрос get - тогда вызывает метод doGet, если post - тогда doPost. Мы можем переопределить эти doN методы, чтобы на каждый тип запроса реагировать отдельно. На какие-нибудь новые модные запросы вроде Patch метода может не быть. Тогда можно переопределить сам метод service, вызвать дефолтную реализацию, а дальше подписать уже недостающие остатки.

Контейнер сервлетов получает запрос, создает объекты под запрос и ответ и передает эти объекты в метод сервлета. Там мы из объекта запроса читаем информацию, что-то вычисляем и записываем ответ в объект ответа. Контейнер преобразует объект ответа в Http-ответ, передает его веб-серверу, а он уже передает обратно клиенту.

Где-то в этой цепочке присутствует создание нового потока для обработки запроса, создание самого объекта сервлета, передача туда объектов запроса и ответа и т.д. Но концептуально это все не важно. Важно только то, что запрос в удобном виде в итоге попадает в метод нужного сервлета.

TODO: ??? Потом возможно догуглить до полного прояснения ситуации и расписать точно, как это еще и технически работает:

Впрочем, несмотря на не важность конкретики технических деталей, важно понимать вот что:

* Каждый запрос клиента выполняется в отдельном треде. Тред или создается новый или берется из пула.
* Несмотря на много тредов, существует только один объект сервлета.
* У каждого запроса свои объекты запроса и ответа.
* Объекты сервлетов могут создаваться как при запуске контейнера, так и при первом обращении. Зависит от настроек самого контейнера.

## Жизненный цикл сервлета

Примерно таков:

* Сервлет еще не существует
* Сервлет находится в процессе инициализации (выполняется сначала конструктор, а потом метод `.init`)
* Сервлет инициализирован (initialized)
* Сервлет находится в процессе уничтожения (выполняется метод `.destroy`)

После выполнения конструктора объект еще не стал сервлетом, потому что еще не получил объекты `ServletConfig` и `ServletContext`. Их он получает в процессе выполнения метода `.init`. В конструкторах рекомендуется ничего не писать, а всю начальную настройку, если она нужна, делать именно в init.

## ServletConfig

Каждый сервлет получает свой *собственный* объект `ServletConfig`. 

Это объект, содержащий "персональные" параметры сервлета и другим сервлетам они не доступны. Их можно задать через xml или через аннотации. ServletConfig инициализируется единожды - когда контейнер создает сервлет, он:

* Сперва считывает параметры из xml или аннотаций и формирует объект ServletConfig
* Создает объект сервлета с помощью конструктора
* Передает объект ServletConfig сервлету через параметризованную версию метода `.init(ServletConfig)`

Изменить этот объект или как-то "перечитать" обновленные значения параметров нельзя - для этого нужно перезапускать сервлет целиком. Но ServletConfig и не предназначен для хранения каких-то часто изменяющихся значений. Это именно что-то конфигурационное плюс-минус стабильное.

## ServletContext

`ServletContext` существует *один на все приложение*, т.е. все сервлеты получают один и тот же `ServletContext` (так что его можно воспринимать как некий ApplicationContext). Параметры контекста можно задать только через xml, через аннотации - нельзя. Сервлеты, относящиеся к разным приложениям, не видят контекст другого приложения.

Контейнер сервлетов создает ServletContext при запуске приложения. Затем при создании сервлета контейнер создает ServletConfig и помещает в него ссылку на ServletContext. Ну а дальше контейнер передает сервлету ServletConfig через метод init и таким образом ServletContext становится доступен сервлету.

TODO: Мб нарисовать это картинкой

TODO: Мб поискать в исходниках tomcat где он создает ServletContext? Когда с остальным разберусь. Просто ради интереса.

## Метод .init

TODO: Мб нарисовать это картинкой тоже

Этот метод изначально определен в интерфейсе `jakarta.servlet.Servlet` и выглядит так:

```java
public void init(ServletConfig config) throws ServletException;
```

Далее у нас есть абстрактный класс GenericServlet, который выглядит так:

```java
@Override
public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}

public void init() throws ServletException {
    // Здесь действительно ничего нет, метод без кода
}
```

Т.е. он добавляет еще один метод init без параметров и вызывает его в параметризованном после установки конфига. Сделано это для удобства - мы можем переопределить метод init() и таким образом дополнить исходный init(ServletConfig) своими собственными установками. Контейнер сервлетов вызывает init(ServletConfig), а стало быть и наш init() тоже выполнится.

Далее В HttpServlet (наследник GenericServlet'а) дела обстоят вот так:

```java
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);  // <-- Использует реализацию родителя
    legacyHeadHandling = Boolean.parseBoolean(config.getInitParameter(LEGACY_DO_HEAD));
}

// init() нету вообще
```

Наши собственные рукописные сервлеты как правило являются наследниками именно HttpServlet, а значит через  переопределение init() мы получаем возможность *дополнить исходную* инициализацию своим кодом (по схеме выше) и не бояться нарушить ее.



TODO: ??? Сделать норм примеры на то, что можно получить из объекта запроса и ответа.

TODO: Приделать второй сервлет и через контекст обменяться данными. Более детально посмотреть как контекст и конфиг связаны - как будто ссылка на контекст кладется в конфиг и т.о. сервлет получает контекст. При этом к контексту можно обратиться через метод самого сервлета. Посмотреть, как это устроено - возможно обертка, внутри которой обращение к конфигу, а оттуда к контексту.







# Tomcat

## Установка

Для установки Tomcat нужно просто [скачать zip-архив](https://tomcat.apache.org/) и распаковать его в удобное место. Например, [девятая версия](https://tomcat.apache.org/download-90.cgi).

## Запуск и остановка

Для запуска\остановки открываем консоль, переходим в `tomcat/bin` и вызываем `startup` \ `shutdown`.

После успешного запуска на `localhost:8080/` должна быть страница приветствия.

## Деплой приложения

Чтобы развернуть приложение, достаточно скомпилировать его в .war-архив и положить этот архив в папку `tomcat\webapps`. Останавливать томкэт не надо - он автоматически видит изменения. После этого приложение становится доступно по адресу

```
localhost:8080/appname
```

Т.е. если файл приложения называется servlet-1.war, то оно будет доступно по адресу `localhost:8080/servlet-1`

## Логи tomcat

Если вдруг что-то пошло не так, логи можно посмотреть в папке `tomcat\logs`, файлы называются catalina.2022-05-18.txt по дате логирования.

# Простой сервлет

## Зависимости

Используем maven проект. Для компиляции нам понадобится зависимость, содержащая классы сервлетов. Но поскольку мы будем деплоить на Tomcat, который в своем составе имеет эту зависимость, то скоуп поставим provided:

```xml
<dependency>
      <groupId>jakarta.platform</groupId>
      <artifactId>jakarta.jakartaee-api</artifactId>
      <version>8.0.0</version>
      <scope>provided</scope>
</dependency>
```

Можно использовать старую зависимость:

```xml
<dependency>
    <groupId>javax</groupId>
    <artifactId>javaee-api</artifactId>
    <version>7.0</version>
    <scope>provided</scope>
</dependency>
```

Чтобы развернуть программу на Tomcat, мы должны упаковать ее в war. Для этого в pom рядом с описанием проекта добавим вид упаковки war с помощью тега <packaging>:

```xml
<groupId>johny.dotsville</groupId>
<artifactId>my-servlet</artifactId>
<version>1</version>
<packaging>war</packaging>
```

и подключим плагин, который собственно и занимается упаковкой (если уже есть другой плагин для упаковки, надо его убрать):

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.3.2</version>
    <configuration>
    	<failOnMissingWebXml>false</failOnMissingWebXml>
        <outputDirectory>C:/tmp</outputDirectory>  <!-- Если хотим в какое-то свое место класть архив -->
    </configuration>
</plugin>
```

## Класс сервлета

Создадим вот такой класс сервлета (создание и настройку логгера смотри в отдельном мануале):

```java
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

// name должен быть уникален среди других сервлетов программы
@WebServlet(
    name = "bar",
    urlPatterns = { "/bar" },
    initParams = {
            @WebInitParam(name = "developer", value = "JohNy Dotsville", description = "hello"),
            @WebInitParam(name = "email", value = "come.as@you.are", description = "world")
    }
)
public class BarServlet extends HttpServlet {
    private static final Logger logger = LogManager.getLogger();
    private String message;
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        logger.info("Работает сервлет BarServlet");
        logger.info("Выполняем метод doGet");
        resp.getWriter().println(String.format("Developer: %s (%s)\nLocation: %s, %s\n%s",
                // Персональные параметры сервлета
                getServletConfig().getInitParameter("developer"),
                getServletConfig().getInitParameter("email"),
                // Глобальные параметры приложения
                getServletContext().getInitParameter("country"),
                getServletContext().getInitParameter("city"),
                // Демонстрируем, что наше дополнение к инициализации работает
                message));
    }
    
    @Override
    public void init() {
        // Расширяем базовую инициализацию чем-то своим
        message = "This message set inside init() method of servlet";
    }
}
```

Собственно все. Благодаря аннотации `@WebServlet` томкэт сможет обнаружить наш сервлет и использовать его для обработки GET-запросов, приходящих по адресу `localhost:8080/my-servlet/bar`:

* my-servlet - потому что мы упаковали программу в war-архив именно с таким именем
* bar - потому что это указано в параметре urlPatterns аннотации @WebServlet

Мы можем создать много подобных сервлетов в одной программе, по сервлету на каждый url например и все они будут нормально работать под управлением контейнера сервлетов. В получившейся программе не нужен метод main, потому что программа сама по себе ничего не делает, она просто описывает сервлеты.

## Конфиг через xml

Настраивать сервлеты можно через xml. Для этого:

* Если это maven-проект, то в директории main создаем директорию `webapp\WEB-INF`
* Кладем туда файл `web.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>bar</servlet-name>
        <servlet-class>johny.dotsville.BarServlet</servlet-class>
        <init-param>
            <param-name>developer</param-name>
            <param-value>JohNy Dotsville</param-value>
            <description>Имя разработчика, ответственного за сервлет</description>
        </init-param>
        <init-param>
            <param-name>email</param-name>
            <param-value>come.as@you.are</param-value>
            <description>Почта разработчика, ответственного за сервлет</description>
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>bar</servlet-name>
        <url-pattern>/bar</url-pattern>
    </servlet-mapping>

    <context-param>
        <param-name>country</param-name>
        <param-value>Russia</param-value>
        <description>Страна, в которой разработано приложение</description>
    </context-param>
    <context-param>
        <param-name>city</param-name>
        <param-value>Moscow</param-value>
        <description>Город, где расположен головной офис компании</description>
    </context-param>

</web-app>
```

Из плюсов такого подхода:

* Параметры находятся вне кода, поэтому можно просто открыть .war, поменять значение в xml файле, томкэт сам перезагрузит сервлет и новые значения окажутся в программе. В случае аннотаций так не получится.

Замечания:

* Можно смешивать конфиги через аннотации и xml. Например, чтобы не описывать параметры сервлета в коде, а вынести их в xml для гибкого изменения, мы можем сделать так:
  * Полноценно описываем сервлет в xml тегом servlet, указывая имя и класс, а также параметры
  * Потом в коде сервлета аннотациями тоже указываем имя (должно совпадать с xml'ным) и url.
  * Получается, что в коде наглядно видно имя сервлета и url, а параметры лежат в xml и их можно легко менять после деплоя без необходимости перекомпилировать класс сервлета
  * Недостаток - необходимость два раза указывать одинаковое имя в разных местах
* Для context-параметров не существует способа задания через аннотации, только xml

# Некоторые термины

Не разбирал, но возможно полезно, просто оставлю тут список:

```
Deployment Descriptor (web.xml file)
```

