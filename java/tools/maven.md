mvn dependency:tree    https://www.tutorialworks.com/maven-find-transitive-dependencies/

# Что такое Maven

Мэвин - это технология для билда проекта и управления зависимостями. В основе лежит идея "объектной модели проекта" (Project Object Model, POM). Управление проектом происходит в декларативном стиле, т.е. мы указываем, что хотим получить, а не что надо сделать.

# Создание проекта

Создать папку с проектом можно по шаблонам (архетипам), которые предоставляет мэвин. Список мэвин-архетипов можно посмотреть тут https://maven.apache.org/archetypes/index.html

Например, базовый проект создается так (все параметры пишутся в одну строку):

```
mvn
archetype:generate
-DarchetypeGroupId=org.apache.maven.archetypes
-DarchetypeArtifactId=maven-archetype-simple
-DarchetypeVersion=1.4
-DgroupId=home.johnydotsville
-DartifactId=hello-maven-1
-Dversion=7.7.7
```

Три пункта: groupId, artifactId и version указываются как для самого архетипа, так и для собственного приложения.

```
mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-simple -DarchetypeVersion=1.4 -DgroupId=com.samplegroup -DartifactId=some-demo -Dversion=7.7.7
```

# Структура проекта

Каждый архетип формирует свою структуру каталогов. Для сравнения можно посмотреть структуру [archetype-simple](https://maven.apache.org/archetypes/maven-archetype-simple/), [archetype-quickstart](https://maven.apache.org/archetypes/maven-archetype-quickstart/) и [archetype-j2eesimple](https://maven.apache.org/archetypes/maven-archetype-j2ee-simple/)

Описанная выше команда создаст такую структуру simple-проекта:

```
|-- hello-maven-1
    |-- pom.xml
    `-- src
        |-- main
        |   `-- java
        |       `-- home
        |           `-- johnydotsville
        |               `-- App.java
        |-- site
        |   `-- site.xml
        `-- test
            `-- java
                `-- home
        |           `-- johnydotsville
                        `-- AppTest.java
```



# Компиляция

Для компиляции нужно зайти в корень проекта (папка, где лежит pom.xml, на примере выше это hello-maven-1) и набрать команду:

```
mvn compiler:compile
```

При компиляции могут возникнуть такие ошибки (upd при использовании simple архетипа ошибки не было, а только в quickstart):

```
[ERROR] Source option 5 is no longer supported. Use 7 or later.
[ERROR] Target option 5 is no longer supported. Use 7 or later.
```

Фиксятся добавлением в pom раздела properties:

```
<properties>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
</properties>
```

Есть еще команда

```
mvn package
```

Пока не читал особо, что она значит. Вроде компиляция с упаковкой в .jar

# Запуск

Команда запуска тоже запускается из корня проекта

```
mvn exec:java -Dexec.mainClass="home.johny.App"
```

# Зависимости

Задаются в .pom в разделе `dependencies`

```xml
<project ...>
  ...
  <properties>
    <log4jversion>2.17.2</log4jversion>
  </properties>
...
  <dependencies>
	<dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>${log4jversion}</version>  <!-- Используем свойство вместо цифры -->
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>${log4jversion}</version>  <!-- Используем свойство вместо цифры -->
      <scope>compile</scope>
    </dependency>
  </dependencies>
  ...
```

После добавления зависимости и компиляции проекта, зависимости скачиваются в локальный репозиторий, который по умолчанию находится в директории `C:\Users\%username%\.m2` В папке *conf* мавена есть файл *settings.xml*. Там много чего можно задать, в частности расположение локального репозитория (тег *localRepository*).

В POM можно объявить свойство в разделе *Properties*, задать ему значение и использовать его по имени. Бывает удобно таким образом объявить, например, версию зависимости и использовать свойство в нескольких местах, вместо того чтобы везде писать конкретную цифру, т.к. бывает что зависимость делится на три части и версия во всех трех частях должна быть одинаковая.

## Виды зависимостей

Зависимости делятся на две общие группы:

* Прямые (direct) - это зависимости, которые мы явно указываем в разделе dependencies

* Транзитивные, "косвенные" (transitive) - это "зависимости зависимостей". Поскольку каждая используемая нами библиотека обычно и сама использует какие-то библиотеки, то получается что и наша программа тоже зависит от этих библиотек.

  Но зависеть может по-разному. Например, мы используем логгер. Разработчики логгера должны тестировать свой продукт и для этого они пользуются каким-нибудь непопулярным фреймворком Noname. Получается, что раз логгер зависит от Noname, то и мы зависим от Noname? Но мы же не пользуемся Noname, да и собственно логгеру Noname нужен только на время выполнения тестов, а при непосредственно работе - нет.

  Т.о., мы бы не хотели зависеть от Noname, чтобы дерево зависимостей не разрасталось. Поэтому существует механизм scope, который позволяет в таких случаях явно указать, когда именно нужна зависимость, чтобы не тащить ее тогда, когда она фактически не нужна.

## Classpath

Перед более детальным объяснением scope нужно вспомнить про *classpath*. Это параметр, в котором мы должны указать путь до классов, чтобы компилятор или виртуальная машина могли их найти. Что это за классы? Это пользовательские классы. К ним относятся наши собственные классы и классы сторонних библиотек. В общем все, что не относится к собственным классам джавы, о расположении которых она и сама знает.

Ключ classpath есть как у программы javac, так и у программы java. Т.е. получается, условно, два classpath - времени компиляции и времени выполнения. Причем они могут быть разными и это вполне естественно. Потому что если мы используем библиотеку A, которой нужна библиотека B, то для *компиляции нашей программы* нам нужно указать в classpath только путь до библиотеки А, т.к. мы используем ее классы напрямую. Но нам не нужно указывать путь до B, т.к. наш код непосредственно ее не трогает. А вот во *время выполнения нашей программы* мы должны указать в classpath путь и до А, и до B, т.к. когда библиотека А начнет работать, ей конечно же понадобятся классы библиотеки B.

> Еще есть "тестовый" (test) classpath вдобавок в двум вышеперечисленным. Он относится к запуску юнит-тестов. Он не нужен ни при компиляции, ни при выполнении.

Итого получается 3 classpath'а:

* complie
* test
* runtime

## Scope

Предисловие: как-то это невероятно сложно оказалось понять до конца. Повсюду копипаста с почти одним и тем же объяснением, которое не понятное. Поэтому я не могу гарантировать, что все написанное ниже правильно до конца.

Вкратце, скоп нужен для двух основных вещей:

* Чтобы не тянуть лишние (реально не нужные нашей программе) транзитивные зависимости
* Чтобы не засорять classpath зависимостями, которые на определенном шаге не нужны, и таким образом не замедлять поиск классов

Скопов 6, из которых основных 4:

* compile
* provided
* runtime
* test

Как я писал выше, есть "разные classpath'ы", в которых требуется указывать пути до зависимостей. Вот первое назначение scope как раз к этому и относится - добавить зависимость в нужный момент (в нужную *фазу*) в нужный classpath. compile означает, что мавен добавит зависимость в classpath при компиляции, тесте и запуске. У мавена есть запускатор и плагины для запуска. 

Второе назначение scope - ограничить "подтягивание" транзитивных зависимостей в программу. Грубо говоря: я пишу библиотеку, для тестов использую Noname фреймворк и объявляю ему скоп test у себя в pom. Это значит, что если кто-то подключит мою библиотеку, он не получит в довесок еще и этот Noname фреймворк, т.е. мавен поймет по этому значению скопа, что Noname нужен был моей библиотеке только для тестов, а для работы не нужен. Значит и пользователю моей библиотеки он не нужен. А вот если бы я написал скоп compile вместо test для Noname, тогда бы и пользователь моей библиотеки стал бы зависимым от Noname, потому что это бы означало, что он нужен моей библиотеке для работы, а значит если кто-то хочет пользоваться моей библиотекой, значит ему понадобится все, что нужно ей. Поэтому еще говорят, что test - это не транзитивный скоп, а compile - транзитивный, т.к. в первом случае test-зависимость косвенно не переносится на пользователя, а во втором - переносится. За остальные скопы говорить сложно, я не понимаю описание.

Резюмируя вышесказанное:

| scope    | в какой classpath добавляется? | как подтягивает транзитивные зависимости?                    |
| -------- | ------------------------------ | ------------------------------------------------------------ |
| compile  | compile, test, runtime         | compile as compile, runtime > runtime, test > x, provided > x |
| provided | compe, test                    | compile > provided, runtime > provided, test > x, provided > x |
| runtime  | test, runtime                  | compile > runtime, runtime > runtime, test > x, provided > x |
| test     | test                           | compile > test, runtime > test, test > x, provided > x       |

Третий столбец означает следующее: я пишу библиотеку, у меня есть зависимость Important, я даю ей скоп compile. Вася подключает мою библиотеку, дает ей скоп runtime и при этом для Васи моя зависимость Important получает скоп не compile, а runtime. Т.е. каждый скоп предполагает либо обрезку каких-то транзитивных зависимостей, либо их подтягивание с возможным изменением скопа. Как видно, все скопы предполагают игнорирование test- и provided- транзитивных зависимостей, а подтягивание только compile- и runtime-зависимостей. При этом compile тянет их без изменения, а provided, runtime и test превращают их в себя.

Короче говоря, тема невероятно мутная. Ну просто очень много каких-то недомолвок. Самое главное, что как-то проверить это, я не знаю как. Хорошо видно влияние некоторых скопов только при упаковке в исполнимый jar. В некоторых случаях зависимости включаются в итоговый артефакт, в некоторых - нет. Так что конечный вывод я могу сделать только исходя из умозрительных нужд:

* compile - ставим когда напрямую пользуемся классами библиотеки
* provided - когда пользуемся классами библиотеки + предполагаем, что эту библиотеку предоставит "запускатор" нашей программы. Типичный случай - когда пишем веб-приложение, которое будет крутиться на веб-сервере и соответственно у него эта библиотека есть
* runtime - не используем вообще этот скоп
* test - используем для библиотек, которые используются только в юнит-тестах

# Отладка

При запуске maven-проекта из консоли, можно через IDEA подключиться к процессу для отладки.

В maven уже есть дебаггер. Для его запуска надо вместо mvn набирать mvnDebug, например:

```java
mvnDebug exec:java -Dexec.mainClass="com.company.App"
```

При этом появится сообщение, что отладка запустилась на порте 8000.

В IDEA выполним немного настроек. Рядом с молотком есть пункт *AddConfiguration*:

1. Add Configuration  > Add new > Remote JVM Debug
2. Ввести имя, Host по умолчанию localhost, port поставить 8000

Дальше как обычная отладка - нажать жука и дебажить. Для повторной отладки нужно снова будет запустить ее через консоль.

# Терминология

► **POM** 

Project Obect Model - Объектная Модель Проекта. pom.xml - это основной файл конфигурации мэвин-проекта, которые содержит всю информацию, необходимую для сборки (build) проекта. Директория, в которой он лежит, является корнем проекта. В этом файле содержится список зависимостей, а также информация о проекте (его название, версия и groupId, пока хз что это такое) и другие настройки.

► **Artifact (Артефакт)**

В документации написано "An artifact is something that is either produced or used by a project. Examples of artifacts produced by Maven for a project include: JARs, source and binary distributions, WARs." "Нечто, что получается из проекта или используется проектом". Пока буду думать об артефакте как о .net-сборке. Потом думаю прояснится.

► **Phase, Goal (фаза, цель)**

мэвин разбивает процесс сборки проекта на "фазы", например вот такая цепочка:

```
validate > compile > test > package > verify > install > deploy (это все фазы)
```

А каждая фаза, в свою очередь, может состоять из нескольких "целей". Цели выполняют конкретные действия, в то время как фазы являются скорее логическими блоками для группировки целей. Вся эта схема образует Build Lifecycle. Есть несколько готовых BL'ов: default, clean, site. Из чего они состоят, можно посмотреть на офф сайте мэвина.



# Вопросы

## Как надежно настроить компиляцию из одной версии в другую?

И зачем вообще это нужно? Имеются ввиду опции компилятора:

```xml
<project>
    [...]
    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>
    [...]
</project>
```

```xml
<project>
    [...]
    <build>
        [...]
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
        </plugins>
        [...]
    </build>
    [...]
</project>
```

Вот тут же и написано https://maven.apache.org/plugins/maven-compiler-plugin/examples/set-compiler-source-and-target.html что надежность хромает.

И в чем вообще прикол? Я могу что ли писать на java 17, а компилировать так, чтобы работало на java 8 или что?



# Мини заметки

* SNAPSHOT в версии означает, что эта версия в разработке. Т.е. есть например версия 1.1.0, то сразу понятно, что она доработана. А если 1.1.0-SNAPSHOT, то значит она еще в разработке.
* В папке мавена conf есть файл settings.xml. Там много чего можно задать, в частности расположение локального репозитория (тег *localRepository*). По умолчанию он находится в папке пользователя, в скрытой директории .m2
* Репозитории бывают:
  * Локальный
  * Корпоративный
  * Центральный

# Черновик

## Сборка, фазы сборки

> Мавен базируется на концепции "жизненного цикла процесса сборки" (build lifecycle), который состоит из фаз (phases).

Сборка (build) - это процесс получения готовой "программы" из исходного кода. Только вместо "программа" говорят "артефакт", потому что это может быть не только какая-то запускаемая программа, но и библиотека, плюс она может включать в себя не только непосредственно "программу", то и разные дополнительные файлы. Одним словом, конечный результат может быть какой-то комплексной вещью и поэтому это корректнее будет назвать "продукт", а просто "программа" как-то мелковато. Поэтому и говорят "артефакт".

И вот этот процесс сборки разделяется на несколько этапов, шагов. Их называют в терминах мавена "фазами". Например, фаза компиляции, фаза запуска юнит-тестов, фаза упаковки скомпилированных файлов в какой-то определенный формат (например, в jar или war файл), фаза инсталляции (артефакт будет установлен в локальный репозиторий), фаза деплоя и т.д. Т.е. разных фаз довольно много. Все они представляют собой какие-то подзадачи, выполняемые в рамках сборки.

Процесс сборки можно организовать по-разному, комбинируя фазы. В мавене есть три готовых "шаблона" процесса сборки. Один из них называется *clean*, состоит из трех фаз: pre-clean, clean, post-clean. Как понятно из названия, предназначен для удаления результатов предыдущих запусков процесса сборки.

Другой шаблон называется *default* и состоит из следующих фаз (многие пропущены, выписаны некоторые просто для демонстрации): validate, compile, test, package, verify, install, deploy. Выполняются они последовательно. Можно выбрать одну фазу, и тогда выполнятся в том числе все, которые были до нее. Например, если вызвать package, то выполнятся validate, compile, test, package.

Можно запускать несколько фаз подряд, например:

```
mvn clean package
```

Некоторые фазы не принято запускать отдельно, например, pre-clean и прочие с подобные префиксами. Потому что они как правило содержат промежуточные результаты, бесполезные сами по себе, в отрыве от законченной фазы. Одним словом, сборка проекта организуется в весьма четкий процесс.

## Плагины, задачи и фазы

Сами фазы являются абстрактными шагами. Фактическая же реализация фаз содержится в *задачах плагинов*. Плагины содержат *задачи* (*goals*). Каждая задача может быть привязана к фазе и когда выполняется фаза, то выполняется и задача. Но можно выполнять задачу и отдельно. Если к фазе не привязано ни одной задачи, то фаза не выполняется (фаза ведь абстрактное понятие, а значит если к ней не привязано конкретных действий, то и выполнять нечего). К одной фазе можно привязать несколько задач, и выполняться они будут в том порядке, в каком указаны в POM.

??? Может быть надо scope указать для копирования файлов в артефакт?

??? Похоже дело было в том, что я добавил плагин в конец, а до этого шел maven-jar-plugin и мб он перетирал









## Подпроекты

В идее ПКМ по основному мавен-проекту и *New > Module*. Там выбираем maven-проект и в общем-то все. В итоге в корне основного мавен-проекта появляется папка с именем подпроекта. По структуре она аналогична обычному мавен-проекту, а базовый pom у нее вот такой:

```xml
<parent>
    <artifactId>parent-project</artifactId>
    <groupId>org.example</groupId>
    <version>1.0</version>
</parent>
<modelVersion>4.0.0</modelVersion>

<artifactId>childproj</artifactId>

<properties>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
</properties>
```

Т.е. просто указан родительский проект. А родительский pom, соответственно, вот такой:

```xml
<groupId>org.example</groupId>
<artifactId>parent-project</artifactId>
<packaging>pom</packaging>  <!-- Вот это важная штука -->
<version>1.0</version>
<modules>
    <module>childproj</module>
</modules>

<properties>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
</properties>
```

В родительский проект, вероятно, никакой код не пишется, поэтому директорию src вероятно удаляют.

Теперь, если в одном проекте требуется использовать типы из другого проекта, мы можем подключать их в pom в разделе dependencies, указывая groupId org.example, artifactId childproj.

Важно! При добавлении классов в подпроекты нужно вручную не забывать указывать имя глобального пакета, в данном случае org.example.

Но вообще надо бы отдельно почитать, ибо Сабурыч мутно рассказал как-то этот момент.