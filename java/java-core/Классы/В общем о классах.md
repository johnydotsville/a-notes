# Несколько фактов о классах

`.clone()` - метод для создания копии объекта. Его следует использовать для возврата из методов копий объектов, а не ссылок на объекты, чтобы их нельзя было изменить извне.

---

В файле может быть размещено несколько классов, но только один может быть public.

---

При компиляции файла А, если компилятор встречает использование класса В, то он ищет файл B.class и если не находит его, то заодно компилирует В. Если находит, но при этом видит, что файл B.java модифицирован позже, то он перекомпилирует В.

---

Если локальные переменные имеют такие же имена как поля класса, это приводит к трудноуловимым ошибкам.

---

`var` доступно с Java 10. Обычно не применяется к int, double и т.д., чтобы явно видеть различие между 1 или 1L например.

---

Обращение к null вызывает исключение типа `NullPointerException`.

---

В Java 9 появились методы

```java
name = Object.requireNonNullElse(name, “unknown”);
name = Object.requireNonNull(name, “Имя не может быть пустым”); // выбросит NullPointerException, если name == null
```

Еще есть requireNonNullElseGet и перегрузка с дженериками, но это уже отдельно посмотреть надо.

---

TODO??? Есть ли в Java встраиваемые методы и что это вообще такое? (Хорстман, Т1, с147)

---

Интересный факт - методы объекта имеют доступ к приватным полям не только “своего” объекта, но и других объектов *того же типа*:

```java
public class MyProgram
{
    public static void main(String[] args)
    {
        Employee vasya = new Employee();
        vasya.setName("Vasiliy");
        
        Employee petya = new Employee();
        petya.setName("Petr");
        
        String fused = vasya.some(petya);
        System.out.println(fused);
    }
}


class Employee {
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String some(Employee emp) { // Объект, получив в этот метот агрумент такого же типа,
        return this.name + " " + emp.name;  // сможет напрямую обращаться к приватному полю
    }
}

```

---

Статические методы можно использовать и на объектах, а не только на классах. Но делать этого не рекомендуется, поскольку приводит к путанице.

СМ широко используются для создания статических фабричных методов. Преимущества статических ФМ перед конструкторами в том, что имя конструктора должно совпадать с именем класса и возвращает всегда один тип - самого класса. А статический ФМ может иметь любое имя и возвращать разные типы.

Пример: класс `NumberFormat` и его статический ФМ `getCurrencyInstance()` и `getPercentInstance()`

---

Метод static void main(String[] args) можно добавить в любой класс, компилировать и запускать потом через java MyClassName, чтобы быстро протестировать.

---

## Передача по значению

В Java при передаче параметров методу всегда используется передача по значению. Т.е. значение исходной переменной копируется в параметр и все изменения параметра касаются только этого параметра. В случае передачи объекта это тоже справедливо - в параметр ссылка именно копируется и через параметр можно конечно же изменить состояние объекта, но например поменять ссылки на два объекта местами - нельзя:

```java
…
Employee emp1 = new Employee();
Employee emp2 = new Employee();

public static void swap(Employee a, Employee b) {
    Employee tmp = a;
    a = b;
    b = tmp;
}  // emp1 и emp2 останутся при своих
```

---

В сигнатуру метода входит имя и количество\типы параметров. Возвращаемый тип не входит.

---

Поля инициализируются по умолчанию (кроме final полей), переменные - нет. Для String значение по умолчанию null, а не пустая строка.

Инициализировать поля можно сразу при объявлении. Причем для этого можно использовать даже статический метод например, а не обязательно литерал.

---

Компилятор сам создает конструктор по умолчанию без аргументов. Если явно создать конструктор с аргументами, тогда компилятор не создаст дефолтный конструктор.

---

Вызвать из конструктора другой конструктор можно так:

```java
class Employee {
    public String name;
    public String who;
    
    public Employee(String name) {
        this.name = name;
    }
    
    public Employee(String name, String who) {
        this(name);  // <-- Вызов другого конструктора
        this.who = who;
    }
}
```

т.е. первым оператором конструктора идет `this(...)` с передачей нужных параметров и выбирается подходящий конструктор.

