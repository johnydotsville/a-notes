# Резюме

* Разные ограничители для дженерик-типа: класс, интерфейс
* Дженерик-методы в обычных классах
* Для ВМ дженериков не существует
* Стирание
* Мостовые (bridge) методы

# Синтаксис

## Простое объявление

```java
class SomeClass<T> {
    private T field;

    public SomeClass(T initValue) {
        this.field = initValue;
    }
    
    public void setField(T value) {
        this.field = value;
    }

    public T getField() {
        return this.field;
    }
}
...
SomeClass<String> sc = new SomeClass<String>("some init value");
SomeClass<String> sc = new SomeClass<>("some init value");
var sc = new SomeClass<String>("some init value");

sc.setField("Hello, generics!");
System.out.println(sc.getField());
```

## Несколько типов

Все то же самое, только используется больше одного типа:

```java
class SomeClass<T1, T2> {
    ...
}
...
SomeClass<String, Person> sc = new SomeClass<String, Person>();
SomeClass<String, Person> sc = new SomeClass<>();
var sc = new SomeClass<String, Person>();
```

## Дженерик-методы

В обычном классе можно сделать дженерик метод, обычный или статический:

```java
class SomeClass {
    public <T> T simpleReturn(T value) {
        return value;
    }

    public static <T> T staticSimpleReturn(T value) {
        return value;
    }
}
...
SomeClass sc = new SomeClass();
System.out.println(sc.simpleReturn("Hello, generic method!"));
System.out.println(SomeClass.staticSimpleReturn("Hello, static generic method!"));
// или так, с явным указанием типа
System.out.println(sc.<String>simpleReturn("Hello, generic method!"));
System.out.println(SomeClass.<String>staticSimpleReturn("Hello, static generic method!"));
```

Иногда компилятор может\не может самостоятельно вывести тип. Так что я бы пока все-таки пользовался явным указанием типа при вызове метода.

## Ввод ограничений на типы

### Простой пример

```java
class SomeClass<T extends A> {
    private T field;

    public SomeClass(T value) {
        this.field = value;
    }
}
...
SomeClass<A> sc = new SomeClass<A>(new A());
```

### Несколько теоретических моментов:

* Если в качестве ограничителей использовать только интерфейсы, то можно делать сколько угодно ограничений
* Если ограничитель является *классом*, то можно использовать только один класс (но после этого опять же, можно добавить сколько угодно интерфейсов)

```java
class A { }
class B { }
class C { }

interface IA { }
interface IB { }
interface IC { }

class SomeClass<T extends IA & IB & IC> { ... }  // Ok
class SomeClass<T extends A & IB & IC> { ... }  // Ok
class SomeClass<T extends A & B> { ... }  // Ошибка, в ограничениях мб только один класс
```

Такая запись `<T extends IA & IB & IC>` означает, что тип T должен реализовывать *все* эти интерфейсы, а не любой. Т.е. каждое последующее ограничение усиливает требования к типу.

### Продвинутый пример

Раз:

```java
class A implements IA, IB, IC { }
class B extends A { }
class C implements IA, IB, IC { }
class D implements IA { };

interface IA { }
interface IB { }
interface IC { }

class SomeClass<T extends IA & IB & IC> { ... }

SomeClass<D> sc = new SomeClass<D>(new D());  // Ошибка, D не реализует IB, IC
SomeClass<A> sc = new SomeClass<A>(new A());  // Ok
SomeClass<A> sc = new SomeClass<A>(new B());  // Ok, т.к. B наследник A
SomeClass<A> sc = new SomeClass<A>(new C());  // Ошибка, хоть C все реализует, но не явл. подтипом A
SomeClass<C> sc = new SomeClass<C>(new C());  // Ok
```

Два. Все то же самое, только в SomeClass первый ограничитель сменился с IA на класс A:

```java
class SomeClass<T extends A & IB & IC> { ... }

SomeClass<A> sc = new SomeClass<A>(new B());  // Ok
SomeClass<C> sc = new SomeClass<C>(new C());  // Ошибка, C не является подтипом A
```

# Теория

Дженерики появились в Java 5. До них использовался тип Object с приведением. Т.е. например класс ArrayList существовал уже тогда, просто у него внутри для элементов использовался тип Object.

Все написанное далее вероятно относится к задротству, которое понадобится только при возникновении реальных проблем, которые могут и не возникнуть. Но почему бы не копнуть, пока есть возможность.

## Стирание

После компиляции никаких дженериков не существует. Вместо обобщенного типа создается "сырой" (raw) тип, в котором вместо дженерик-типа подставляется Object, если нет ограничителей типа. Если они есть, тогда в качестве типа ставится *первый* ограничитель.

Грубо говоря:

```java
class Foo<T> {
    public T field;
}
=>
class Foo {
    public Object field;
}
...
class Foo<T extends IA, IB> {
    public T field;
}
=>
class Foo {
    public IA field;  // Используется первый ограничитель
}
```

Плюс производится приведение типов, например:

```java
class Foo<T> {
    public T getSome(T value) {
        T tmp = value;
        return tmp;
    }
}
=>
class Foo {
    public Object getSome(Object value) {
        Object tmp = value;
        return tmp;
    }
}
...
Foo<Person> foo = new Foo<Person>();
Person pers = new Person();
Person result = !(Person)!foo.getSome(pers);  // Автоприведение к чему надо, сейчас к Person
```

Т.е. суть в том, что во всех местах использования дженериков компилятор сам приводит к нужному типу. В данном случае getSome возвращает Object, а он приводит его к Person. Т.е. нам не надо писать явно (Person)foo.getSome(pers).

## Мостовые методы

Хорстман, Том 1, стр. 404

Это методы, которые генерируются автоматически для поддержки полиморфизма в случае использования дженериков.

Для объяснения потребуется:

```java
// Какой-то общий класс, для "абстрактной" пары значений
class Pair<T> {
    private T first;
    private T second;

    public T getFirst() {
        return this.first;
    }
    public void setFirst(T first) {
        this.first = first;
    }

    public T getSecond() {
        return this.second;
    }
    public void setSecond(T second) {
        this.second = second;
    }
}
```

```java
// Класс интервала дат, как раз использует класс Pair для хранения пары значений дат.
// Особенность в том, что вторая дата интервала не может быть меньше первой.
// Поэтому нужно переопределить сеттер второго значения.
class DateInterval extends Pair<LocalDate> {
    @Override
    public void setSecond(LocalDate second) {
        if (second.compareTo(getFirst()) >= 0) {
            super.setSecond(second);
        } else {
            throw new IllegalArgumentException("Incorrect second date");
        }
    }
}
```

```java
// Теперь используем эти типы
Pair<LocalDate> interval = new DateInterval();
interval.setFirst(LocalDate.of(2007, 9, 22));
interval.setSecond(LocalDate.of(2007, 9, 23));
```

В чем же хитрость?

В том, что поскольку в Pair не объявлен ограничитель типа, все T в нем станут Object. Т.е. метод setSecond в классе Pair станет таким:

```java
// class Pair
public void setSecond(Object second) { ... }
```

Значит, этот метод унаследуется классом DateInterval и у него будет *два* метода setSecond:

```java
// class DateInterval
public void setSecond(Object second) { this.second = second }  // Наследство от Pair
public void setSecond(LocalDate second) { ... }  // Собственный переопределенный
```

Поэтому когда выполняется строчка `interval.setSecond(LocalDate.of(2007, 9, 23));` происходит следующее:

* Хоть объект у нас DateInterval, но он лежит в ссылке типа Pair
* Значит должен быть вызван метод `setSecond(Object second)`, потому что ссылка типа Pair
* Но взят он должен быть из класса DateInterval, потому что реальный объект - типа DateInterval
* Получается, что переопределенный в DateInterval метод `setSecond(LocalDate second)` теряется во всей этой схеме

Чтобы выйти из этой ситуации, компилятор в классе DateInterval не просто скопирует метод `setSecond(Object second)` из суперкласса, а сделает его вот таким:

```java
// class DateInterval
public void setSecond(Object second) {
    setSecond((LocalDate)second);
}
```

Т.е. он приведет Object к LocalDate и вызовет setSecond, таким образом вызовется уже правильный setSecond, у которого параметр типа LocalDate.