# Резюме

* Стирание
* Разные ограничители для дженерик-типа: класс, интерфейс
* Дженерик-методы в обычных классах

# Теория

Дженерики появились в Java 5. До них использовался тип Object с приведением. Т.е. например класс ArrayList существовал уже тогда, просто у него внутри для элементов использовался тип Object. 

Стирание

# Синтаксис

## Простое объявление

```java
class SomeClass<T> {
    private T field;

    public SomeClass(T initValue) {
        this.field = initValue;
    }
    
    public void setField(T value) {
        this.field = value;
    }

    public T getField() {
        return this.field;
    }
}
...
SomeClass<String> sc = new SomeClass<String>("some init value");
SomeClass<String> sc = new SomeClass<>("some init value");
var sc = new SomeClass<String>("some init value");

sc.setField("Hello, generics!");
System.out.println(sc.getField());
```

## Несколько типов

Все то же самое, только используется больше одного типа:

```java
class SomeClass<T1, T2> {
    ...
}
...
SomeClass<String, Person> sc = new SomeClass<String, Person>();
SomeClass<String, Person> sc = new SomeClass<>();
var sc = new SomeClass<String, Person>();
```

## Дженерик-методы

В обычном классе можно сделать дженерик метод, обычный или статический:

```java
class SomeClass {
    public <T> T simpleReturn(T value) {
        return value;
    }

    public static <T> T staticSimpleReturn(T value) {
        return value;
    }
}
...
SomeClass sc = new SomeClass();
System.out.println(sc.simpleReturn("Hello, generic method!"));
System.out.println(SomeClass.staticSimpleReturn("Hello, static generic method!"));
// или так, с явным указанием типа
System.out.println(sc.<String>simpleReturn("Hello, generic method!"));
System.out.println(SomeClass.<String>staticSimpleReturn("Hello, static generic method!"));
```

Иногда компилятор может\не может самостоятельно вывести тип. Так что я бы пока все-таки пользовался явным указанием типа при вызове метода.

## Ввод ограничений на типы

### Простой пример

```java
class SomeClass<T extends A> {
    private T field;

    public SomeClass(T value) {
        this.field = value;
    }
}
...
SomeClass<A> sc = new SomeClass<A>(new A());
```

### Несколько теоретических моментов:

* Если в качестве ограничителей использовать только интерфейсы, то можно делать сколько угодно ограничений
* Если ограничитель является *классом*, то можно использовать только один класс (но после этого опять же, можно добавить сколько угодно интерфейсов)

```java
class A { }
class B { }
class C { }

interface IA { }
interface IB { }
interface IC { }

class SomeClass<T extends IA & IB & IC> { ... }  // Ok
class SomeClass<T extends A & IB & IC> { ... }  // Ok
class SomeClass<T extends A & B> { ... }  // Ошибка, в ограничениях мб только один класс
```

Такая запись `<T extends IA & IB & IC>` означает, что тип T должен реализовывать *все* эти интерфейсы, а не любой. Т.е. каждое последующее ограничение усиливает требования к типу.

### Продвинутый пример

Раз:

```java
class A implements IA, IB, IC { }
class B extends A { }
class C implements IA, IB, IC { }
class D implements IA { };

interface IA { }
interface IB { }
interface IC { }

class SomeClass<T extends IA & IB & IC> { ... }

SomeClass<D> sc = new SomeClass<D>(new D());  // Ошибка, D не реализует IB, IC
SomeClass<A> sc = new SomeClass<A>(new A());  // Ok
SomeClass<A> sc = new SomeClass<A>(new B());  // Ok, т.к. B наследник A
SomeClass<A> sc = new SomeClass<A>(new C());  // Ошибка, хоть C все реализует, но не явл. подтипом A
SomeClass<C> sc = new SomeClass<C>(new C());  // Ok
```

Два. Все то же самое, только в SomeClass первый ограничитель сменился с IA на класс A:

```java
class SomeClass<T extends A & IB & IC> { ... }

SomeClass<A> sc = new SomeClass<A>(new B());  // Ok
SomeClass<C> sc = new SomeClass<C>(new C());  // Ошибка, C не является подтипом A
```

