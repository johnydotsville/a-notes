# Резюме

* Интерфейсы Iterable, Iterator, Enumeration, разница между ними (forEach, forEachRemaining)
* Интерфейс Collection
* Абстрактный класс AbstractCollection
* LinkedList, ArrayList, Vector < Stack и их связь с интерфейсом RandomAccess
* Fail-fast и не fail-fast итераторы

# Схема интерфейсов

![coll_iface_base](img/coll_iface_base.svg)

Это основная схема. У некоторых интерфейсов могут быть и другие потомки, например, у Map еще есть ConcurrentMap, Bindings, LogicalMessageContext, но к базе это не относится. Для деталей - гугл с запросом "javadoc map" в помощь.

А еще здесь не написано про конкретные реализации этих интерфейсов, потому что этих реализаций очень много и есть смысл почитать о них отдельно и выбрать только актуальные для своих задач.

# Iterable

```java
public interface Iterable<T> {
    Iterator<T> iterator();
    void forEach(Consumer<? super T> action)
}
```

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    ---
    remove, forEachRemaining
}
```

Iterable подразумевает возможность обхода. Обходить коллекции можно циклом for:

```java
for (var item: MyData) {
    System.out.println(item);
}

// Компилятор развернет его в что-то вроде:
Iterator<SomeType> rator = MyData.iterator();
while (rator.hasNext()) {
    SomeType item = rator.next();
    System.out.println(item);
}
```

> Важно: порядок вывода элементов может не совпадать с порядком добавления. Это зависит от того, что под капотом коллекции. Если например это массив, то вывод будет совпадать с очередностью добавления. А если хэш-таблица, то может не совпадать.

## forEach и forEachRemaing

Принципиальная разница в том, что *forEach* - это метод Iterable, т.е. по сути метод коллекции. А *forEachRemaining* - это метод итератора Iterator. Т.е. у коллекции нет forEachRemaining, а у итератора нет forEach:

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);
arr.forEach(name -> System.out.println(name));
// Tom, Huck, Becky, Sid, Joe  // Подразумевает вывод всегда полностью, от начала до конца

Iterator<String> rator = arr.iterator();
if (rator.hasNext())
    rator.next();
rator.forEachRemaining(name -> System.out.println(name));
// Huck, Becky, Sid, Joe  // Вывод от текущей позиции итератора до конца
```

Без словоблудия сложно. Это вообще объяснять не надо, об этом надо подумать и прочувствовать. Используй силу, Люк!

*Итератор движется только вперед*, поэтому у него нет понятия "для каждого", у него есть только понятие "для каждого оставшегося". Для коллекции же есть только понятие набора ее элементов в целом, поэтому у нее нет концепции "оставшихся".

## remove

Это опять про Iterator и принцип его работы. При удалении производится удаление прочитанного элемента. Не какого-то произвольного по индексу или значению, а именно прочитанного, т.е. того, на который спозиционировались после вызова *.next()*. То есть перед вызовом .remove() обязательно вызывать .next():

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);

Iterator<String> rator = arr.iterator();
rator.next();
rator.remove();  // Удаляем Tom
// rator.remove();  // Ошибка! IllegalStateException, не вызвали сперва .next()
rator.next();
rator.remove();  // Удаляем Huck
```

## Iterator и Enumeration

Суть у них одинаковая - обходить коллекцию. Но:

* Интерфейс Enumeration считается устаревшим
* Имеет всего два метода: hasMoreElements и nextElement
* У него нет метода remove, т.е. это read-only итератор
* Он не *fail-fast*. Это означает, что если во время обхода коллекции в нее добавляются или удаляются элементы, то итератор никак на это не реагирует, потому что работает с копией коллекции, а не с оригиналом. *Fail-fast* итераторы, коим является Iterator, выбрасывают *ConcurrentModificationException*

TODO: вернуться потом подробнее

# Collection

```java
public interface Collection<E> 
    extends Iterable<E> {
        +.add();          +.size();         +.isEmpty();
        +.remove();       +.clear();        +.stream();
        +.removeAll();    +.contains();     +.spliterator()
        +.removeIf();     +.retainAll();    +.toArray();
}
```

* retainAll - `col1.retainAll(col2)` - в col1 оставит только те элементы, которые есть в col2. Остальные удалит.

Коллекция по сути умеет:

* Добавлять\удалять
* Определять, есть ли в ней указанный элемент
* Возвращать свой размер

# List

Для этого вида коллекций характерно следующее:

* Соблюдается порядок элементов. Т.е. в каком порядке добавили, в таком и прочитали.
* Произвольный доступ, т.е. можно получить элемент по индексу (актуальность под вопросом, т.к. производительность может быть очень плохой в зависимости от реализации. LinkedList поддерживает доступ по индексу, но пользоваться этой возможностью лучше не надо)

![list_branch](img/list_branch.svg)

Замечание: LinkedList еще реализует еще и другие интерфейсы, например, Queue. Оно и логично, ведь это список. Но для упрощения схемы это не показано тут. Поэтому конкретные реализации лучше разбирать отдельно и писать про них отдельно, т.к. они иногда плохо влазят в общую схему.

```java
public interface List<E> 
    extends Collection<E> {
        +.sort();       +.indexOf();
        +.get();        +.lastIndexOf();
        +.set();        +.replaceAll();
        +.subList();    +.removeRange();
}
```

Список умеет все то же, что и коллекция, плюс:

* Сортировать свои элементы
* Получать\устанавливать элемент по индексу
* Все, что может быть связано с индексацией: удалять промежуток, возвращать промежуток

Зачем AbstractCollection и AbstractList, если есть интерфейсы Collection и List? Если концептуально, то в абстрактных классах находится дефолтная реализация некоторых методов. Но почему бы ее не поместить тогда в интерфейсы, в дефолтную реализацию? Как минимум потому, что такая возможность появилась только в Java 8. 

## RandomAccess

Это абсолютно пустой интерфейс, нужный по сути для пометки, что коллекция поддерживает доступ по индексу. Этим интерфейсом помечены классы ArrayList и Vector < Stack.

# Set < SortedSet < NavigableSet

Для всех этих коллекций характерно следующее:

* Нет дублирующихся элементов (уникальность элемента определяется по методам equals и hashCode)

## Set

* Теоретически, Set может содержать null только один раз. Но каждая конкретная реализация может отличаться: в каких-то из них добавлять null вообще нельзя.
* Нужно с осторожностью добавлять в Set изменяемые объекты. Т.к. на момент добавления элемент может быть уникальным, но если его изменить, он может перестать быть уникальным и тогда поведение Set может быть непредсказуемым.
* Порядок элементов в Set не определен. Т.е. при чтении элементы вполне могут идти не в том порядке, в котором были добавлены.

```java
public interface Set<E>
	extends Collection<E> {
		// Ничего нового к методам Collection не добавляет
}
```

## SortedSet

* Поддерживает порядок элементов *по возрастанию*. Добавляемый элемент должен реализовать интерфейс Comparable, чтобы можно было сравнить его с другими и найти ему место.

```java
public interface SortedSet<E>
	extends Set<E> {
        +.comparator();    +.headSet();
        +.first();         +.tailSet();
        +.last();          +.subSet();
}
```

В этом интерфейсе появляются новые методы именно за счет наличия порядка среди элементов:

* first\last - первый\последний элемент

* headSet\tailSet - вернуть подмножество, элементы в котором младше\старше указанного. Например:

  ```java
  [1, 2, 3, 4, 5, 6, 7, 8]
  headSet(4) = [1, 2, 3]  // Сам элемент не входит
  tailSet(4) = [4, 5, 6, 7, 8]  // Здесь, включая сам элемент
  ```

  P.S. У конкретной реализации, например, TreeSet, в headSet есть второй параметр - включать или нет сам элемент. Но в общем интерфейсе такого параметра нет. Поэтому в таких случаях стоит помнить, что конкретные реализации могут иметь что-то собственное.

* subSet - вернуть подмножество между двумя элементами. Например:

  ```java
  [1, 2, 3, 4, 5, 6, 7, 8]
  subSet(4, 6) = [4, 5]
  ```

  Аналогичная ситуация и здесь. У TreeSet есть настройки включения\исключения элементов.

## NavigableSet

Это множество с более продвинутыми операциями поиска.

```java
public interface NavigableSet<E>
	extends SortedSet<E> {
        +.ceiling();    +.pollFirst();
        +.floor();      +.pollLast();
        +.higher();     +.descendingIterator();
        +.lower();      +.descendingSet();
}
```

Методы похожи на SortedSet, только более гибкие:

* ceiling\floor - вернуть *один* элемент, который больше\меньше (или равен) заданного. Если такого нет, возвращает null:

  ```java
  [10, 20, 32, 45, 56, 74]
  ceiling(6) = 10  // Т.к. первое число, больше 6, это 10
  floor(6) = null  // Т.к. меньше 6 нет элементов
  floor(15) = 10
  ```

* higher\lower - вернуть один элемент, который *строго* больше\меньше заданного. Если такого нет, возвращает null.

* descendingSet - возвращает то же множество, только элементы расположены по убыванию.

* pollFirst\pollLast - возвращает и удаляет младший\старший элемент.

В NavigableSet уже появляется возможность выставлять включение\исключение элемента при выборе подмножества.

## Queue < Deque

```java
public interface Queue<E>
	extends Collection<E> {
        +.element();    +.peek();
        +.offer();      +.poll();
}
```

```java
public interface Deque<E>
	extends Queue<E> {
        +.pop();                     +.getFirst();
        +.push();                    +.getLast();
        +.addFirst();                +.offerFirst();
        +.addLast();                 +.offerLast();
        +.removeFirst();             +.peekFirst();
        +.removeLast();              +.peekLast();
        +.removeFirstOccurence();    +.pollFirst();
        +.removeLastOccurence()      +.pollLast();
        +.descendingIterator();
}
```



