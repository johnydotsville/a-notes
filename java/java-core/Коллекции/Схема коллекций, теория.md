> Зачем это? Целью было не просто скопировать все методы из доки, а только характерные для каждого интерфейса, чтобы наглядно было видно, чем каждый потомок расширяет родителя и т.о. сформировать общее представление, зачем каждый интерфейс нужен и => для каких случаев подходят конкретные коллекции.
>
> Если метод не понятен - смотреть доку. Здесь не копипаста доки.
>
> P.S. Голубой - интерфейсы, Красный - абстрактные классы, Зеленый - конкретные классы.

# Резюме

* Интерфейсы Iterable, Iterator, Enumeration, разница между ними (forEach, forEachRemaining)
* Интерфейс Collection
* Абстрактный класс AbstractCollection
* Конкретные списки: LinkedList, ArrayList, Vector и Stack
* Fail-fast итераторы

TODO: вернуться сюда, когда освоюсь с простыми сценариями, и дописать наблюдения.

# Схема интерфейсов

![Iterable_shema](img/Iterable_shema.svg)

# Iterable

```java
public interface Iterable<T> {
    Iterator<T> iterator();
    void forEach(Consumer<? super T> action)
}
```

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    ---
    remove, forEachRemaining
}
```

Iterable подразумевает возможность обхода. Обходить коллекции можно циклом for:

```java
for (var item: MyData) {
    System.out.println(item);
}

// Компилятор развернет его в что-то вроде:
Iterator<SomeType> rator = MyData.iterator();
while (rator.hasNext()) {
    SomeType item = rator.next();
    System.out.println(item);
}
```

> Важно: порядок вывода элементов может не совпадать с порядком добавления. Это зависит от того, что под капотом коллекции. Если например это массив, то вывод будет совпадать с очередностью добавления. А если хэш-таблица, то может не совпадать.

## forEach и forEachRemaing

Принципиальная разница в том, что *forEach* - это метод Iterable, т.е. по сути метод коллекции. А *forEachRemaining* - это метод итератора Iterator. Т.е. у коллекции нет forEachRemaining, а у итератора нет forEach:

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);
arr.forEach(name -> System.out.println(name));
// Tom, Huck, Becky, Sid, Joe  // Подразумевает вывод всегда полностью, от начала до конца

Iterator<String> rator = arr.iterator();
if (rator.hasNext())
    rator.next();
rator.forEachRemaining(name -> System.out.println(name));
// Huck, Becky, Sid, Joe  // Вывод от текущей позиции итератора до конца
```

Без словоблудия сложно. Это вообще объяснять не надо, об этом надо подумать и прочувствовать. Используй силу, Люк!

*Итератор движется только вперед*, поэтому у него нет понятия "для каждого", у него есть только понятие "для каждого оставшегося". Для коллекции же есть только понятие набора ее элементов в целом, поэтому у нее нет концепции "оставшихся".

## remove

Это опять про Iterator и принцип его работы. При удалении производится удаление прочитанного элемента. Не какого-то произвольного по индексу или значению, а именно прочитанного, т.е. того, на который спозиционировались после вызова *.next()*. То есть перед вызовом .remove() обязательно вызывать .next():

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);

Iterator<String> rator = arr.iterator();
rator.next();
rator.remove();  // Удаляем Tom
// rator.remove();  // Ошибка! IllegalStateException, не вызвали сперва .next()
rator.next();
rator.remove();  // Удаляем Huck
```

## Iterator и Enumeration

Суть у них одинаковая - обходить коллекцию. Но:

* Интерфейс Enumeration считается устаревшим
* Имеет всего два метода: hasMoreElements и nextElement
* У него нет метода remove, т.е. это read-only итератор
* Он не *fail-fast*. Это означает, что если во время обхода коллекции в нее добавляются или удаляются элементы, то итератор никак на это не реагирует, потому что работает с копией коллекции, а не с оригиналом. *Fail-fast* итераторы, коим является Iterator, выбрасывают *ConcurrentModificationException*

TODO: вернуться потом подробнее

# Collection

```java
public interface Collection<E> 
    extends Iterable<E> {
        +.add();          +.size();         +.isEmpty();
        +.remove();       +.clear();        +.stream();
        +.removeAll();    +.contains();     +.spliterator()
        +.removeIf();     +.retainAll();    +.toArray();
}
```

* retainAll - `col1.retainAll(col2)` - в col1 оставит только те элементы, которые есть в col2. Остальные удалит.

Коллекция по сути умеет:

* Добавлять\удалять
* Определять, есть ли в ней указанный элемент
* Возвращать свой размер

## List

```java
public interface List<E> 
    extends Collection<E> {
        +.sort();       +.indexOf();
        +.get();        +.lastIndexOf();
        +.set();        +.replaceAll();
        +.subList();    +.removeRange();
}
```

![list_branch](img/list_branch.svg)

Список умеет все то же, что и коллекция, плюс:

* Сортировать свои элементы
* Получать\устанавливать элемент по индексу
* Все, что может быть связано с индексацией: удалять промежуток, возвращать промежуток

Зачем AbstractCollection и AbstractList, если есть интерфейсы Collection и List? Если концептуально, то в абстрактных классах находится дефолтная реализация некоторых методов. Но почему бы ее не поместить тогда в интерфейсы, в дефолтную реализацию? Как минимум потому, что такая возможность появилась только в Java 8. 

### RandomAccess

Это абсолютно пустой интерфейс, нужный по сути для пометки, что коллекция поддерживает доступ по индексу.

## Set < SortedSet < NavigableSet

```java
public interface Set<E>
	extends Collection<E> {
		// Ничего нового к методам Collection не добавляет
}
```

```java
public interface SortedSet<E>
	extends Set<E> {
        +.comparator();    +.headSet();
        +.first();         +.tailSet();
        +.last();          +.subSet();
}
```

```java
public interface NavigableSet<E>
	extends SortedSet<E> {
        +.ceiling();    +.pollFirst();
        +.floor();      +.pollLast();
        +.higher();     +.descendingIterator();
        +.lower();      +.descendingSet();
}
```

## Queue < Deque

```java
public interface Queue<E>
	extends Collection<E> {
        +.element();    +.peek();
        +.offer();      +.poll();
}
```

```java
public interface Deque<E>
	extends Queue<E> {
        +.pop();                     +.getFirst();
        +.push();                    +.getLast();
        +.addFirst();                +.offerFirst();
        +.addLast();                 +.offerLast();
        +.removeFirst();             +.peekFirst();
        +.removeLast();              +.peekLast();
        +.removeFirstOccurence();    +.pollFirst();
        +.removeLastOccurence()      +.pollLast();
        +.descendingIterator();
}
```



