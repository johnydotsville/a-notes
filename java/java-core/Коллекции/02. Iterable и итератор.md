# Iterable и итератор

Назначение итератора - предоставить единый интерфейс для обхода любой коллекции, не смотря на то, как она устроена под капотом.

```java
public interface Iterable<T> {
    Iterator<T> iterator();
    void forEach(Consumer<? super T> action)
}
```

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    ---
    remove, forEachRemaining
}
```

Iterable подразумевает возможность обхода. Обходить коллекции можно циклом for:

```java
for (var item: myData) {
    System.out.println(item);
}

// Компилятор развернет его в что-то вроде:
Iterator<SomeType> rator = myData.iterator();
while (rator.hasNext()) {
    SomeType item = rator.next();
    System.out.println(item);
}
```

> Важно: порядок вывода элементов может не совпадать с порядком добавления. Это зависит от того, что под капотом коллекции. Если например это массив, то вывод будет совпадать с очередностью добавления. А если хэш-таблица, то может не совпадать.

## forEach и forEachRemaing

Принципиальная разница в том, что *forEach* - это метод Iterable, т.е. по сути метод коллекции. А *forEachRemaining* - это метод итератора Iterator. Т.е. у коллекции нет forEachRemaining, а у итератора нет forEach:

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);
arr.forEach(name -> System.out.println(name));
// Tom, Huck, Becky, Sid, Joe  // Подразумевает вывод всегда полностью, от начала до конца

Iterator<String> rator = arr.iterator();
if (rator.hasNext())
    rator.next();
rator.forEachRemaining(name -> System.out.println(name));
// Huck, Becky, Sid, Joe  // Вывод от текущей позиции итератора до конца
```

Без словоблудия сложно. Это вообще объяснять не надо, об этом надо подумать и прочувствовать. Используй силу, Люк!

*Итератор движется только вперед*, поэтому у него нет понятия "для каждого", у него есть только понятие "для каждого оставшегося". Для коллекции же есть только понятие набора ее элементов в целом, поэтому у нее нет концепции "оставшихся".

## remove

Это опять про Iterator и принцип его работы. При удалении производится удаление прочитанного элемента. Не какого-то произвольного по индексу или значению, а именно прочитанного, т.е. того, на который спозиционировались после вызова *.next()*. То есть перед вызовом .remove() обязательно вызывать .next():

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);

Iterator<String> rator = arr.iterator();
rator.next();
rator.remove();  // Удаляем Tom
// rator.remove();  // Ошибка! IllegalStateException, не вызвали сперва .next()
rator.next();
rator.remove();  // Удаляем Huck
```

# Iterator и Enumeration

Суть у них одинаковая - обходить коллекцию. Но:

* Интерфейс Enumeration считается устаревшим
* Имеет всего два метода: hasMoreElements и nextElement
* У него нет метода remove, т.е. это read-only итератор
* Он не *fail-fast*. Это означает, что если во время обхода коллекции в нее добавляются или удаляются элементы, то итератор никак на это не реагирует, потому что работает с копией коллекции, а не с оригиналом. *Fail-fast* итераторы, коим является Iterator, выбрасывают *ConcurrentModificationException*

# Fail-fast

Fail-fast-итератор это такой итератор, который выбрасывает исключение *ConcurrentModificationException*, когда обнаруживает структурное изменение коллекции извне. Работает это примерно так:

* Есть коллекция К, с которой работают поток П1 и П2
* Чтобы обходить коллекцию, требуется создать итератор. На каждый обход создается отдельный итератор
* В П1 создается итератор И1 и начинается обход коллекции
* В П2 создается итератор И2, тоже начинается обход и, например, в какой-то момент некоторый элемент удаляется из коллекции
* И1 выбрасывает исключение

Структурным изменением считается удаление\добавление элемента\изменение размерности коллекции. Но простая замена одного значения на другое не является структурным изменением.