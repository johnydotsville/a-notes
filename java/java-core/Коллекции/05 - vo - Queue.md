# Вопросы

- [ ] Есть ли концептуальные отличия и отличия в эффективности между классами ArrayDeque и LinkedList, если использовать их как очередь и стек?
  - [ ] Кто потребляет больше памяти?
  - [ ] Почему у ArrayList преимущества перед LinkedList при добавлении\удалении элементов на концах очереди, хотя в основе лежит массив?
- [ ] По какому принципу элементы добавляются в PriorityQueue?
  - [ ] Как эта реализация очереди связана с интерфейсами Comparable и Comparator и понятием natural ordering?
  - [ ] В начале очереди оказываются младшие или старшие элементы?
  - [ ] Гарантируется ли порядок извлечения, если в начале очереди оказываются несколько элементов с одинаковым порядком?
  - [ ] При обходе очереди через обычный итератор, можно ли быть уверенным, что элементы будут получены в правильной последовательности? Если нет, как тогда нужно получать элементы?

# Queue

![coll_iface_concrete_queue.drawio](img/coll_iface_concrete_queue.drawio.svg)

```java
public interface Queue<E>
	extends Collection<E> {
        // Добавление в конец очереди
        +.add(E)
        +.offer(E);

        // Взять элемент из начала очереди (без удаления)
        +.element();    
        +.peek();
    
        // Взять элемент из начала очереди (с удалением)
        +.poll();
        +.remove();
}
```

```java
public interface Deque<E>
	extends Queue<E> {
        // Функционал стека
        +.push();  // Добавить в НАЧАЛО (addFirst(e); внутри)
        +.pop();   // Извлечь из НАЧАЛА (removeFirst(); внутри) с удалением
    
        // Функционал очереди
        +.offerFirst();  // Добавление
        +.offerLast();
        +.peekFirst();  // Извлечение
        +.peekLast();   // peek - без удаления, poll - с удалением
        +.pollFirst();  
        +.pollLast();
    
        +.getFirst();  // Остальное понятно из названий
        +.getLast();
        +.addFirst();
        +.addLast();
        +.removeFirst();
        +.removeLast();
        +.removeFirstOccurence();
        +.removeLastOccurence();
    
        +.descendingIterator();
}
```

# Представители

## ArrayDeque и LinkedList

В общем случае ArrayDeque предподчительнее. Из официальной документации:

* `ArrayDeque` эффективнее, чем `LinkedList` при добавлении и удалении элементов в начале и в конце
* `LinkedList` хорош для удаления текущего элемента при итерации, но не очень хорош для самой итерации
* `LinkedList` потребляет больше памяти, чем `ArrayDeque`

## PriorityQueue

[Документация](https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)

При добавлении в эту очередь, новый элемент встает не в конец, а в позицию, которая соответствует его приоритету. Приоритет определяется согласно natural ordering, т.е. хранимые объекты должны реализовать интерфейс Comparable, либо в очередь при создании нужно передать компаратор.

> Важный момент: при обычном обходе коллекции через for можно обнаружить, что элементы выводятся не в natural ordering, а как-то по-своему. Все потому что если нужен именно natural-порядок, то и обходить коллекцию надо как очередь - через извлечение элементов, например, методом poll
>
> UPD. Не на всяком примере это можно сразу заметить, но это так.

```java
Comparator<Person> personComparator = (Person p1, Person p2)
                -> Integer.compare(p1.getAge(), p2.getAge());

Queue<Person> queue = new PriorityQueue<>(personComparator);

Person tom = new Person("Tom Sawyer", 14);
Person huck = new Person("Huck Finn", 14);
Person mary = new Person("Mary Sawyer", 17);

queue.add(mary);  // Мэри окажется в конце очереди, хотя добавлена первой
queue.add(tom);
queue.add(huck);
```

В начало очереди попадают *меньшие* элементы. Если оказывается несколько одинаковых меньших элементов, то порядок извлечения не гарантируется (хотя у меня на многих запусках порядок соблюдался - по очередности добавления, т.е. Том всегда был впереди Гека, хотя обоим по 14 лет)