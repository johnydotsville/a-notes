Ппц вся эта тема себя скомпроментировала. Такая мешанина получилась.

# Резюме

* Интерфейсы Iterable, Iterator, Enumeration, разница между ними (forEach, forEachRemaining)
* Интерфейс Collection
* Абстрактный класс AbstractCollection
* LinkedList, ArrayList, Vector < Stack и их связь с интерфейсом RandomAccess
* Fail-fast и не fail-fast итераторы
* Дерево, хэш-таблица

# Структуры данных

Тут может быть ложь, пиздеж и провокация. Целью было просто понять самую суть структур, минимум для представления, без деталей, если они не нужны для понимания практического применения.

## Список

Здесь понятно

## Деревья

*Дерево* - это структура данных, в которой у каждого элемента мб 0..n подэлементов. Да, именно несколько, а не обязательно только 2. У такого "обычного" дерева только одно требование - у каждого элемента мб только один родитель.

*Двоичное (бинарное) дерево* - это дерево, у которого:

* У каждого элемента не более двух детей
* "Левые" дети всегда меньше родителя, а "правые" дети - всегда больше родителя

*Сбалансированное дерево (B-дерево)* - это дерево, у которого высота левого и правого поддеревьев отличается не более чем на 1.

*Красно-черное дерево* - это подвид сбалансированного дерева. КЧ-дерево является двоичным. Тут высота может быть считается как-то по-другому, судя по картинкам не всегда разница между ветками в высоту равняется 1, но суть в том, что оно все-таки сбалансированное, т.е. поиск в нем происходит быстрее, чем если оно было несбалансированным. Ну а все остальные принципы у него как у двоичного дерева, т.е. левые - меньше, правые - больше, и только по два ребенка у родителя.

## Хэш-таблица

Хэш-таблица - используется, когда требуются быстрые вставка\удаление\поиск. Ее особенностью является отсутствие определенного порядка хранения элемента. Позиция элемента вычисляется путем пропускания элемента через хэш-функцию, которая и возвращает позицию для элемента (например, индекс массива или где она там непосредственно хранится). 

Для разных элементов хэш-функция может вернуть одинаковые хэш-коды, это называется коллизией. Хорошие ХФ минимизируют количество коллизий, но тем не менее это факт. Ввиду однозначного соответствия элемента и его позиции (в большинстве случаев), скорость добавления, удаления и поиска элементов равна O(1), т.е. мгновенная. В худшем случае O(n).

С хэш-таблицей связаны несколько терминов:

* Bucket - это собственно "место, где хранится элемент". Например, индекс массива. Видел объяснение как "fast-access location". Можно также обозвать bucket словом "слот". В одном слоте может храниться и несколько элементов.
* Capacity - это текущее количество бакетов, "слотов" в хэш-таблице.
* Initial capacity - это количество слотов на момент создания хэш-таблицы.
* Load factor - это число, которое показывает, насколько допустимо заполнить таблицу до проведения перехэширования. Выражается отношением `m/n`, где m - текущая заполненность, а n - общее количество слотов ("размер таблицы"). Дефолтное значение load factor примерно 0.75. Пример: пусть всего у нас будет 15 слотов. 11/15=0.73, а 12/15=0.8 Это значит, что когда в таблице окажется двенадцать элементов, будет проведено перехэширование. Т.е. выделится массив в два раза больше текущего, для каждого элемента повторно вычислится хэш-функция и элементы займут свои места в новом массиве.

## Выводы

Выводы личные, так что за точность пока не ручаюсь. Характеристики относительно друг друга. Т.е. "медленные" не значит, что они прямо медленные-медленные, а просто медленнее, чем в других структурах.

|             | Вставка\удаление                                             | Поиск                                                        | Доп. характеристики |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------- |
| Список      | Быстрые, потому что не надо никаких хэш-функций считать или искать место для вставки. Приделал элемент в хвост и готово. | Медленный, т.к. надо посмотреть все элементы от начала до конца, ибо 0 логики при вставке. |                     |
| Хэш-таблица | Средние, потому что нужно считать хэш-функцию, чтобы найти позицию для элемента. | Быстрый. Хотя и нужно посчитать хэш-функцию, но это вероятно быстрее, чем например обойти дерево. |                     |
| Дерево      | Медленные, потому что раз элементы упорядочены, то надо этот порядок постоянно поддерживать. | Средний, потому что все-таки нужно обходить дерево. Конечно обходить надо меньше элементов, чем в списке, но все же вычислить хэш-функцию вероятно будет побыстрее. Поэтому средний. |                     |



# Схема интерфейсов









