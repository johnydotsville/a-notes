# Set

![coll_iface_concrete_set.drawio](img/coll_iface_concrete_set.drawio.svg)

## В двух словах

Set - это "множество из математики", а множество не может содержать два одинаковых элемента. Следовательно, используй Set, если:

* Нужен набор *без повторяющихся элементов*. Если попробовать добавить повторяющийся элемент, он просто не добавится, исключений не возникнет.

При этом:

* Порядок элементов не важен? Используй HashSet
* Хочешь, чтобы элементы шли в том порядке, в котором добавляешь? Используй LinkedHashSet
* Хочешь, чтобы элементы были отсортированы и можно было делать всякое вроде "найти элементы больше такого-то"? Используй TreeSet
* В HashSet и LinkedHashSet можно добавить null, в TreeSet - нельзя, будет исключение

## Интерфейс Set

* Нужно с осторожностью добавлять в Set изменяемые объекты. Т.к. на момент добавления элемент может быть уникальным, но если его изменить, он может перестать быть уникальным и тогда поведение Set может быть непредсказуемым.

```java
public interface Set<E>
	extends Collection<E> {
		// Ничего нового к методам Collection не добавляет
}
```

## Интерфейс SortedSet

* Поддерживает порядок элементов *по возрастанию*. Добавляемый элемент должен реализовать интерфейс Comparable, чтобы можно было сравнить его с другими и найти ему место.

```java
public interface SortedSet<E>
	extends Set<E> {
        +.comparator();    +.headSet();
        +.first();         +.tailSet();
        +.last();          +.subSet();
}
```

В этом интерфейсе появляются новые методы именно за счет наличия порядка среди элементов:

* first\last - первый\последний элемент

* headSet\tailSet - вернуть подмножество, элементы в котором младше\старше указанного. Например:

  ```java
  [1, 2, 3, 4, 5, 6, 7, 8]
  headSet(4) = [1, 2, 3]  // Сам элемент не входит
  tailSet(4) = [4, 5, 6, 7, 8]  // Здесь, включая сам элемент
  ```

  P.S. У конкретной реализации, например, TreeSet, в headSet есть второй параметр - включать или нет сам элемент. Но в общем интерфейсе такого параметра нет. Поэтому в таких случаях стоит помнить, что конкретные реализации могут иметь что-то собственное.

* subSet - вернуть подмножество между двумя элементами. Например:

  ```java
  [1, 2, 3, 4, 5, 6, 7, 8]
  subSet(4, 6) = [4, 5]
  ```

  Аналогичная ситуация и здесь. У TreeSet есть настройки включения\исключения элементов.

## Интерфейс NavigableSet

Это множество с более продвинутыми операциями поиска.

```java
public interface NavigableSet<E>
	extends SortedSet<E> {
        +.ceiling();    +.pollFirst();
        +.floor();      +.pollLast();
        +.higher();     +.descendingIterator();
        +.lower();      +.descendingSet();
}
```

Методы похожи на SortedSet, только более гибкие:

* ceiling\floor - вернуть *один* элемент, который больше\меньше (или равен) заданного. Если такого нет, возвращает null:

  ```java
  [10, 20, 32, 45, 56, 74]
  ceiling(6) = 10  // Т.к. первое число, больше 6, это 10
  floor(6) = null  // Т.к. меньше 6 нет элементов
  floor(15) = 10
  ```

* higher\lower - вернуть один элемент, который *строго* больше\меньше заданного. Если такого нет, возвращает null.

* descendingSet - возвращает то же множество, только элементы расположены по убыванию.

* pollFirst\pollLast - возвращает и удаляет младший\старший элемент.

В NavigableSet уже появляется возможность выставлять включение\исключение элемента при выборе подмножества.

# Представители

??? Для сетов, похоже, важна емкость и коэффициент загрузки. Интересно, как они связаны? Допустим, емкость 100, что это значит? Что может быть добавлено только 100 элементов? И что такое коэффициент загрузки?

## HashSet

Реализует интерфейс Set. Логически основан на принципе хэш-таблицы, фактически базируется на HashMap. Порядок итерации не подчиняется никаким правилам и со временем может измениться. Разрешается вставлять null. Обеспечивает постоянное время к операциями добавления, удаления, поиска и определения размера.

??? Если производительность обхода важна, нельзя задавать слишком большую изначальную емкость и также нужно чтобы заполненность не была слишком низкой. Прикол в том, что здесь, похоже, "размер" структуры как минимум равен емкости. Т.е. если емкость 100 элементов, а фактически добавлено 15, то обход этих 15 будет занимать времени как обход всей 100.

Реализация не синхронизирована. Итераторы являются fail-fast.

## LinkedHashSet

Реализует интерфейс Set. Допускает null. Поддерживает порядок итерации - как добавили, так и обошли. Дает постоянное время для вставки, удаления, поиска. Обход занимает ровно столько времени, сколько фактически содержится элементов, за счет того, что это все-таки список.

## TreeSet

Базируется на TreeMap. Реализует интерфейс NavigableSet. Обеспечивает добавление, удаление, поиск за log(n). Порядок элементов - так называемый natural ordering (т.е. похоже должна быть реализация метода, позволяющего сравнивать элементы) или определяемая через переданный компаратор.