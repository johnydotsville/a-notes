# Queue

![coll_iface_concrete_queue.drawio](img/coll_iface_concrete_queue.drawio.svg)

```java
public interface Queue<E>
	extends Collection<E> {
        // Добавление в конец очереди
        +.add(E)
        +.offer(E);

        // Взять элемент из начала очереди (без удаления)
        +.element();    
        +.peek();
    
        // Взять элемент из начала очереди (удалением)
        +.poll();
        +.remove();
}
```

```java
public interface Deque<E>
	extends Queue<E> {
        // Функционал стека
        +.push();  // Добавить в НАЧАЛО (addFirst(e); внутри)
        +.pop();   // Извлечь из НАЧАЛА (removeFirst(); внутри) с удалением
    
        // Функционал очереди
        +.offerFirst();  // Добавление
        +.offerLast();
        +.peekFirst();  // Извлечение
        +.peekLast();   // peek - без удаления, poll - с удалением
        +.pollFirst();  
        +.pollLast();
    
        +.getFirst();  // Остальное понятно из названий
        +.getLast();
        +.addFirst();
        +.addLast();
        +.removeFirst();
        +.removeLast();
        +.removeFirstOccurence();
        +.removeLastOccurence();
    
        +.descendingIterator();
}
```

# Представители

## ArrayDeque и LinkedList

В общем случае ArrayDeque предподчительнее. Из официальной документации:

* In terms of efficiency, `ArrayDeque` is more efficient than the `LinkedList` for add and remove operation at both ends
* The best operation in a `LinkedList` implementation is removing  the current element during the iteration. `LinkedList` implementations are not ideal structures to iterate
* The `LinkedList` implementation consumes more memory than the `ArrayDeque` implementation

## PriorityQueue

В этой очереди используется natural ordering. Можно при создании передать компаратор или полагаться на реализацию интерфейса Comparable хранимыми элементами.

> Важный момент: при обычном обходе коллекции через for можно обнаружить, что элементы выводятся не в natural ordering, а как-то по-своему. Все потому что если нужен именно natural-порядок, то и обходить коллекцию надо как очередь - через извлечение элементов, например, методом poll