# Коллекции

## Резюме

* Интерфейс Collection
* Абстрактный класс AbstractCollection
* Интерфейсы Iterable, Iterator, Enumeration, разница между ними
* Fail-fast итераторы

## Интерфейсы Collection, Iterable, Iterator

У всех коллекций базовый интерфейс `Collection` из java.util

Примерный вид, основные методы и важные связанные сущности в виде гномика:

```java
import java.util.Collection;

// https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html
public interface Collection<E> extends Iterable<E> {
    bool add(E item);
    Iterator<T> iterator();
    ---
    addAll, clear, contains, isEmpty, remove, size, toArray
    stream, parallelStream
}

// https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html
public interface Iterable<T> {
    Iterator<T> iterator();
    void forEach(Consumer<? super T> action)
}

// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html
public interface Iterator<E> {
    boolean hasNext();
    E next();
    ---
    remove, forEachRemaining
}
```

## Класс AbstractCollection

```java
import java.util.AbstractCollection;

public abstract class AbstractCollection<E>
	extends Object
	implements Collection<E>
```

Базовый класс для всех других коллекций:

* Реализует некоторые служебные методы из интерфейса Collection (contains, toArray, remove и т.д.)
* Имеет абстрактные методы *.iterator()* и *.size()*, чтобы потомки сами озаботились об алгоритмах обхода

## Обход

Обходить коллекции можно циклом for:

```java
for (var item: MyData) {
    System.out.println(item);
}

// Компилятор развернет его в что-то вроде:
Iterator<SomeType> rator = MyData.iterator();
while (rator.hasNext()) {
    SomeType item = rator.next();
    System.out.println(item);
}
```

> Важно: порядок вывода элементов может не совпадать с порядком добавления. Это зависит от того, что под капотом коллекции. Если например это массив, то вывод будет совпадать с очередностью добавления. А если хэш-таблица, то может не совпадать.

## forEach и forEachRemaing

Принципиальная разница в том, что *forEach* - это метод Iterable, т.е. по сути метод коллекции. А *forEachRemaining* - это метод итератора Iterator. Т.е. у коллекции нет forEachRemaining, а у итератора нет forEach:

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);
arr.forEach(name -> System.out.println(name));
// Tom, Huck, Becky, Sid, Joe  // Подразумевает вывод всегда полностью, от начала до конца

Iterator<String> rator = arr.iterator();
if (rator.hasNext())
    rator.next();
rator.forEachRemaining(name -> System.out.println(name));
// Huck, Becky, Sid, Joe  // Вывод от текущей позиции итератора до конца
```

Без словоблудия сложно. Это вообще объяснять не надо, об этом надо подумать и прочувствовать. Используй силу, Люк!

*Итератор движется только вперед*, поэтому у него нет понятия "для каждого", у него есть только понятие "для каждого оставшегося". Для коллекции же есть только понятие набора ее элементов в целом, поэтому у нее нет концепции "оставшихся".

## remove

Это опять про Iterator и принцип его работы. При удалении производится удаление прочитанного элемента. Не какого-то произвольного по индексу или значению, а именно прочитанного, т.е. того, на который спозиционировались после вызова *.next()*. То есть перед вызовом .remove() обязательно вызывать .next():

```java
ArrayList<String> arr = new ArrayList<>(
    Arrays.asList("Tom", "Huck", "Becky", "Sid", "Joe")
);

Iterator<String> rator = arr.iterator();
rator.next();
rator.remove();  // Удаляем Tom
// rator.remove();  // Ошибка! IllegalStateException, не вызвали сперва .next()
rator.next();
rator.remove();  // Удаляем Huck
```

## Iterator и Enumeration

Суть у них одинаковая - обходить коллекцию. Но:

* Интерфейс Enumeration считается устаревшим
* Имеет всего два метода: hasMoreElements и nextElement
* У него нет метода remove, т.е. это read-only итератор
* Он не *fail-fast*. Это означает, что если во время обхода коллекции в нее добавляются или удаляются элементы, то итератор никак на это не реагирует, потому что работает с копией коллекции, а не с оригиналом. *Fail-fast* итераторы, коим является Iterator, выбрасывают *ConcurrentModificationException*

TODO: вернуться потом подробнее

## Карта интерфейсов

<img src="img/Карта интерфейсов коллекций.png" alt="Карта интерфейсов коллекций" style="zoom:80%;" />

TODO: вернуться сюда с большим пониманием внутреннего устройства конкретных коллекций (на массиве, на списке) и оставить резюме по каждому виду.