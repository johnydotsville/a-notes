* Создание потоков

  Предпочтительнее через реализацию интерфейса Runnable



Callable, Runnable

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные  им потоки, система будет ждать их завершения. Однако это правило не относится к особому виду потоков – демонам. Если  завершился последний обычный поток процесса, и остались только  потоки-демоны, то они будут принудительно завершены и выполнение  процесса закончится. Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод **`setDaemon(true)`**;
 Проверить, является ли поток демоном, можно вызвав его метод **`boolean isDaemon()`**;

Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого  потока. 

ключевое слово volatile (изменчивый, не постоянный). Его необходимо  использовать для переменных, которые используются разными потоками. Это  связано с тем, что значение переменной, объявленной без volatile, может  кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.

> Что за кэширование?

Как видите, мы избавились от метода finish() и реализовали тот же  механизм завершения потока с помощью встроенной системы прерываний. В  этой реализации мы получили одно преимущество — метод sleep() вернет  управление (сгенерирует исключение) незамедлительно после прерывания  потока. Заметьте что методы sleep() и join() обёрнуты в конструкции try-catch.  Это необходимое условие работы этих методов. Вызывающий их код должен  перехватывать исключение InterruptedException, которое они бросают при  прерывании во время ожидания.

Статический метод Thread.yield() заставляет процессор переключиться на  обработку других потоков системы. Метод может быть полезным, например,  когда поток ожидает наступления какого-либо события и необходимо чтобы  проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл:



```
//Ожидание поступления сообщения
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}
```

Метод join() имеет перегруженную версию, которая получает в качестве  параметра время ожидания. В этом случае join() возвращает управление  либо когда завершится ожидаемый поток, либо когда закончится время  ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.

Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое  число в объекте потока, более высокое значение которого означает больший приоритет. Система в первую очередь выполняет потоки с большим  приоритетом, а потоки с меньшим приоритетом получают процессорное время  только тогда, когда их более привилегированные собратья простаивают.

Синхронизация потоков — тема, не изучив которую, программировать правильные многопоточные приложения не получится. 

