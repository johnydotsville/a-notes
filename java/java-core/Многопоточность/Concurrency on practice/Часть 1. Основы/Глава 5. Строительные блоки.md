# 5.1  Syncronized collection

Синхронизированные коллекции включают в себя Vector и Hashtable, а также разные синхронизированные обертки, получаемые с помощью фабричных методов Collections.syncronizedXxx. В этих классах ПБ достигается за счет инкапсуляции состояния и объявление всех публичных методов синхронизированными, так что только один поток за раз может работать с состоянием.

## 5.1.1 Problems with syncronized collections

Проблемы синхронизированных коллекций (СхК).

СхК являются ПБ, но иногда может требоваться дополнительная блокировка в клиентском коде, чтобы защитить составные действия, такие как итерация, навигация (поиск элемента за каким-то элементом по заданному условию) и операции по условию ("проверь-потом-действуй", например "добавить, если отсутствует"). Технически, СхК остаются ПБ и без дополнительных клиентских блокировок, однако могут вести себя не так, как вы ожидаете, в случае конкурентной модификации. Пример:

```java
public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}

public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
...
for (int i = 0; i < vector.size(); i++)
    doSomething(vector.get(i));
```

Проблема в том, что при вызове getLast может произойти разрыв между вычислением индекса последнего элемента и собственно извлечением элемента. В этот разрыв другой поток может удалить последний элемент и тогда getLast приведет к исключению ArrayIndexOutOfBoundsException. Аналогично и с итерацией.

Добавление клиентского замка решает проблему:

```java
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}

public static void deleteLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }   
}
...
synchronized (vector) {
    for (int i = 0; i < vector.size(); i++)
        doSomething(vector.get(i));
}
```

## 5.1.2 Iterators and ConcurrentModificationException

Мы использовали Vector в примерах для понятности, хотя он считается устаревшим классом коллекции. Но даже более современные коллекции не решают проблему составных действий. Стандартный способ обхода коллекций - это использовать Iterator, либо явно, либо через "for-each" синтаксис, появившийся в Java 5.0 Итераторы не избавляют нас от необходимости блокировать коллекции на время обхода в случае, если другие потоки могут конкурентно вносить изменения в коллекцию. Синхронизированные коллекции не рассчитаны на конкурентную модификацию и возвращают fail-fast итераторы. Это такие итераторы, которые выбрасывают исключение ConcurrentModificationException, если обнаруживают, что коллекция изменилась с момента начала итерации.

Итого, существует два способа обхода проблемы модификации коллекции во время итерации:

* Блокировать коллекцию. Может быть неприемлемо, если коллекция большая и действия, производимые над элементом во время итерации, занимают много времени. Тогда другие потоки могут ждать очень долго и производительность будет низкая.
* Делать копию коллекции перед итерацией. Опять же, если коллекция большая, это может занять много времени.

## 5.1.3 Hidden iterators

Скрытые итераторы - это когда итерация осуществляется неявно. Мы сами вроде бы ничего не пишем, но какие-то используемые нами операции приводят к итерации:

```java
public class HiddenIterator {

    @GuardedBy("this")
    private final Set<Integer> set = new HashSet<Integer>();

    public synchronized void add(Integer i) { 
        set.add(i); 
    }
    public synchronized void remove(Integer i) { 
        set.remove(i); 
    }

    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("DEBUG: added ten elements to " + set);  // <-- Скрытая итерация
    }
    
}
```

Здесь, чтобы сформировать строковое представление множества, проводится итерация по его элементам и во время нее может выскочить ConcurrentModificationException, т.к. метод println не обернут в синхронизацию.

Методы, которые используют итерацию под капотом: hashCode, equals, containsAll, removeAll, retainAll, конструкторы, принимающие коллекции, и т.д. В общем, скрытая итерация может поджидать на каждом углу.

# 5.2 Concurrent collections

Конкурентные коллекции как более производительная альтернатива синхронизированным коллекциям. В синхронизированных доступ к состоянию просто блокирует потоки, а в конкурентных все более продуманно.

* ConcurrentHashMap - замена синхронизированным реализациям Map, основанных на хэш-таблицах

* Интерфейс ConcurrentMap - добавляет составные действия вроде "добавить-если-отсутствует", заменить, удалить по условию

* ConcurrentSkipListMap

* ConcurrentSkipListSet

* CopyOnWriteArrayList - замена синхронизированным реализациям листа, где обход является превалирующей операцией

* Queue - задумана для временного хранения элементов, пока они ждут обработки. Операции в queue не блокирующие - если элемента нет, возвращается null. Несколько реализаций:

  * ConcurrentLinkedQueue - классическая FIFO
  * PriorityQueue - очередь, где элементы автоматически занимают место на основе своего приоритета (natural ordering наверное)

  LinkedList тоже реализует Queue, но у других классов выше производительность за счет выпиливания доступа по индексу.

* BlockingQueue - реализует операции добавления и получения с блокированием, т.е. в случае отсутствия элементов вызывающий поток будет ждать, пока они появятся. А в случае когда все слоты заняты, поток будет ждать, пока они появятся. Удобно для реализации задач производителя-потребителя.

## 5.2.1 ConcurrentHashMap

В отличие от обычных синхронизированных коллекций, эта использует более продвинутый механизм блокирования, называемый *lock striping* (глава 11.4.2). В итоге она поддерживает неограниченно много конкурентных потоков-"читателей", ограниченное количество конкурентных "писателей", а также "читатели" и "писатели" могут работать конкурентно. В однопоточных программах эта версия мэпы имеет лишь незначительное ухудшение производительности.

Эта коллекция, как и другие конкурентные, возвращает *weakly-consistent* итератор, который не выбрасывает ConcurrentModificationException. Он спокойно переносит конкурентную модификацию коллекции и может (но не обязан, так что не всегда) видеть внесенные изменения.

