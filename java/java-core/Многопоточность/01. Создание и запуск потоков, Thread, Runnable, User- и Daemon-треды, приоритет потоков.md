# Вопросы

- [ ] Что такое "главный поток"?
- [ ] Чем отличаются user-thread'ы от daemon-thread'ов?
  - [ ] 
  - [ ] В каком случае главный поток будет дожидаться выполнения остальных потоков, а в каком - не будет? Как это связано с user thread и daemon thread?
- [ ] Чем технически и концептуально отличается подход "implements Runnable" от "extends Thread", если и там, и там нужно переопределить метод .run?
  - [ ] Чем отличается запуск потока через .run() и .start()?
  - [ ] Как запустить параллельный код, оформленный через Thread?
  - [ ] Как запустить параллельный код, оформленный через Runnable? Зачем для этого нужен объект Thread?
- [ ] Как оформить код для потока через лямбду или анонимный класс? Какая связь с функциональными интерфейсами?
- [ ] Почему нельзя запустить поток дважды, используя один и тот же объект Thread? Как это работает концептуально?
- [ ] Почему не стоит использовать непосредственно объекты Thread для организации параллельного выполнения задач? 
  - [ ] Что происходит с потоком после того как он отработал, если он оформлен через Thread?
  - [ ] Какие альтернативы прямому использованию Thread существуют?

# Создание и запуск потоков

Когда программа запускается, существует только один поток, называемый *главным*. В нем и выполняется функция main(). Когда функция main() выполнится, программа завершается, если нет других потоков (если точнее, то *user-потоков*). Если они есть, то программа завершится только после их выполнения. Подробнее будет в разделе "Виды потоков и приоритет" ниже.

## implements Runnable vs extends Thread

```java
import java.lang.Thread;
import java.lang.Runnable;
```

Первый способ - реализовать интерфейс Runnable:

```java
public class Counter implements Runnable {  // <-- Реализуем интерфейс
    @Override
    public void run() {
        System.out.println("Counter начал работу");

        for (int i = 0; i < 100; i++) {
            System.out.println("i: " + i);
        }

        System.out.println("Counter завершил работу");
    }

    public static void main(String[] args) {  // <-- Запуск
        System.out.println("main начал выполнение");

        Runnable counter = new Counter();     // Экземпляр runnable
        Thread thread = new Thread(counter);  // нужно передать в тред
        thread.start();  // И тогда тред вызовет метод .run() переданного объекта
        
        System.out.println("main завершен");
    }
}
```

Второй способ - унаследоваться от класса Thread:

```java
public class Counter extends Thread {  // <-- Наследуемся от класса
    @Override
    public void run() {
        System.out.println("Counter начал работу");

        for (int i = 0; i < 100; i++) {
            System.out.println("i: " + i);
        }

        System.out.println("Counter завершил работу");
    }

    public static void main(String[] args) {  // <-- Запуск
        System.out.println("main начал выполнение");

        Counter counter = new Counter();  // А тут просто создаем наш объект
        counter.start();                  // И запускаем прямо его
        
        System.out.println("main завершен");
    }
}
...
// К слову, сам класс Thread тоже реализует Runnable
public class Thread implements Runnable
```

Результат работы один и тот же:

```java
main начал выполнение
main завершен
Counter начал работу
i: 0
i: 1
...
i: 99
Counter завершил работу
// Видно, что main выполнился мгновенно, но программа не завершилась, 
// а дождалась, пока отработает счетчик, т.к. это т.н. "user-thread"
// Еще есть "daemon-thread", и вот его бы JVM ждать не стала
```

Идейно вариант через implements Runnable предпочтительнее, поскольку реализует принцип "предпочитайте композицию наследованию". Ввиду отсутствия множественного наследования в джаве, реализация интерфейса поможет нам, если нужно наследоваться от какого-то своего класса, но при этом хочется параллельного выполнения.

## .run() vs .start()

Важный момент - запуск через .start() выполняет код в *новом потоке*, а .run() - в *текущем*:

```java
public static void main(String[] args) {
    System.out.println("main начал выполнение");

    Counter counter = new Counter();
    // counter.start();  // Заменим .start() на .run()
    counter.run();
    
    System.out.println("main завершен");
}
// P.S. Для случая с Runnable все аналогично
```

```java
main начал выполнение
Counter начал работу
i: 0
i: 1
...
i: 99
Counter завершил работу
main завершен
```

Так что нужно пользоваться .start(), иначе никакой параллельности не будет

## Повторный запуск

Чтобы запустить одну и ту же задачу второй раз, нам необходимо создать новый объект Thread - мы не можем переиспользовать старый:

```java
Runnable code = () -> System.out.println("Hello, thread!");

Thread thread1 = new Thread(code);
thread1.start();  // Ok
thread1.start();  // Ошибка!

Thread thread2 = new Thread(code);
thread2.start();  // Ok
```

Как это устроено технически - вопрос сложный, но логически все объяснимо: когда один объект связан с одним реальным потоком, это упрощает понимание, что сейчас происходит с этим потоком - то ли он работает, то ли завершился, то ли спит и т.д. Если же мы могли бы запускать второй поток, используя тот же объект thread1, то как бы мы тогда понимали, что происходит с первым потоком?

## Лямбды и анонимные классы

Можно оформлять Runnable не через отдельные классы, а через лямбды:

```java
Runnable counter = () -> {
    for (int i = 0; i < 100; i++) {
        System.out.println("i: " + i);
    }
};

Thread thread = new Thread(counter);
thread.start();
```

Или через анонимный класс:

```java
Runnable myRunnable =
    new Runnable() {
        public void run() {
            System.out.println("Runnable running");
        }
    }
```

Пример через анонимный класс просто для демонстрации. На деле смысла в этом мало. А вот лямбдой может быть очень даже удобно в некоторых случаях.

## Не Thread'ом единым

Использовать класс Thread напрямую для выполнения параллельных задач считается плохой практикой. С потоками связаны разные накладные расходы, вроде их создания, уничтожения, переключения и поэтому существуют специальные интерфейсы, в которых все эти вопросы учтены. Например, интерфейс *ExecutorService*. О нем в отдельном конспекте о "продвинутом запуске потоков".

# Виды потоков и приоритет

В джаве потоки бывают двух видов:

* User threads
* Daemon threads

## Приоритет

У любого потока в джаве есть приоритет. Выражается целым числом *от 1 до 10*. По умолчанию равен 5:

```java
Thread thread1 = new Thread();
System.out.println(thread1.getPriority());  // 5

Thread thread2 = new Thread();
System.out.println(thread2.getPriority());  // 5
```

Узнать\установить приоритет можно методами объекта треда:

```java
Thread thread = new Thread();
thread.getPriority();   // 5
thread.setPriority(8);  // Увеличиваем
thread.getPriority();   // 8
```

В классе Thread есть константы для приоритетов:

```java
Thread.MIN_PRIORITY   // 1
Thread.NORM_PRIORITY  // 5
Thread.HIGH_PRIORITY  // 10
```

## User треды

Характерны тем, что JVM не прекращает работу, пока выполняется хотя бы один user-тред.

## Daemon треды