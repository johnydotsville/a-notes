Тестовый набор данных:

```java
enum Sex { M, F }

class Character {
    public String firstname;
    public String lastname;
    public Sex sex;
    public int age;

    public Character(String firstname, String lastname, Sex sex, int age) {
        this.firstname = firstname;
        this.lastname = lastname;
        this.sex = sex;
        this.age = age;
    }
}
...
Character tom = new Character("Tom", "Sawyer", Sex.M, 13);
Character huck = new Character("Huckleberry", "Finn", Sex.M, 14);
Character becky = new Character("Becky", "Thatcher", Sex.F, 12);
Character sid = new Character("Sid", "Sawyer", Sex.M, 12);
Character joe = new Character("Joe", "Harper", Sex.M, 13);
Character marry = new Character("Marry", "Sawyer", Sex.F, 16);

ArrayList<Character> peeps = new ArrayList<>(
    Arrays.asList(tom, huck, becky, sid, joe, marry)
);
```

Простой пример:

```java
long shortNames = peeps.stream()
    .filter(p -> p.firstname.length() == 3)  // Промежуточная операция (intermediate), ret Stream<T>
    .count();  // Терминальная операция (terminal), ret long

long shortNames = peeps.parallelStream()
    .filter(p -> p.firstname.length() == 3)
    .count();
```



## Характеристики стримов:

* Выполняются по требованию, т.е. работа начнется только когда потребуют результат
* Поток не изменяет свой источник (коллекцию, поток), а выдает новый поток
* Поток не сохраняет свои элементы (???)



## Создание стримов

### Из коллекции

У коллекций есть методы .stream() и parallelStream(), которые возвращают поток.

### Из массива

У массивов, в отличие от коллекций, нету методов .stream() и parallelStream(). Поток на массиве получается так:

```java
Character[] peeps = new Character[] {  // массив персонажей
    tom, huck, becky, sid, joe, marry
};

Stream<Character> stream = Stream.of(peeps);  // 1 способ
Stream<Character> stream = Arrays.stream(peeps);  // 2 способ
Stream<Character> stream = Stream.of(tom, huck, becky, sid, joe, marry);  // 3 способ

long shortNames = stream
    .filter(p -> p.firstname.length() == 3)
    .count();
```



## Методы потоков

### filter

```java
long shortNames = peeps.stream()
    .filter(p -> p.firstname.length() == 3)  // Промежуточная операция (intermediate), ret Stream<T>
    .count();  // Терминальная операция (terminal), ret long
```

### map

```java
List<String> fullnames = peeps.stream()
    .map(p -> p.firstname + " " + p.lastname)  // Можно передать лямбду
    .map(String::toUpperCase)  // А можно просто функцию
    .toList();
```

### flatMap

TODO: вписать нормальный пример с реализацией

Концептуально, делает многомерный набор одномерным:

```
[ 
	[2, 3, 5], 
    [7, 11, 13], 
    [17, 19, 23] 
] -> [ 2, 3, 5, 7, 11, 13, 17, 19, 23 ]
```