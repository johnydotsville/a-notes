# Примитивные типы

В джаве 8 примитивных типов. Причем целочисленные бывают *только* знаковые:

| Название | Размер                                                       | Значение                                               | Комментарии                                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| byte     | 1b (8 bit)                                                   | -128 : 127                                             |                                                              |
| short    | 2b (16 bit)                                                  | -32_768 : 32_767                                       |                                                              |
| int      | 4b (32 bit)                                                  | -2_147_483_648 : 2_147_483_647                         |                                                              |
| long     | 8b (64 bit)                                                  | -9_223_372_036_854_775_808 : 9_223_372_036_854_775_807 |                                                              |
| float    | 4b (32 bit)                                                  | 1.4e-45 : 3.4e+38                                      | float рекомендуется не пользоваться, если этого явно не требует библиотека или не нужно обязательно сэкономить память, double - универсальнее |
| double   | 8b (64 bit)                                                  | 4.9e-324 : 1.7e+308                                    | Может хранить отрицательные числа                            |
| char     | 2b (16 bit)                                                  |                                                        |                                                              |
| boolean  | Отличается в разных реализациях виртуальной машины. Например, в Sun JVM и Oracle HotSpot JVM это 4b (32 bit) |                                                        |                                                              |

## Экспоненциальная запись дроби

Чтобы получить обычную запись десятичного числа, нужно возвести 10 в указанную степень и умножить на дробь, записанную до буквы ***e\***.

1.4e-3 = 1.4 * $10^{-3}$ = 0,0014

## Комментарии

Шестнадцатеричные цифры имеют префикс 0x, двоичные - 0b

Разделитель _ можно использовать не только для десятичных цифр 1_000_000, но и для 16х и 8х.

# Объектные оболочки и упаковка-распаковка

int - примитивный тип.

Integer - т.н. "объектная оболочка" для примитивного типа.

Объектные оболочки существуют для всех примитивных типов: Character, Byte, Short, Integer, Long, Float, Double, Boolean. У этих, кроме boolean, общий суперкласс Number.

ArrayList например не работает с примитивными типами, поэтому приходится использовать оболочки:

```java
//ArrayList<int> ints = new ArrayList<int>(10);  // Ошибка
ArrayList<Integer> ints = new ArrayList<Integer>(10);
ints.add(5);  // авто-упаковка, компилятор развернет это в ints.add(Integer.valueOf(5))
int number = ints.get(0);  // авто-распаковка, развернется в ints.get(0).intValue();

Integer n = 3;  // авто-упаковка
n++;  // распаковка-инкремент-упаковка
```

При добавлении и извлечении числа в этом примере происходит т.н. "упаковка" и "распаковка" соответственно. Упаковка - это когда примитивный тип помещается в объект-оболочку. Распаковка - это когда примитивный тип извлекается из объекта-оболочки обратно. Метафорически это так: упаковка, "boxing", подразумевает что когда вы кладете например телефон в коробку, в целом теперь эта сущность занимает больше места. Так же и тут - примитивный тип занимает мало места, а объект - много по сравнению с ним, т.е. упаковка - это превращение маленького в большое, т.е. примитивного типа в объектный. Распаковка - обратный процесс.

В оболочках есть статические и обычные методы, позволяющие создавать оболочки, извлекать из оболочек значения и прочее:

```java
int five = Integer.parseInt("5");  // Строку преобразовать в число
Integer seven = Integer.valueOf(7);  // Из примитива создать объект
int isev = seven.intValue();  // Извлечь примитив из объекта
String ssev = Integer.toString(8);

Character symbol = Character.valueOf('w');
char sym = symbol.charValue();
```

## Особенности

* При сравнении оболочек надежнее пользоваться методом `.equals()`

* В оболочку можно положить null и теоретически получить потом NullPointerException

* TODO Хорстман Том 1 с.240

  ```java
  Integer n = 1;
  Double x = 2.0;
  System.out.println(true ? n : x);  // Выведет 1.0
  ```

  Т.е. int распакуется, приведется к double и снова упакуется. Правда я не очень понимаю как это под капотом работает. Ведь тут не сравниваются два числа, а значит зачем приводить int к double?

* Упаковка-распаковка происходит еще на этапе компиляции, т.е. компилятор где нужно расставляет соответствующие операции и к виртуальной машине уже поступает готовый код.

TODO: можно сделать дополнительные примеры по остальным методам оболочек, там есть еще сравнение и другие.



# Непонятки

- [ ] Вообще не понятно как работает double.

  На дефолтных говносайтах написано, что диапазон значений 4.9e-324 : 1.7e+308. Т.е. минимальное число не 0 даже, а больше нуля и до огромного числа, грубо говоря, 308 нулей это в 30 раз больше миллиарда.

  При этом переменная double позволяет положить в себя значения от -2_147_483_648 до 2_147_483_647, меньше-больше - ругается. Лично проверил. Эти значения совпадают со значениями int.

  Нашел вот такую картинку с изображением того, как хранится double.

  ![ml6Hz](img/ml6Hz.png)

  Экспонента, это как будто целая часть числа, а fraction - дробная. Но что значит 11 бит и 52 бит в данном случае?