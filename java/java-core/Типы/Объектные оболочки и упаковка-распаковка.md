# Объектные оболочки и упаковка-распаковка

int - примитивный тип.

Integer - т.н. "объектная оболочка" для примитивного типа.

Объектные оболочки существуют для всех примитивных типов: Character, Byte, Short, Integer, Long, Float, Double, Boolean. У этих, кроме boolean, общий суперкласс Number.

ArrayList например не работает с примитивными типами, поэтому приходится использовать оболочки:

```java
//ArrayList<int> ints = new ArrayList<int>(10);  // Ошибка
ArrayList<Integer> ints = new ArrayList<Integer>(10);
ints.add(5);  // авто-упаковка, компилятор развернет это в ints.add(Integer.valueOf(5))
int number = ints.get(0);  // авто-распаковка, развернется в ints.get(0).intValue();

Integer n = 3;  // авто-упаковка
n++;  // распаковка-инкремент-упаковка
```

При добавлении и извлечении числа в этом примере происходит т.н. "упаковка" и "распаковка" соответственно. Упаковка - это когда примитивный тип помещается в объект-оболочку. Распаковка - это когда примитивный тип извлекается из объекта-оболочки обратно. Метафорически это так: упаковка, "boxing", подразумевает что когда вы кладете например телефон в коробку, в целом теперь эта сущность занимает больше места. Так же и тут - примитивный тип занимает мало места, а объект - много по сравнению с ним, т.е. упаковка - это превращение маленького в большое, т.е. примитивного типа в объектный. Распаковка - обратный процесс.

В оболочках есть статические и обычные методы, позволяющие создавать оболочки, извлекать из оболочек значения и прочее:

```java
int five = Integer.parseInt("5");  // Строку преобразовать в число
Integer seven = Integer.valueOf(7);  // Из примитива создать объект
int isev = seven.intValue();  // Извлечь примитив из объекта
String ssev = Integer.toString(8);

Character symbol = Character.valueOf('w');
char sym = symbol.charValue();
```

## Особенности

* При сравнении оболочек надежнее пользоваться методом `.equals()`

* В оболочку можно положить null и теоретически получить потом NullPointerException

* TODO Хорстман Том 1 с.240

  ```java
  Integer n = 1;
  Double x = 2.0;
  System.out.println(true ? n : x);  // Выведет 1.0
  ```

  Т.е. int распакуется, приведется к double и снова упакуется. Правда я не очень понимаю как это под капотом работает. Ведь тут не сравниваются два числа, а значит зачем приводить int к double?

* Упаковка-распаковка происходит еще на этапе компиляции, т.е. компилятор где нужно расставляет соответствующие операции и к виртуальной машине уже поступает готовый код.

TODO: можно сделать дополнительные примеры по остальным методам оболочек, там есть еще сравнение и другие.