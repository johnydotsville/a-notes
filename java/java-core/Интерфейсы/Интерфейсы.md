Здесь опишу куцые синтетические примеры, просто чтобы можно было по-быстрому смотреть синтаксис. В отдельных файлах возможно заморочусь с реализацией интерфейса Comparable и т.д.

TODO Здесь встречаются неочевидные вещи, вроде приватных методов в интерфейсе, использование которых хорошо бы посмотреть в конкретных промышленных программах. Поэтому в целом вся заметка тут будет куцая. После изучения синтаксиса я буду разбирать конкретные программы, которые смогу найти и в случае чего дополнять здесь описания, чтобы было более наглядно, что и зачем нужно.

# Факты

* Все члены интерфейса по умолчанию public. Поэтому в самом интерфейсе писать это явно не надо (если написать, ошибки компиляции не будет, но это лишнее).
* В интерфейсах не может полей, но могут быть константы (*static final*). С виду такая константа может выглядеть как поле, но это не поле. Аналогично, писать *public static final* можно явно, но не нужно. Впрочем, кажется можно пользоваться этой константой внутри класса как полем. Переназначить конечно нельзя, а вот считать - легко, и при этом даже не надо указывать имя интерфейса.
* В интерфейсах могут быть обычные методы и статические (но только с Java 8). До Java 8, если к интерфейсу хотелось приделать статические методы, то просто создавали парный класс с похожим названием и клали их туда. Из реального примера - в самой Java есть интерфейс Collections и класс Collection.
* Объект интерфейса создать конечно невозможно.
* Один интерфейс может расширять другой интерфейс.
* Интерфейс может иметь закрытые методы (с Java 9). При этом они должны иметь реализацию. Использоваться они могут только внутри интерфейса, т.е. внутри класса-реализатора такой метод не будет даже виден. TODO дописать бы сюда пример, когда увижу реальную реализацию
* Интерфейс может иметь метод с реализацией по умолчанию, он помечается словом default. TODO интересно, а можно ли это использовать как трейты?
* Если класс реализует два интерфейса, а в них есть метод с одинаковой сигнатурой (или например такой же метод есть в суперклассе), то для решения этой неоднозначности есть вполне конкретный алгоритм действий (см. пункт [Коллизия методов](#коллизия-методов)).

# Объявление

Интерфейс с константой и обычным методом:

```java
public interface Fillable {
    int GAS_CAPACITY = 30;  // public static final. Это не поле, это константа
    void Fill(int liter);  // public
}
```

Интерфейс с реализацией по умолчанию:

```java
public interface Movable {
    default void move(String destination) {  // default
        System.out.println("Машина поехала в " + destination);
    }
}
```

Один интерфейс может расширять другой интерфейс:

```java
public interface Acceleration extends Movable {
    
}
```

TODO как это применить, пока описать не могу. Оставлю в таком виде, когда на реальных примерах увижу, допишу.

Интерфейс может иметь приватный метод:

```java
public interface IFaceWithPrivateMethod {
    default void publicMethodCallingPrivateMethod() {
        System.out.println("Через этот дефолтный публичный метод можно вызвать приватный метод.");
        privateMethod();
    }

    void publicMethod();

    private void privateMethod() {
        System.out.println("Это приватный метод интерфейса IFaceWithPrivateMethod");
    }
}
```

TODO. Вот на это посмотреть в реальной программе было бы реально интересно, как это по-человечески используется.

# Реализация

При реализации нескольких интерфейсов, они перечисляются через запятую:

```java
public class Car implements Movable, Fillable {
    private int gas = 10;

    public int getGas() {
        return this.gas;
    }

    public void fill(int liter) {
        gas += liter;
        if (gas > GAS_CAPACITY)  // Константа доступна для использования без имени интерфейса
            gas = GAS_CAPACITY;
    }
}
```

# Принадлежность к интерфейсу

Объекты можно класть в переменные типа интерфейса:

```java
Movable mvb = new Car();
Fillable flb = new Car();
```

Если объект реализует интерфейс, то instanceof дает true:

```java
boolean carIsMovable = car instanceof Movable;  // true
boolean carIsFillable = car instanceof Fillable;  // true
```

# Проблемы

## Коллизия методов

* Сценарий 1: класс B расширяет класс A и реализует интерфейс I, при этом в классе A и интерфейсе I есть метод с идентичной сигнатурой и при этом в интерфейсе он реализован по умолчанию.

Что будет? Будет использован метод суперкласса.

```java
public class Superclass {
    public void someMethod() {
        System.out.println("Это someMethod из класса Superclass");
    }
}

public interface IFace {
    default void someMethod() {
        System.out.println("Этот метод someMethod интерфейса IFace");
    }
}

public class Subclass extends Superclass implements IFace {
}
...

IFace bar = new Subclass();  // ! Тип ссылки - IFace
bar.someMethod();  // Но выведется "Это someMethod из класса Superclass"
```

Можно конечно переопределить метод:

```java
public class Subclass extends Superclass implements IFace {
    @Override public void someMethod() {
        System.out.println("Я Subclass и это мой личный метод someMethod");
    }
}
...

IFace bar = new Subclass();  // ! Тип ссылки - IFace
bar.someMethod();  // "Я Subclass и это мой личный метод someMethod"
```

* Сценарий 2: класс реализует два интерфейса, и в обоих есть метод с одинаковой сигнатурой.

```java
public interface IFace {
    default void someMethod() {
        System.out.println("Этот метод someMethod интерфейса IFace");
    }
}

public interface IFoobar {
    default void someMethod() {
        System.out.println("Интерфейс IFoobar предоставил метод someMethod");
    }
}

public class Subclass implements IFace, IFoobar {
}
```

Если бы он наследовался от Superclass, тогда бы опять метод суперкласса победил. Но в данном случае будет ошибка компиляции. Причем даже если бы у какого-то интерфейса не было бы реализации по умолчанию, все равно была бы ошибка. Важен сам факт, что в двух интерфейсах два метода с одинаковой сигнатурой.

В этом случае надо явно переопределить в классе метод и либо написать свою реализацию, либо вызвать реализацию из желаемого интерфейса:

```java
public class Subclass implements IFace, IFoobar {
    @Override public void someMethod() {
        // Либо пишем свою реализацию
        // Либо вызываем дефолтную из нужного интерфейса (если она конечно есть)
        IFoobar.super.someMethod();
    }
}
```

