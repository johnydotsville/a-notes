
<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>История эволюции интерфейсов в Java / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
</head>
<body>



<br/>
Интерфейс в Java сильно эволюционировал за прошедшие годы. Давайте рассмотрим, какие изменения произошли в процессе его развития.<br/>
<a name="habracut"></a><br/>
<h2>Оригинальные интерфейсы</h2><br/>
Интерфейсы в Java 1.0 были достаточно простыми по сравнению с тем, какие они сейчас. Они могли содержать лишь два типа элементов: константы и публичные абстрактные методы.<br/>
<br/>
<h3>Поля-константы</h3><br/>
Интерфейсы могут содержать поля, так же как и обычные классы, но с несколькими отличиями:<br/>
<br/>
<ul>
<li>Поля должны быть проинициализированы</li>
<li>Поля считаются публичными статическими финальными</li>
<li>Модификаторы public, static и final не нужно указывать явно (они «проставляются» по умолчанию)</li>
</ul><br/>
<pre><code class="java">public interface MyInterface {
    int MY_CONSTANT = 9;
}
</code></pre><br/>
Даже несмотря на то, что явно это не задано, поле MY_CONSTANT считается публичной статической финальной константой. Вы можете добавить эти модификаторы, но делать это не обязательно.<br/>
<br/>
<h2>Абстрактные методы</h2><br/>
Наиболее важными элементами интерфейса являются его методы. Методы интерфейса также отличаются от методов обычного класса:<br/>
<br/>
<ul>
<li>У методов нет тела </li>
<li>Реализация методов предоставляется классами, реализующими данный интерфейс </li>
<li>Методы считаются публичными и абстрактными даже, если это не задано явно </li>
<li>Методы не могут быть финальными, поскольку в Java комбинация модификаторов abstract и final запрещена </li>
</ul><br/>
<pre><code class="java">public interface MyInterface {
    int doSomething();
    String doSomethingCompletelyDifferent();
}
</code></pre><br/>
<h2>Вложенность</h2><br/>
Java 1.1 представила концепцию классов, которые можно размещать внутри других классов. Такие классы бывают двух видов: статические и нестатические. Интерфейсы так же могут содержать внутри себя другие интерфейсы и классы.<br/>
<br/>
Даже если это не задано явно, такие интерфейсы и классы считаются публичными и статическими.<br/>
<br/>
<pre><code class="java">public interface MyInterface {
    class MyClass {
        //...
    }

    interface MyOtherInterface {
        //...
    }
}
</code></pre><br/>
<h3>Перечисления и аннотации</h3><br/>
В Java 5 были введены ещё два типа: Перечисления и Аннотации. Они также могут быть помещены внутрь интерфейсов.<br/>
<br/>
<pre><code class="java">public interface MyInterface {
    enum MyEnum {
        FOO, BAR;
    }

    @interface MyAnnotation {
        //...
    }
}
</code></pre><br/>
<h2>Обобщенные типы</h2><br/>
Java 5 ввела концепцию «дженериков» — обобщенных типов. Вкратце: «дженерики» позволяют вам использовать обобщенный тип вместо указания конкретного типа. Таким образом, вы можете писать код, который работает с различным количеством типов, не жертвуя при этом безопасностью и не предоставляя отдельную реализацию для каждого типа.<br/>
<br/>
В интерфейсах, начиная с Java 5, вы можете определить обобщенный тип, а затем использовать его в качестве типа возвращаемого значения метода или в качестве типа аргумента метода.<br/>
<br/>
Интерфейс Box работает независимо от того, используете ли вы его для хранения объектов типа String, Integer, List, Shoe или каких-либо других.<br/>
<br/>
<pre><code class="java">interface Box&lt;T> {
    void insert(T item);
}

class ShoeBox implements Box&lt;Shoe> {
    public void insert(Shoe item) {
        //...
    }
}
</code></pre><br/>
<h2>Статические методы</h2><br/>
Начиная с Java 8, вы можете включать в интерфейсы статические методы. Данный подход изменил привычный для нас способ работы интерфейса. Они теперь работают совсем не так, как работали до Java 8. Первоначально все методы в интерфейсах были абстрактными. Это означало, что интерфейс предоставлял лишь сигнатуру, но не реализацию. Реализация оставалась за классами, реализующими ваш интерфейс.<br/>
<br/>
При использовании статических методов в интерфейсах вам нужно также предоставить реализацию тела метода. Чтобы задействовать в интерфейсе такой метод, просто используйте ключевое слово static. Статические методы считаются публичными по умолчанию.<br/>
<br/>
<pre><code class="java">public interface MyInterface {
    
    // This works
    static int foo() {
        return 0;
    }

    // This does not work, 
    // static methods in interfaces need body
    static int bar();
}
</code></pre><br/>
<h3>Наследование статических методов</h3><br/>
В отличие от обычных статических методов, статические методы в интерфейсах не наследуются. Это означает, что если вы хотите вызвать такой метод, вы должны вызвать его напрямую из интерфейса, а не из реализующего его класса.<br/>
<br/>
<pre><code class="java">MyInterface.staticMethod();
</code></pre><br/>
Это поведение очень полезно для избежания проблем при множественном наследовании. Представьте, что у вас есть класс, реализующий два интерфейса. У каждого из интерфейсов есть статический метод с одинаковым именем и сигнатурой. Какой из них должен быть использован в первую очередь?<br/>
<br/>
<h3>Почему это полезно</h3><br/>
Представьте, что у вас есть интерфейс и целый набор вспомогательных методов, которые работают с классами, реализующими этот интерфейс.<br/>
<br/>
Традиционно существовал подход в использовании класса-компаньона. В дополнение к интерфейсу создавался утилитный класс с очень похожим именем, содержащий статические методы, принадлежащие интерфейсу.<br/>
<br/>
Вы можете найти примеры использования данного подхода прямо в JDK: интерфейс java.util.Collection и сопутствующий ему утилитный класс java.util.Collections.<br/>
<br/>
Со статическими методами в интерфейсах этот подход больше не актуален, не нужен и не рекомендован. Теперь вы можете иметь все в одном месте.<br/>
<br/>
<h2>Методы по умолчанию</h2><br/>
Методы по умолчанию похожи на статические методы тем, что для них вы также должны предоставлять тело. Чтобы объявить метод по умолчанию, просто используйте ключевое слово default.<br/>
<br/>
<pre><code class="java">public interface MyInterface {
    default int doSomething() {
        return 0;
    }
}
</code></pre><br/>
В отличие от статических методов, методы по умолчанию наследуются классами, реализующими интерфейс. Что важно, такие классы могут при необходимости переопределять их поведение.<br/>
<br/>
Хотя есть одно исключение. В интерфейсе не может быть методов по умолчанию с такой же сигнатурой, как у методов toString, equals и hashCode класса Object. Взгляните на ответ Брайана Гетца, чтобы понять обоснованность такого решения:<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html"> Allow default methods to override Object's methods.</a><br/>
<br/>
<h3>Почему это полезно</h3><br/>
Идея с реализацией методов прямо в интерфейсе выглядит не совсем правильной. Так почему в первую очередь была введена эта функциональность?<br/>
<br/>
У интерфейсов есть одна проблема. Как только вы предоставите свой API другим людям, он навсегда «окаменеет» (его нельзя будет изменить безболезненно).<br/>
<br/>
По традиции, Java очень серьезно относится к обратной совместимости. Методы по умолчанию предоставляют способ расширить существующие интерфейсы новыми методами. Наиболее важно то, что методы по умолчанию уже предоставляют определенную реализацию. Это означает, что классам, реализующим ваш интерфейс, не нужно реализовывать какие-либо новые методы. Но, если в этом будет необходимость, методы по умолчанию можно будет переопределить в любое время, если их реализация перестанет подходить. Таким образом, вкратце, вы можете предоставить новую функциональность существующим классам, реализующим ваш интерфейс, сохраняя при этом совместимость.<br/>
<br/>
<h3>Конфликты</h3><br/>
Давайте представим, что у нас есть класс, реализующий два интерфейса. У этих интерфейсов есть метод по умолчанию с одинаковыми именем и сигнатурой.<br/>
<br/>
<pre><code class="java">interface A {
    default int doSomething() {
        return 0;
    }
}

interface B {
    default int doSomething() {
        return 42;
    }
}

class MyClass implements A, B {
}
</code></pre><br/>
Теперь один и тот же метод по умолчанию с одной и той же сигнатурой унаследован от двух разных интерфейсов. У каждого интерфейса своя реализация этого метода.<br/>
<br/>
Итак, как наш класс узнает, какую из двух различных реализаций использовать?<br/>
<br/>
Он и не узнает. Приведенный выше код приведет к ошибке компиляции. Если вам требуется заставить его работать, то для этого необходимо переопределить конфликтный метод в вашем классе.<br/>
<br/>
<pre><code class="java">interface A {
    default int doSomething() {
        return 0;
    }
}

interface B {
    default int doSomething() {
        return 42;
    }
}

class MyClass implements A, B {

    // Without this the compilation fails    
    @Override
    public int doSomething() {
        return 256;
    }
}
</code></pre><br/>
<h2>Приватные методы</h2><br/>
С появлением Java 8 и введением методов по умолчанию и статических методов, у интерфейсов появилась возможность содержать не только сигнатуры методов, но и их реализации. При написании таких реализаций рекомендуется разделять сложные методы на более простые. Такой код легче переиспользовать, поддерживать и понимать.<br/>
<br/>
Для такой цели вы бы использовали приватные методы, поскольку они могут содержать все детали реализации, которые не должны быть видимы и использованы извне.<br/>
<br/>
К сожалению в Java 8 интерфейс не может содержать приватные методы. Это означает, что вы можете использовать:<br/>
<br/>
<ol>
<li>Длинные, сложные и трудные в понимании тела методов. </li>
<li>Вспомогательные методы, которые являются частью интерфейса. Это нарушает принцип инкапсуляции и загрязняет публичный API интерфейса и классов-реализаций. </li>
</ol><br/>
К счастью, начиная с <a href="http://openjdk.java.net/jeps/213">Java 9, вы можете использовать приватные методы в интерфейсах</a>. У них есть следующие особенности:<br/>
<br/>
<ul>
<li>у приватных методов есть тело, они не абстрактные </li>
<li>они могут быть как статическими, так и нестатическими </li>
<li>они не наследуются классами, реализующими интерфейс, и интерфейсами </li>
<li>они могут вызывать другие методы интерфейса </li>
<li>приватные методы могут вызывать другие приватные, абстрактные, статические методы или методы по умолчанию </li>
<li>приватные статические методы могут вызывать только другие статические и приватные статические методы </li>
</ul><br/>
<pre><code class="java">public interface MyInterface {

    private static int staticMethod() {
        return 42;
    }

    private int nonStaticMethod() {
        return 0;
    }
}
</code></pre><br/>
<h2>Хронологический порядок</h2><br/>
Ниже представлен хронологический перечень изменений по версиям Java:<br/>
<br/>
<h4>Java 1.1</h4><br/>
Вложенные классы<br/>
<br/>
Вложенные интерфейсы<br/>
<br/>
<h4>Java 5</h4><br/>
Обобщенные типы<br/>
<br/>
Вложенные перечисления<br/>
<br/>
Вложенные аннотации<br/>
<br/>
<h4>Java 8</h4><br/>
Методы по умолчанию<br/>
<br/>
Статические методы<br/>
<br/>
<h4>Java 9</h4><br/>
Приватные методы</div></div></div> 
</body>
</html>
