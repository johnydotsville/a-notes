# java.io и java.nio

Насколько я понял, в джаве для работы с файлами есть два глобальных подхода:

* Использовать пакет java.io (более старый API)
* Использовать пакет java.nio (более новый API, n значит non-blocking)

Характеристики io:

* Блокирующий ввод\вывод  ??? Значит ли это, что эти классы нельзя использовать в асинхронном программировании?
* Операции ориентированы на работу с потоками (java.io.InputStream, OutputStream)

В общем это значит, что мы читаем напрямую из потока по одному или несколько байт и обрабатываем их как считаем нужным. Они нигде не буферизуются, т.е. считали-обработали, считали-обработали. Мы не можем, например, после чтения вернуться немножко назад и "перечитать". Плюс к этому, операции чтения\записи блокируют поток до своего завершения, т.е. поток не может выполнять никакую другую работу, пока операция не завершится.

Характеристики nio:

* Неблокирующий ввод\вывод
* Операции ориентированы на работу с буфером (java.nio.Buffer ???)

Это значит, что данные из источника сперва попадают в буфер, из которого мы уже их читаем (с помощью каналов???). Соответственно, по буферу можно перемещаться вперед-назад, если вдруг в этом есть необходимость. Операции чтения\записи являются неблокирующими, т.е. поток не дожидается окончания операции, а может например перейти к другой операции над другим буфером.

# IO, обзор

Пакет IO в предназначен для чтения\записи данных между источниками и приемниками.

Наиболее типичные источники\приемники данных:

- Files
- Pipes (средство обмена данными между тредами)
- Network Connections
- In-memory Buffers (e.g. arrays)
- System.in, System.out, System.error

Наиболее типичные задачи ввода\вывода:

- File Access
- Network Access
- Internal Memory Buffer Access
- Inter-Thread Communication (Pipes)
- Buffering
- Filtering
- Parsing
- Reading and Writing Text (Readers / Writers) 
- Reading and Writing Primitive Data (long, int etc.)
- Reading and Writing Objects

## Потоки

Вся работа крутится вокруг концепции потока (Stream). Поток - это концептуально бесконечная последовательность данных. Поток присоединяется к источнику или приемнику данных. В поток можно писать или читать.

Чтение\запись в основе бывает двух видов:

* Чтение\запись байтов (классы java.io.InputStream и OutputStream)
* Чтение\запись символов (классы java.io.Reader и Writer)

Все эти четыре класса являются абстрактными и могут только в совсем базовые операции. Например, InputStream может, по сути, просто читать байты из источника. Может побайтно, может - по нескольку байт в массив. Метод чтения возвращает -1, если данных в источнике не осталось.

Посимвольная обработка нужна, чтобы упростить работу с текстом, т.к. один символ может кодироваться не одним байтом, а например двумя и больше.

Существуют буферизованные потоки, например, BufferedInputStream, BufferedReader. Чтение пачками выгоднее, чем по одному байту\символу. ??? Интересно, но ведь это не ставит потоки из IO на одну полку с NIO?

Вообще, для перечисленных выше задач существуют разные реализации этих абстрактных классов, которые могут в более высокоуровневые вещи. Например, считать строку целиком.

## Комбинирование потоков

Некоторые потоки можно комбинировать, чтобы добиваться нужного эффекта. Допустим, можно получить InputStream. Он оперирует байтами. А мы хотим прочитать его как строки. Для этого мы его передаем в InputStreamReader. Поскольку он Reader, то оперирует символами и таким образом преобразует прочитанные байты в символы. И все это мы еще помещаем в BufferedReader для увеличения скорости.

```java
// Грубоватый пример такой комбинации
URL url = new URL(fullUrl);
InputStream is = url.openStream();  // throws an IOException
BufferedReader br = new BufferedReader(new InputStreamReader(is));

while ((line = br.readLine()) != null) {
    System.out.println(line);
}
```

