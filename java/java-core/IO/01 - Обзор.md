# Ввод-вывод и ОС

## Блокирующий\неблокирующий IO

Термины "блокирующий" и "неблокирующий" IO позволяют понять, что происходит с потоком, который запросил операцию IO. Поскольку IO это в основном работа с устройствами (диски, сетевая карта), то почти любая операция IO - это системный вызов к операционной системе, т.е. поток при этом отдает процессор операционной системе и переходит в состояние блокировки.

При блокирующем IO, ОС не пробуждает поток до тех пор, пока операция IO не будет полностью выполнена. Т.о., когда поток продолжает выполнение, можно быть уверенным, что все данные, которые он ожидал получить в результате запрошенной операции IO, готовы и он может их обработать.

При неблокирующем IO, ОС запускает операцию IO и возвращает управление потоку, т.е. он продолжает выполняться, пока не закончится его квант времени. При этом конечно у него нет никаких гарантий того, что интересующие его данные готовы. Говорят, что "пока операция IO не закончена, поток может заняться чем-то еще". Но ведь не просто так же он запросил IO, он ведь наверняка хотел получить данные и обработать их, так чем же тогда "еще" он может заняться? Разве что сидеть и спрашивать "Ну что, готовы данные, которые я запросил? А теперь? А теперь? А теперь?". Поэтому на деле это "чем-то еще" означает, что скорее всего в этом потоке используется много "источников" данных и он просто инициирует вторую IO операцию, потом третью, четвертую и т.д. И так глядишь пока он это делает, первый источник заполнится данными и можно будет их обработать.

## Железо и оповещения

Устройства IO делятся на несколько типов, два из которых это:

* Блочные - hdd, sdd, флэшки и прочие, поддерживающие позиционирование
* Символьные - сетевая карта и прочие, которые позиционирование не поддерживают в виду своей природы (бесконечный поток байтов)

У этих устройств есть два концептуальных компонента: буфер и контроллер с регистрами. В буфере накапливаются данные, которые устройство получает\отправляет, а благодаря регистрам устройство общается с ОС. Например, по сети приходят данные и попадают в буфер сетевой карты. При этом она устанавливает в условный регистр "статуса" значение, сигнализирующее о том, что "данные пришли, можно забирать". ОС периодически проверяет этот "регистр статуса" и когда видит этот сигнал, собственно говоря, копирует данные из буфера в память потока, которому они были нужны, и оттуда он уже может их читать. А когда поток хочет отправить что-то по сети, он делает системный вызов и ОС берет эти данные, копирует из памяти потока в буфер сетевой карты и записывает в условный регистр "управления" какое-то значение и тогда сетевая карта понимает, что эти данные из буфера надо вылить в сеть.

Реальная картина такого взаимодействия может отличаться, но суть примерно такая и есть. Важен сам факт того, что ОС поддерживает режим IO без блокировок за счет того, что часть ее собственных системных вызовов реализована именно как неблокирующие.

Оповещения о готовности для самой ОС тоже отдельная тема, но один из способов - так называемый *event loop*, поток, занимающийся в цикле опросом устройств о готовности результата IO. Упоминаю об этом потому, что в NIO есть селекторы, которые очень похожи на этот самый event loop.

Ну а теперь можно и про джаву.

# java.io и java.nio

В джаве есть два пакета для работы с вводом-выводом (IO):

* java.io (появился первым)
* java.nio (появился вторым, new IO)

NIO еще называют Non-blocking IO, но это не совсем корректно. Например, работа с файлами в NIO все равно всегда происходит в блокирующем стиле, а работа с сокетами - по умолчанию тоже, но может быть переведена в неблокирующий режим.

Сравнение двух пакетов:

|                  | java.IO     | java.NIO                    |
| ---------------- | ----------- | --------------------------- |
| Тип IO операций  | Блокирующие | Неблокирующие + блокирующие |
| С чем работаем?  | Потоки      | Каналы, буферы              |
| Доп. возможности | -           | Селекторы                   |

О таких вещах как каналы, буферы и селекторы написано в разделе про NIO, но в целом выбор того или иного пакета зависит от типа задач, требований к производительности и характера самой обработки ввода-вывода.

Что за типы задач? Есть задачи с "тяжелым" IO, т.е. задачи, где IO используется интенсивно и занимает важную роль среди всех операций, например, веб-сервер. Он интенсивно работает с IO, потому что должен постоянно принимать соединения и обрабатывать данные. А что за характер обработки? Сама обработка может быть разная. Может быть это простое сохранение данных или пересылка куда-то еще, т.е. без необходимости анализировать сами данные. Тогда это один дело. А может быть наоборот - эти данные подвергаются сложной обработке. Что насчет требований производительности? Есть разница, обрабатывать 10 соединений в секунду или 10_000.

В общем, суть понятна - без конкретных задач и ограничений нет из разговора о том, что лучше - IO или NIO. Пара паттернов, которые могли бы склонить выбор туда или сюда:

* Соединений мало - тогда можно создавать на каждое соединение отдельный поток и проводить обработку в нем, используя java.IO. Дополнительные потоки - это дополнительный расход памяти и время на переключение контекста. Но за счет того, что соединений мало, это не сильно влияет на производительность.
* Соединений много - расход памяти и времени на переключение между потоками может стать критичным. Поэтому нужно искать способы как обрабатывать несколько соединений в одном потоке. Для этого подходит java.NIO - инициируем подряд несколько IO операций и пока инициировали последнюю, уже завершилась первая и можно ее обрабатывать. Меньше переключений контекста, меньше памяти на дополнительные потоки.
* Данные сложные и проверки на их готовность могут быть менее выгодными, чем дождаться окончания блокирующего IO - используем java.IO

# IO, обзор

Пакет IO в предназначен для чтения\записи данных между источниками и приемниками.

Наиболее типичные источники\приемники данных:

- Files
- Pipes (средство обмена данными между тредами)
- Network Connections
- In-memory Buffers (e.g. arrays)
- System.in, System.out, System.error

Наиболее типичные задачи ввода\вывода:

- File Access
- Network Access
- Internal Memory Buffer Access
- Inter-Thread Communication (Pipes)
- Buffering
- Filtering
- Parsing
- Reading and Writing Text (Readers / Writers) 
- Reading and Writing Primitive Data (long, int etc.)
- Reading and Writing Objects

## Потоки

Вся работа крутится вокруг концепции потока (Stream). Поток - это концептуально бесконечная последовательность данных. Поток присоединяется к источнику или приемнику данных. В поток можно писать или читать.

Чтение\запись в основе бывает двух видов:

* Чтение\запись байтов (классы java.io.InputStream и OutputStream)
* Чтение\запись символов (классы java.io.Reader и Writer)

Все эти четыре класса являются абстрактными и могут только в совсем базовые операции. Например, InputStream может, по сути, просто читать байты из источника. Может побайтно, может - по нескольку байт в массив. Метод чтения возвращает -1, если данных в источнике не осталось.

Посимвольная обработка нужна, чтобы упростить работу с текстом, т.к. один символ может кодироваться не одним байтом, а например двумя и больше.

Существуют буферизованные потоки, например, BufferedInputStream, BufferedReader. Чтение пачками выгоднее, чем по одному байту\символу. ??? Интересно, но ведь это не ставит потоки из IO на одну полку с NIO?

Вообще, для перечисленных выше задач существуют разные реализации этих абстрактных классов, которые могут в более высокоуровневые вещи. Например, считать строку целиком.

## Комбинирование потоков

Некоторые потоки можно комбинировать, чтобы добиваться нужного эффекта. Допустим, можно получить InputStream. Он оперирует байтами. А мы хотим прочитать его как строки. Для этого мы его передаем в InputStreamReader. Поскольку он Reader, то оперирует символами и таким образом преобразует прочитанные байты в символы. И все это мы еще помещаем в BufferedReader для увеличения скорости.

```java
// Грубоватый пример такой комбинации
URL url = new URL(fullUrl);
InputStream is = url.openStream();  // throws an IOException
BufferedReader br = new BufferedReader(new InputStreamReader(is));

while ((line = br.readLine()) != null) {
    System.out.println(line);
}
```



# IO примеры

## Файл - файл, байты

Читаем байты из файла и сразу же записываем прочитанные байты в другой файл. Сравнение скорости побайтного чтения и чтения пачкой:

```java
public class Main {
    public static void main(String[] args) throws Exception {
        String source = "E:/tmp/demo.mp4";  // 1200kb
        String target = "E:/tmp/demo_copy.mp4";

        try (
                InputStream istream = new FileInputStream(source);
                OutputStream ostream = new FileOutputStream(target);
        ) {
            runWithTimeTrack(() -> readBytesAsBatch(istream, ostream, 4096));  // 28 ms
            //runWithTimeTrack(() -> readOneByteAtTime(istream, ostream));  // 7626 ms
        }
    }

    private static void readOneByteAtTime(InputStream istream, OutputStream ostream) {
        try {
            int data;
            while ((data = istream.read()) != -1) {
                ostream.write(data);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private static void readBytesAsBatch(InputStream istream, OutputStream ostream, int batchSize) {
        try {
            int readenBytesCount;
            byte[] data = new byte[batchSize];
            while ((readenBytesCount = istream.read(data)) != -1) {
                ostream.write(data, 0, readenBytesCount);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private static void runWithTimeTrack(Runnable action) {
        LocalDateTime start = LocalDateTime.now();
        LocalDateTime from = LocalDateTime.from(start);
        System.out.println("Начали: " + start);

        action.run();

        LocalDateTime finish = LocalDateTime.now();
        System.out.println("Закончили: " + LocalDateTime.now());
        long millis = from.until(finish, ChronoUnit.MILLIS);
        System.out.println("Потрачено: " + millis);
    }
}
```



# NIO

NIO означает New IO, а не Non-blocking IO. Например, API для работы с файлами в NIO использует блокирующую модель.

В стандартном IO мы работаем с *потоками* байтов или символов напрямую. В NIO мы с потоками непосредственно не работаем, а присоединяем к потоку *канал*, который пишет и читает информацию из потока в *буфер*. И главное, что пока он это делает, наша программа может выполняться дальше.

*Селекторы* - это объекты, которые могут следить за несколькими каналами на предмет наступления *событий*, например, соединение открыто, пришли данные и т.д. Т.о. можно организовать одновременную обработку нескольких источников данных в одном потоке.







# Черновик по java nio

> Канал мы получаем, например, на объекте файла. А можно ли канал "приделать" к любому потоку?

## Буфер

Буфер - это просто область памяти, которую мы выделяем под данные при работе с каналом, ведь он должен куда-то писать и читать то, что добывает из потока. Буфер может находиться в двух режимах: чтения и записи.

В nio есть несколько типов буферов. Условно их можно разделить на два вида:

* ByteBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer - по буферу на каждый примитивный тип
* MappedByteBuffer

Каждый из этих классов имеет статический метод *.allocate()* для выделения памяти под буфер:

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
```

У буфера есть 3 характеристики:

* capacity - емкость. Это все время одно и то же, максимальный размер буфера, который мы ему выделили при создании.
* position - позиция. При чтении и записи позиция каждый раз смещается и указывает соответственно на последний элемент, который мы прочитали или записали.
* limit - лимит. При записи лимит равен емкости буфера, а при чтении лимит указывает, сколько элементов мы можем прочитать из буфера, поскольку буфера может быть заполнен не до конца.

Работа с буфером обычно заключается в выполнении 4 шагов:

* Прочитать из канала и поместить прочитанное в буфер.

  Можно сделать это через канал. Логика "читаем из канала и кладем прочитанное в буфер":

  ```java
  int bytesWritten = someChannel.read(buffer);
  ```

  Или через метод самого буфера:

  ```java
  buffer.put(127);
  ```

* Перевести буфер в режим чтения методом .flip()

  При этом limit становится равен значению position, а сам position потом обнуляется, чтобы начать чтение с начала буфера.

* Прочитать данные из буфера.

  Тоже можно либо пользуясь методом канала (логика "Пишем в канал то, что находится в буфере"):

  ```java
  byte bytesRead = someChannel.write(buffer);
  ```

  Или методом самого буфера:

  ```java
  byte data = buffer.get();  // Читает один элемент
  ```

* Очистить буфер методом .clear() или .compact()

  Метод .clear() полностью очищает буфер. Метод .compact() удаляет из буфера только те данные, которые мы прочитали. Непрочитаенные он перемещает в начало буфера и последующая запись в буфер будет происходить в позицию после этих данных.

Дополнительные методы буфера:

* rewind() - переместить position в 0, чтобы можно было перечитать буфер с начала
* mark() + reset() - mark помечает текущую позицию в буфере, а reset сбрасывает текущую позицию до отмеченной.







# Черновик



Вопросы:

* Самый основной вопрос у меня пока что такой: как непосредственно происходит ввод\вывод, допустим, с диска? Ну то есть:

  * file.read()
  * ???
  * головки диска перемещаются и царапают блин

  Т.е. что происходит после того как мы запрашиваем операцию IO? Насколько я знаю, IO операции и любые другие, связанные с обращением к железу, может выполнять только ОС. Вот мы посылаем запрос ОС на чтение. Дальше она наверное как-то с помощью драйвера инициирует "физическую" IO операцию. Но как? Кто ее выполняет? Ведь драйвер это тоже программа, значит кто-то ее должен выполнить. Если это делает "главный" CPU, то получается что в любом случае никакой "параллельности" невозможно. Но есть предположение, что может быть это делает какой-то "мини" CPU, встроенный в само устройство? Мб контроллер или хз как еще. Ну в общем, сама железка непосредственно все делает, кладет куда-нибудь в свой железячный буфер, а потом когда заканчивает, как-то отовещает об этом ОС, ну там прерывание например посылает и ОС начинает из железячного буфера копировать в RAM.

# Блокирующий и неблокирующий IO

Некоторые утверждения:

* При неблокирующем IO нужно меньше тредов на обслуживание такого же количества запросов IO

  Из этого я делаю вывод, что при блокирующем на каждый запрос IO выделяется тред?

* Большинство неблокирующих фреймворков используют бесконечный цикл (называется event loop) для проверки, готовы ли данные и когда готовы, то вызываются "заинтересованные" в этих данных процессы. Чтобы этот бесконечный цикл был эффективным и не тратил попусту процессорное время, то все серьезные операционные системы предоставляют специализированный API для создания таких циклов, где все оптимизировано и продумано.

* Неблокирующий IO может быть реализован в синхронном и асинхронном стиле.

  Т.е. сам по себе "неблокирующий" не означает "параллельный" или вроде того. Что это значит, пока не понимаю.

  Но важно то, что "блокирующий" означает, что он блокирует тред. Т.е. если в текущем треде мы вызвали "неблокирующую" операцию, которая при этом просто создала второй тред и заблокировала его для ожидания IO, то эту операцию можно назвать неблокирующей действительно разве что только в кавычках.

* NIO позволяет не плодить потоки и следовательно не требует накладных расходов на синхронизацию

* Java NIO из-за необходимости быть мультиплатформенным не использует всех сильных возможностей каждой ОС. Но благодаря библиотекам вроде Netty можно использовать преимущества каждой конкретной платформы.

* Каждый поток имеет свой программный счетчик и регистры

* Есть два способа организовать IO: блокирующий и неблокирующий.

  И есть два типа IO операций: синхронные и асинхронные.

  Пока я не понимаю такого разделения. В данный момент у меня в голове синхронный=блокирующий, асинхронный=неблокирующий и я не понимаю, что значит "способ организовать IO" и "тип IO операции", это вроде одно и то же.

  UPD. ??? синхронный подразумевает, что IO-метод делает запрос на операцию IO и блокирует тред, пока операция не завершится. Асинхронный подразумевает, что IO-метод отправляет запрос на IO и сразу же делает возврат, а дальше уже мы с помощью какого-либо механизма опроса понимаем, закончен IO или нет, можем ли мы получить результат или нет.

* Под любой "блокирующей" или "неблокирующей" операцией IO лежит блокирующий системный вызов. Процессор после выполнение каждой команды проверяет, не поступило ли прерывание. Если поступило, он сохраняет стек и переходит на обработку прерывания.

* Теперь, обычно, ОС не нужно постоянно опрашивать устройство в стиле "Ну что, есть результат? А теперь? А теперь?". Она просто отдает команду на выполнение IO, а когда команда завершается, устройство вызывает прерывание и таким образом ОС пониманет, что все говото и можно передать данные нужному процессу.

* Асинхронность в программировании - это модель, когда компоненты отправляют друг другу сообщения, не ожидая получить ответ немедленно.

* Что такое мультиплексирование? Это "уплотнение канала связи за счет передачи нескольких потоков данных по одному каналу связи". При этом конечно скорость каждого потока падает, т.к. приходится делиться полосой. К чему это объяснение? А к тому, что IO в современных ОС тоже можно организовать за счет своеобразного мультиплексирования: сделать единственный поток, который будет в цикле (событийный поток, event loop) опрашивать готовность операций IO и оповещать интересующиеся программы.



Некоторые процессы:

* Вот как я понял процесс отправки данных: клиентская программа вызывает IO операцию, которая должна отсылать некоторые данные. Эти данные записываются в буфер сокета (этот буфер находится в RAM) и когда буфер заполняется, тред блокируется и управление уходит ОС. Она начинает этот буфер читать и отправлять по сети (вероятно, перемещая данные из RAM-буфера сокета в буфер сетевой карты). Когда все из буфера прочитано, он опустошается и ОС снова запускает процесс, чтобы он докинул оставшиеся данные в буфер.

  Соответственно на стороне сервера



Из Танненбаума:

* Устройства вывода в общем случае можно разделить на блочные (читай, с возможностью позиционирования - hdd, ssd, флешки) и символьные (без возможности позиционирование, например, сетевые карты).
* Устройство IO содержит буфер и контроллер. Контроллер - это "электрическая" часть устройства, его мозги. В нем есть регистры (например, регистр статуса, регистр управления и другие, не суть, главное что они есть). ОС может писать в эти регистры и таким образом отдавать устройству команды, и может читать эти регистры, чтобы узнавать о статусе устройства - например, что данные пришли и можно скопировать их из буфера устройства в буфер процесса.
* Причем где находится контроллер - это часть самого устройства или на материнке, пока не знаю. И так-то это не сильно важно вроде.
* 

## Важное

Системный вызов (СВ) тоже бывает синхронный и асинхронный. Синхронный предполагает, что вызвавший СВ процесс блокируется до полного завершения СВ. Когда СВ завершается, ОС переводит запросивший СВ процесс в состояние готовности и когда снова наступает его очередь выполняться, он гарантированно получает результаты работы СВ.

Асинхронный не предполагает блокировку вызвавшего процесса. При АСВ происходит, например, запуск операции IO, управление возвращается вызвавшему СВ процессу и он использует свой квант времени дальше. При этом подходе ему конечно приходится потом самому как-то узнавать, готовы ли результаты.

Большая часть СВ является синхронной, но в современных ОС количество АСВ увеличивается.

> Теперь бы выяснить, как ОС обрабатывает АСВ. Ведь процесс как-то должен узнать, завершеная ли операция, ради которой он делал СВ. Если, он, грубо говоря, забьет на нее? Могут ли результаты быть утеряны? В общем, как ведет себя ОС при таком сценарии.



## Полезные ссылки

Ссылки, в которых действительно были найдены важные, ключевые для понимания вещи:

* https://ps-group.github.io/os/nonblocking_io_posix
* https://studfile.net/preview/9886821/page:4/