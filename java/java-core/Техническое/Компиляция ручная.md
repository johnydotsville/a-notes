# Резюме

* "Корень". При компиляции\запуске от структуры директорий *com.company.core* не уйти. Компилировать\запускать надо всегда от корня, т.к. полные имена классов вроде *com.company.core.App* по сути содержат в себе информацию о структуре директорий, где надо искать скомпилированный файл класса и этот поиск ведется от директории запуска компилятора\исполнителя.
* javac -d
* java -classpath -cp "c:\tmp;c:\tmp\misc" com.company.core.App
* Для разделения нескольких путей в classpath используется `;` Можно брать набор путей в кавычки на случай пробелов в путях

# Подготовка

Создал директорию `...\test\com\company`. Здесь `test` - корень директории под программу, а com\company - стандартная джавовская структура пакета.

Внутри test создал директории `core` и `biz`. Получилось:

```
...\test\com\company\core
...\test\com\company\biz
```

В core положил файл App.java, это будет точка входа:

```java
package com.company.core;

import com.company.biz.Account;

public class App {
    public static void main(String[] args) {
		Account account = new Account(5000);
		System.out.println("Account start amount: " + account.getAmount());
		
		account.deposit(2500);
		System.out.println("Account current amount: " + account.getAmount());
		
		System.out.println("Demo works fine.");
	}
}
```

В biz положил файл Account, простой класс с логикой:

```java
package com.company.biz;

public class Account {
	private int amount;
	
	public Account(int amount) {
		this.amount = amount;
	}
	
	public void deposit(int amount) {
		this.amount += amount;
	}
		
	public int getAmount() {
		return this.amount;
	}
}
```

# Компилируем-запускаем

Возможные проблемы:

* Не запускается программа, ошибка JNI о том, что скомпилено более новой версией.

  Решение: указывать путь до java.exe нужной версии полностью

Вопросы стоят такие:

1. Как правильно компилировать? А именно: в какой директории нужно находиться при вызове javac?
2. Куда по умолчанию попадают скомпилированные файлы?
3. Как задать место, куда после компиляции должны попадать файлы?
4. Как запустить скомпилированную программу?
5. Можно ли разнести .class файлы куда угодно, а потом просто через *classpath* указать пути до них, чтобы все работало как будто файлы лежат нормально?
6. Как скомпилировать несколько файлов? Можно ли при этом задать какую-то маску, чтобы компилировались все файлы в директории и поддиректориях?

### 1

Компилировать полагается из корневой директории программы. В нашем примере это *test*.

В этом случае компилятор сможет найти класс Account, взяв путь из import. Если же перейти например в *test\com\company* и компилировать оттуда, тогда не найдет, потому что ищет относительно текущей директории, т.е. он будет искать в *test\com\company* структуру *com\company\core* и в ней App.java

```
cd ...\test
javac com/company/core/App.java
```

Т.о. важно помнить, что все крутится относительно корневой директории программы и структура папок должна быть как в объявлении пакета.

### 2

По умолчанию скомпилированные файлы лягут рядом с исходниками.

### 3

Задать место, куда нужно складывать скомпилированные файлы, можно с помощью ключа -d

```
javac -d bin com/company/core/App.java
```

При этом в bin сгенерируется такая же структура папок - com/company/core,biz. Чтобы запустить программу, нужно теперь перейти в bin, т.к. помним про важность структуры папок и что при запуске\компиляции надо находиться в "корне".

### 4

Запускать нужно, находясь в корне, вот так:

```
cd ...\test
java com.company.core.App
```

Нельзя, допустим, вот так:

```
cd ...\test\com\company\core
java App
```

Потому что App - это всего лишь имя файла, а реальное полное имя класса com.company.core.App и соответственно виртуальная машина при таком запуске будет искать в core структуру com/company/core, конечно ее не найдет и ничего не выполнится.

### 5 classpath

Разложить .class-файлы совсем "куда угодно" нельзя, в том плане что структура директорий должна быть соблюдена по пакету. Допустим, по "нормальному" файлы лежат так:

```
c:\tmp\com\company\core\App.class
c:\tmp\com\company\biz\Account.class
```

Мы можем переложить их например вот так:

```
c:\tmp\misc\com\company\core\App.class
c:\tmp\some\where\com\company\biz\Account.class
```

И при запуске указать в *-classpath* (или просто *-cp*) эти пути вот так (для разделения используется `;` а кавычки пригодятся, если в путях есть пробелы):

```
java -cp "C:\tmp\misc;C:\tmp\some\where" com.company.core.App
```

Но это не отменяет того, что в этих директориях должна лежать структура com/company/core и com/company/biz по форме пакета.

??? Можно ли указывать не com.company.core.App а просто App? Я думаю, что нельзя, потому что речь идет об указании полного имени класса, из которого ВМ уже автоматически выделяет директорию.

### 6

Для компиляции нескольких файлов можно указать полные пути до них:

```
javac -d bin com/company/core/App.java com/company/biz/Client.java
```

Если класс использует другой класс, то этот другой класс автоматически скомпилируется.

Можно указать только папки, а имена файлов заменить на *. При этом подпапки не сканируются, т.е. будут скомпилированы только те файлы, которые непосредственно лежат в указанных директориях:

```
javac -d bin com/company/core/* com/company/biz/*
javac -d bin com/company/*  <-- А вот это не сработает
```

