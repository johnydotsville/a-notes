И лямбды, и функциональные интерфейсы вносят в джаву концепции функционального программирования. Поэтому сперва стоит отметить несколько характерных особенностей функционального программирования.

# Функциональное программирование

Основные концепции ФП:

* Функции это объекты первого порядка

  Это значит, что с функцией можно обращаться как, например, с обычными объектами\переменными в ООП: создать объект функции и сохранить его в переменную (именно саму функцию, а не результат ее работы), передать функцию в качестве параметра в другую функцию, возвращать функцию как результат функции. В Java методы сами по себе не являются объектами первого порядка. Т.е. мы не можем из метода вернуть метод.

* Чистые функции (pure functions)

  Это функции, которые удовлетворяют двум требованиям:

  * Не имеют сайд-эффектов

    Т.е. функция в процессе своей работы не меняет ничего "вовне" себя. Например, типичный Java-сеттер имеет сайд-эффект, потому что он меняет значение в поле класса. А метод сложения двух чисел, который просто принимает числа и возвращает результат, является чистой функцией, т.к. не изменяет ничего вне себя. При этом внутри функции может быть свое локальное состояние, разные переменные, которые функция может изменять. Главное, чтобы эти изменения не влияли ни на что вне функции.

  * Выход зависит исключительно от входа

    Т.е. при одних и тех же входных параметрах результат работы будет один и тот же. Если мы передаем, грубо говоря, в функцию сложения числа 3 и 2, она всегда должна возвращать 5.

* Функции высшего порядка

  Это функции, которые удовлетворяют одному из двух требований:

  * Как минимум один параметр функции тоже является функцией
  * Результат работы функции является функцией

Тру-функциональное программирование соблюдает следующие правила:

* Не использует состояние
* Исключает сайд-эффекты
* Использует иммутабельные переменные\объекты
* Предпочитает рекурсию циклам

Не все задачи можно решить с помощью функционального программирования. Например, если функция сохраняет данные в БД, это считается сайд-эффектом. Но можно частично использовать принципы ФП и получать от них выгоду.

# Функциональные интерфейсы и лямбды

За этим термином стоит всего лишь интерфейс, у которого *строго один* метод без реализации (абстрактный). Если методов без реализации больше одного, тогда интерфейс уже не считается функциональным. Методы с реализацией (т.е. дефолтные и приватные) не считаются, их может быть сколько угодно.

```java
interface MyFunctional {
    void methodNameDoesNotMatter();
}

interface NotFunctional {
    void methodA();
    String methodB();
}
```

Лямбды - это компактный синтаксис для пользования функциональными интерфейсами.

```java
@FunctionalInterface
interface MathOperation {
    String calc(int a, int b);
}
...
MathOperation plus  = (val1, val2) -> val1 + " + " + val2 + " = " + (val1 + val2);
MathOperation minus = (val1, val2) -> val1 + " - " + val2 + " = " + (val1 - val2);
MathOperation multi = (val1, val2) -> val1 + " * " + val2 + " = " + (val1 * val2);

System.out.println(plus.calc(5, 4));   // 9
System.out.println(minus.calc(5, 4));  // 1
System.out.println(multi.calc(5, 4));  // 20

// String res = plus(5, 4);  // Так написать нельзя, обязательно надо указать метод
```

Когда мы объявляем переменную интерфейса и пытаемся поместить в нее лямбду, компилятор проверяет:

* Является ли интерфейс функциональным
* Соответствует ли количество параметров лямбды количеству параметров метода интерфейса и правильно ли с точки зрения типов используются параметры в теле лямбды. Отсюда становится понятно, почему лямбда может сопоставляться только с функциональным интерфейсом - если бы нереализованных методов было больше одного, компилятор бы не понял, на какой метод ориентироваться.
* Сходятся ли тип результата метода и тип, который возвращает лямбда

В джаве есть набор готовых функциональных интерфейсов, находятся в *java.util.function*. Правда набор странноватый после C# кажется. В C# было объявлено двадцать делегатов Func с количеством параметров от нуля до дофига, хватало на все случаи жизни. Вероятно, если надо больше, придется создать самостоятельно.

Аннотация @FunctionalInterface не позволит добавить в интерфейс больше одного абстрактного метода.