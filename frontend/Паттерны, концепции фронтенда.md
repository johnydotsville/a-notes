В JavaScript (и фронтенде в целом) есть множество полезных паттернов и трюков, помимо **троттлинга** и **дебаунса**. Вот подборка самых практичных:

---

### **1. Мемоизация (кеширование результатов функций)**
**Зачем**: Чтобы избежать повторных тяжелых вычислений.  
**Пример**:  
```javascript
const memoize = (func) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = func(...args);
    cache.set(key, result);
    return result;
  };
};

const factorial = memoize((n) => {
  return n <= 1 ? 1 : n * factorial(n - 1);
});

console.log(factorial(5)); // Вычисляет
console.log(factorial(5)); // Берёт из кеша
```

---

### **2. Паттерн «Флаг первого вызова»**
**Зачем**: Для выполнения кода только один раз (аналог `once`).  
**Пример**:  
```javascript
let isInitialized = false;

function init() {
  if (isInitialized) return;
  console.log("Инициализация...");
  isInitialized = true;
}

init(); // Сработает
init(); // Проигнорируется
```

---

### **3. Ленивая загрузка (Lazy Load)**
**Зачем**: Откладывать инициализацию ресурсов до момента реальной необходимости.  
**Пример для изображений**:  
```html
<img data-src="image.jpg" class="lazy" alt="...">
<script>
  const lazyImages = document.querySelectorAll('.lazy');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  });
  lazyImages.forEach(img => observer.observe(img));
</script>
```

---

### **4. Паттерн «Подписка/События» (PubSub)**
**Зачем**: Для гибкой коммуникации между компонентами без прямых связей.  
**Пример**:  
```javascript
const eventBus = {
  events: {},
  subscribe(event, callback) {
    this.events[event] = this.events[event] || [];
    this.events[event].push(callback);
  },
  emit(event, data) {
    (this.events[event] || []).forEach(callback => callback(data));
  }
};

// Подписываемся
eventBus.subscribe('userLogged', (user) => {
  console.log(`Пользователь ${user.name} вошёл!`);
});

// Триггерим событие
eventBus.emit('userLogged', { name: 'Alex' });
```

---

### **5. Защита от «Race Conditions» (например, в API-запросах)**
**Зачем**: Чтобы последний запрос отменял предыдущие, если они ещё не завершились.  
**Пример с AbortController**:  
```javascript
let controller = null;

async function fetchData(query) {
  if (controller) controller.abort(); // Отменяем предыдущий запрос
  controller = new AbortController();
  try {
    const response = await fetch(`/api?q=${query}`, {
      signal: controller.signal
    });
    return response.json();
  } catch (err) {
    if (err.name !== 'AbortError') console.error(err);
  }
}
```

---

### **6. Прокси-объекты для валидации**
**Зачем**: Для автоматической проверки данных при изменении.  
**Пример**:  
```javascript
const user = {
  name: '',
  age: 0
};

const validator = {
  set(target, prop, value) {
    if (prop === 'age' && (value < 0 || value > 120)) {
      throw new Error("Недопустимый возраст!");
    }
    target[prop] = value;
    return true;
  }
};

const userProxy = new Proxy(user, validator);
userProxy.age = 25; // ОК
userProxy.age = 150; // Ошибка!
```

---

### **7. Псевдосупер (имитация наследования)**
**Зачем**: Для вызова методов родителя в цепочке наследования.  
**Пример**:  
```javascript
class Parent {
  log() {
    console.log("Родитель!");
  }
}

class Child extends Parent {
  log() {
    super.log(); // Вызов родительского метода
    console.log("Ребёнок!");
  }
}

new Child().log();
// Родитель!
// Ребёнок!
```

---

### **8. Замыкания для приватных переменных**
**Зачем**: Создать «инкапсуляцию» в JS.  
**Пример**:  
```javascript
function createCounter() {
  let count = 0; // Приватная переменная
  return {
    increment() { count++; },
    getCount() { return count; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
console.log(counter.count); // undefined (нельзя получить напрямую)
```

---

### **9. Паттерн «Фабрика» (Factory)**
**Зачем**: Создавать объекты без явного указания класса.  
**Пример**:  
```javascript
function createUser(type) {
  switch (type) {
    case 'admin':
      return { role: 'admin', permissions: ['read', 'write', 'delete'] };
    case 'user':
      return { role: 'user', permissions: ['read'] };
    default:
      throw new Error("Неизвестный тип!");
  }
}

const admin = createUser('admin');
```

---

### **10. Асинхронные очереди (Promise Chaining)**
**Зачем**: Для последовательного выполнения асинхронных операций.  
**Пример**:  
```javascript
const tasks = [task1, task2, task3];
tasks.reduce((chain, task) => chain.then(task), Promise.resolve());
```

---

### **Когда что использовать?**
- **Троттлинг/Дебаунс**: События UI (скролл, ввод, клики).  
- **Мемоизация**: Тяжёлые вычисления (фильтрация, математика).  
- **PubSub**: Коммуникация между компонентами.  
- **Прокси**: Валидация данных «на лету».  

Эти паттерны покрывают 90% задач в современном JS. Какой разобрать подробнее?