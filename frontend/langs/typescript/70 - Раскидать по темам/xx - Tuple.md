# Tuple

`Tuple` - это разновидность массива. По-русски более-менее общепринято называется "кортеж".

Особенности tuple:

* Фиксированная длина массива.
* Элементы могут иметь разный тип.
* Доступ к элементам возможен только по индексу.
  * Попытки обратиться к отсутствующему индексу приводят к ошибке. В то время как если обратиться к отсутствующему индексу в обычном массиве, просто получим undefined.

Пример:

```typescript
type Info = [string, number];  // <-- Объявили Tuple-тип, длина массива 2

const tom: Info = ["Tom Sawyer", 14];
console.log(tom[0]);  // Tom Sawyer
console.log(tom[1]);  // 14
console.log(tom[2]);  // <-- Ошибка!
```

# Деструктуризация tuple

Tuple деструктурируются по таким же правилам, как и массивы:

```typescript
const tom: [string, number] = ["Tom Sawyer", 14];
const [fullname, age] = tom;

console.log(fullname);  // Tom Sawyer
console.log(age);       // 14
```

Можно пропускать значения, можно давать переменным значения по умолчанию и т.д. Подробнее о деструктуризации массивов - в конспекте по JS, раздел о продвинутом синтаксисе.

# Named tuple

Именованный кортеж - это когда мы при объявлении tuple указываем имена для каждого элемента. Однако это исключительно декоративная возможность, для наглядности. Потому что обращаться к элементам tuple по этим именам не получится, т.к. обращение априори возможно только по индексу:

```typescript
type Info = [fullname: string, age: number];  // <-- Named tuple 
const tom: Info = ["Tom Sawyer", 14];

console.log(tom[0]);  // Tom Sawyer
console.log(tom[1]);  // 14

console.log(tom["fullname"]);  // <-- Ошибка! Доступ только по индексу.
```

# Readonly tuple

## В чем проблема

Хотя на уровне синтаксиса мы не можем обращаться к неправильным индексам в tuple, но поскольку все-таки это обычный массив, то есть возможности накосячить:

```typescript
type Info = [fullname: string, age: number];
const tom: Info = ["Tom Sawyer", 10];
tom[1] = 14;  // <-- Ok, можно перезаписать значение по "правильному" индексу.
tom[2] = "Missouri";  // <-- Ошибка! Нельзя работать с "неправильным" индексом.

tom.push("Концептуальная ошибка");  // <-- Но вот так прокатит.

for (const [index, value] of tom.entries()) {
  console.log(`${index}: ${value}`);  // <-- Индекс 2 сущетвует и в нем есть значение.
}

console.log(tom[0]);  // Tom Sawyer
console.log(tom[1]);  // 14
console.log(tom[2]);  // <-- Ошибка! Но прочитать его так не получится.
```

Из примера видно, что хотя на уровне синтаксиса не удастся явно работать с недопустимыми индексами, но в целом возможность редактировать массив остается.

## Как решить проблему

Описанная проблема решается через объявление tuple как `readonly`:

```typescript
type Info = readonly [string, number];
```

В этом случае tuple действительно станет константой, которую не удастся испортить:

```typescript
type Info = readonly [fullname: string, age: number];  // <-- readonly tuple 
const tom: Info = ["Tom Sawyer", 10];

tom[1] = 14;  // <-- Ошибка!
tom.push("Концептуальная ошибка");  // <-- Ошибка!
```





# TODO

В доке есть примеры как использовать tuple с остаточными параметрами. Сходу не понял, зачем это нужно, но на всякий случай в todo оставлю:

https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types