# Идея промиса

Промис - это объект, который позволяет нам синхронно выполнить некий код, а когда он завершится, асинхронно выполнить дополнительные действия.

Сразу практический пример: подключить библиотеку lodash и с помощью нее вывести в консоль случайное число:

```javascript
function addScript(src) {
  return new Promise((resolve, reject) => {  // <-- Этот код выполнится синхронно.
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Не удалось подключить скрипт ${src}.`));
    document.head.append(script);  // <-- Скачивание начинается в этот момент. Происходит асинхронно.
  });  
}

addScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js")
  .then(result => printRandomNumber(1, 100))  // <-- А этот - асинхронно
  .catch(err => console.log(err.message));  // <-- И этот тоже.

function printRandomNumber(min, max) {
  console.log(_.random(min, max));
}
```

Комментарии:

* Функция добавления скрипта на страницу возвращает промис.
  * В данном случае мы подключаем скрипт lodash. Он лежит по известному адресу в интернете.
  * Подключение заключается в создании элемента `<script>` и добавлении его на страницу программным способом.
  * Скачивание начинается в момент выполнения .append. Оно происходит асинхронно.
    * По сути, основной скрипт только производит настройку, раздает указания. Когда он завершается, то начинается скачивание и подключение. Когда оно завершается, выполняются настроенные на соответствующие события колбэки.
  * Если элемент скрипта добавился на страницу нормально, то браузер выполняет onload, а если есть проблемы - onerror.
    * Именно поэтому мы на эти события навешиваем лямбды с вызовом resolve и reject.
    * Т.о. промис завершится, когда сработает одно из этих событий.
* На промис мы вешаем обработчики результата и ошибки.
  * В случае успеха вызываем функцию, которая пользуется lodash'ем для генерации случайного числа.
    * Как такового "результата" работы у нашего работяги нет, поэтому вызываем `resolve()`  без аргументов. Результатом является сам факт успешной загрузки скрипта и добавление его на страницу.
  * В случае ошибки просто выводим текст ошибки в консоль.

Основная польза от промисов - снижение фактора callback-hell. Вложенность колбэков становится ниже за счет того, что промисы удобно организовывать в цепочки.

В этом конспекте больше рассмотрено внешнее пользование промисами, обзорное, а более детальные механики работы методов будут в следующих конспектах.

# Базовый синтаксис промисов

```javascript
let prom = new Promise((resolve, reject) => {
  let num = Math.random() * 10;
  if (num >= 7) {
    resolve(num);
  } else {
    if (num >= 4)
      reject(new Error("Полученное число недостаточно большое."));
    else
      throw new Error("Произошла непредвиденная ошибка.");
  }
});

prom.then(
  result => console.log("Результат задачи из промиса: " + result),
  error => console.log("Задача в промисе завершилась некорректно: " + error.message)
);
```

## Колбэки resolve и reject, статус промиса

При создании промиса мы передаем ему функцию-колбэк с двумя параметрами. Общепринятые названия для них - resolve и reject. Это тоже функции, которые нам передает сам промис, и мы должны вызвать их в своей функции, чтобы отметить завершение работы промиса. На старте статус промиса `pending` ("выполняется") и если не вызвать resolve или reject, то промис останется в этом состоянии и будет считаться незавершенным.

Вызовом `resolve(результат)` мы обозначаем успешное выполнение колбэка и передаем промису результат работы. Промис при этом переходит в состояние `fulfilled`.

Вызовом `reject(ошибка)` мы обозначаем провал колбэка и передаем промису причину провала. Промис при этом переходит в состояние `rejected`.

Если возникает непойманное исключение, это то же самое, что вызвать reject и передать в него это исключение. Т.е. промис в этом случае как бы сам ловит это исключение и отклоняется с этой ошибкой.

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно. Так же как и статус меняется только один раз. Получить статус тоже невозможно.

### Синхронная работа - асинхронная обработка результата

Колбэк, который мы передаем в промис, начинает выполняться сразу при создании промиса, так что явно его запускать не надо. Промис выполняется синхронно, а обработка результата его работы происходит асинхронно. Подробнее о синхронности и асинхронности и как это организовано - в конспекте про Event Loop.

> Важное замечание: при рассмотрении примеров из ближайших разделов может возникнуть вопрос: "Если промис выполняется синхронно, то почему результат обрабатывается когда-то там потом, а не сразу?". Ответ такой: непосредственно в языке JS нет асинхронных операций, они есть только в платформе - браузере или Node. Поэтому я просто не мог написать синтетические примеры с асинхронностью. В реальных ситуациях (например из задачи в начале этого конспекта по подключению скрипта), в колбэке промиса обычно присутствуют операции, которые запускают некий реально асинхронный процесс, который завершится когда-то в будущем, а промис этого завершения не ждет и программа идет дальше.

Пока же просто визуально посмотрим на последовательность вывода в консоль:

```javascript
console.log("Начало скрипта");

new Promise((resolve, reject) => {
  console.log("В начале промиса");  // <-- Промис выполняется СИНХРОННО
  for (let i = 0; i < 10; i++) {
    syncDelay();
  }
  console.log("В конце промиса");
  resolve(7);
})
  .then(result => {  // <-- Обработка результата промиса происходит АСИНХРОННО
    console.log("Результат промиса: " + result);
  });

console.log("В конце скрипта");

function syncDelay() {  // <-- Имитация долгой синхронной работы, просто очень большой цикл
  for (let i = 0; i < 999999999; i++);
}
/*
  Начало скрипта
  В начале промиса
  В конце промиса
  В конце скрипта
  Результат промиса: 7  // <-- Т.к. обработка результата асинхронная, мы видим это на последнем месте
*/
```

## Опциональность resolve и reject

Строго говоря, в колбэке не обязательно указывать параметры, т.е. промис можно написать и вот так:

```javascript
let prom = new Promise(() => {  // <-- Нет resolve и reject в параметрах
  throw new Error("Шеф, все пропало!");
});

prom.catch(err => console.log(err.message));  // Шеф, все пропало!
```

Просто в этом случае у нас не будет возможности завершить промис самостоятельно. Например, промис из примера выше автоматически завершится reject'ом, потому что внутри колбэка выброшена ошибка. Но самостоятельно мы бы не смогли его заreject'ить, т.к. передали промису колбэк без параметров.

Соответственно, можно передать колбэк всего с одним параметром, под resolve:

```javascript
let prom = new Promise((resolve) => {
  resolve("Привет, мир!");
});

prom.then(result => console.log(result));  // Привет, мир!
```



# Обработка результата промиса

## Методы then, catch, finally

Эти методы можно объединять в цепочки, потому что каждый из них тоже возвращает промис. Более детально об этом в других конспектах.

## Метод then

Получить доступ к результату или ошибке промиса можно с помощью метода `then`, который принимает две функции:

```javascript
prom.then(
  result => console.log(result),
  error => console.log(result.message)
);
```

 ```javascript
prom.then(  // Если не планируем обрабатывать ошибки, второй колбэк можно не передавать.
  result => console.log(result)
);
 ```

Если промис завершился успешно, то выполнится первый колбэк и через свой параметр он получит результат промиса. Если промис отклонился, то выполнится второй колбэк и через свой параметр он получит ошибку, приведшую к отклонению.

Передавая колбэки в then, мы ставим их в отдельную очередь и выполняться они будут асинхронно, после того как выполнится основной скрипт.

В итоге можно сказать, что "получить результат промиса" непосредственно - невозможно. Грубо говоря, мы не можем извлечь этот результат из промиса. Единственный способ до него добраться - передать колбэк в метод then и тогда промис отдаст нам свой результат через параметр колбэка. Это замечание будет полезно для лучшего понимания цепочки промисов дальше.

## Метод catch

Если у выполняемой в промисе функции результата как такового нет (например, она просто загружает из интернета скрипт и подключает его на страницу), и нам не нужен обработчик результата, но мы хотим отлавливать ошибки, то можем использовать метод `catch` вместо then:

```javascript
prom.catch(
  error => console.log(result.message)
);
````

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
prom
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То можно принять ошибку не только из prom, но и из then.

При возникновении ошибки она проскакивает все звенья цепочки до первого попавшегося catch (или then, у которого есть второй колбэк). Если там ее не обработать, она полетит до следующего catch и так до тех пор, пока цепочка не закончится и скрипт не ляжет.

## Метод finally

Метод `finally` принимает функцию без аргументов:

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно он нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис - успешно или нет. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый метод возвращает промис, то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => {
    console.log("Выполняем общие действия.");
    return 10;  // <-- Пытаемся перекрыть результат исходного промиса
  })
  .then(result => {
    console.log(result);  // 5, т.е. finally не "проглотил" результат исходного промиса
  });
```

Подробнее о технической стороне этих методов - другом конспекте.

# Асинхронные ошибки в промисе

Важный момент касательно ошибок в промисах: если написать вот так:

```javascript
new Promise(() => {
  setTimeout(() => { throw new Error("Ошибка в промисе!"); }, 1000);  // <-- throw в setTimeout
})
  .then(result => console.log(result))
  .catch(err => console.log(err.message));
```

То в catch мы не попадем, потому что выброс ошибки произошел в отложенном коде. Ошибки ловятся "автоматически" только если происходят синхронно, непосредственно в коде колбэка.

