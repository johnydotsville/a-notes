# Массивы

## Создание массива

### Литерал массива

Является самым распространенным способом.

```javascript
let arr = [];  // Пустой массив
let arr = ["Яблоко", "Апельсин", "Груша"];
```

### Функция-конструктор

```javascript
let arr = new Array();   // Пустой массив
let arr = new Array(5);  // Массив заданного размера, вместо элементов - undefined
let arr = new Array("Яблоко", "Апельсин", "Груша");
```

Все то же самое работает и без new:

```javascript
let arr = Array(5);  // <-- Без new тоже сработает
```

### Фабричные функции

► `Array.of()` метод принимает набор элементов и создает из них массив. Может быть полезен, когда элемент один и является цифрой. В этом случае функция-конструктор создала бы пустой массив из указанного количества элементов.

```javascript
const arr = Array.of(5);  // <-- Создаст массив из одного элемента - цифры 5
const arr = Array.of(5, "Привет", 7, "Мир");  // <-- Массив из четырех элементов
```

► `Array.from` метод ([дока](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)):

* Первый параметр - это iterable-объект, из которого создается итоговый массив.
* Второй параметр - это функция, которая применяется к исходному значению и ее результат попадает в итоговый массив. Так `Array.from(guys, g => "Mr. " + g)` прибавит приставку "Mr. " к именам.
* Третий параметр - thisArg, значение, которое надо поставить в this, если он используется в функции из второго параметра.

Array.from особенно удобен, когда надо, например, из псевдомассива создать настоящий массив, или преобразовать в массив другой iterable-объект, например, Map:

```javascript
// iterable-объект
const guys = new Map();
guys.set("tom", { name: "Tom", surname: "Sawyer" });
guys.set("huck", { name: "Huck", surname: "Finn" });

const arr = Array.from(guys.values());  // <-- Из значений мапы формируем массив
arr.forEach(g => console.log(g.name));  // Tom, Huck
```

```javascript
// Псевдомассив
const guys = {  // <-- Это псевдомассив, поэтому на нем нельзя применить forEach или for of
  "0" : "Tom Sawyer",
  "1" : "Huck Finn",
  length: 2
};

const arr = Array.from(guys, g => "Mr. " + g);  // <-- Но из него можно создать настоящий массив

arr.forEach(g => console.log(g));

for (const item of arr) {
  console.log(item);
}
```

Еще есть Array.fromAsync, но о нем в конспекте про стандартные методы.

## Размер массива

Размер массива хранится в свойстве `length`:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];
let len = arr.length;  // 3
```

Важная особенность: на самом деле length это не количество элементов в массиве, а максимальный индекс + 1:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

arr[100] = "Слива";

console.log(arr.length);  // 101
```

Мы можем перезаписывать это свойство. Это может иметь смысл для быстрого укорачивания массива:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

console.log(arr);  // ['Яблоко', 'Апельсин', 'Груша']
arr.length = 2;
console.log(arr);  // ['Яблоко', 'Апельсин']. По сути, удалили один элемент.
arr.length = 0;
console.log(arr);  // []  // Очистили массив
```



## Доступ к элементам

Нумерация начинается с 0. Для доступа к элементам есть два синтаксиса:

* `[]` - позволяет задать только положительный индекс.
* `.at(-1)` - метод для получения элемента из указанного индекса. Позволяет задавать как положительный, так и отрицательный индекс. Положительный аналогичен использованию скобок. Отрицательный - ведет отсчет от конца массива. Новая возможность.
* `.with(ind, value)` - метод для изменения значения в указанном индексе. Возвращает этот же массив, с измененным значением.

```javascript
let arr = ["Яблоко", "Апельсин", "Груша", "Мандарин"];
let first = arr[0];  // Яблоко
let last = arr.at(-1);  // Мандарин
```

```javascript
let last = arr[arr.length - 1];  // По старинке
```

```javascript
let arr = [5, 7, 4, 10];

let narr = arr.with(0, 3);
console.log(arr);  // [5, 7, 4, 10]
console.log(narr);  // [3, 7, 4, 10]  // <-- Первый элемент изменился
console.log(arr === narr);  // false, narr - это уже другой массив, созданный заново
```

## Проверка на массив

Поскольку массив является объектом по своей природе, то `typeof` их не различает:

```javascript
console.log(typeof {}); // object
console.log(typeof []); // тоже object
```

Поэтому, чтобы распознать массив, есть отельный метод `Array.isArray` ([дока](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)):

```javascript
console.log(Array.isArray({})); // false
console.log(Array.isArray([])); // true
```

# Устройство массива

## Массив - это объект

Внутри массив является объектом. Соответственно, к нему применимы все правила, касающиеся объектов, например копирование по ссылке.

Движок js проводит оптимизации, за счет которых массивы работают быстро. Если мы начинаем работать с массивом как с обычным объектом, то движок начинает рассматривать его как обычный объект и соответственно отключает все оптимизации. Триггером для отключения оптимизаций служат:

* Добавление массиву произвольных свойств.

  ```javascript
  let arr = ["Яблоко", "Апельсин", "Груша"];
  arr.comment = "Массив с фруктами";
  ```

* Создание "дыр" между элементами.

  ```javascript
  let arr = ["Яблоко", "Апельсин", "Груша"];
  arr[100] = "Ананас";
  ```

* Заполнение массива в обратном порядке.

  ```javascript
  let arr = [];
  arr[1] = "Апельсин";
  arr[0] = "Яблоко";
  ```

* Хранение в массиве разнородных данных:

  ```javascript
  let arr = [
    "Яблоко", 
    { name: "Tom" }, 
    function() { console.log("Функция хранится в массиве.") },
    true
  ];
  
  
  console.log(arr[0]);  // Яблоко
  console.log(arr[1].name);  // Tom
  arr[2]();  // Функция хранится в массиве.
  ```

## Индексы - это свойства

Числа, которые мы указываем в квадратных скобках, чтобы получить доступ к индексу массива, являются не более чем свойствами объекта. Причем они являются строковыми свойствами, т.е. указанное в скобках число преобразуется в строку. А сам синтаксис квадратных скобок для массива - то же самое, что обращение к произвольному свойству объекта:

```javascript
const arr = ["Tom", "Huck"];
console.log(arr[0]);  // <-- Это число преобразуется в строку
console.log(arr["1"]);  // <-- А тут уже указана строка, поэтому преобразования не будет
console.log(arr["length"]);  // 2, просто обращаемся к свойству, то же самое что arr.length
```

Раз индексы, это свойства, то можно удалить элемент массива оператором `delete`, как обычное свойство объекта:

```javascript
const arr = ["Tom", "Huck"];
delete arr[0];  // <-- length остается равным 2

arr.forEach(i => console.log(i));
```

Однако такое удаление сделает массив разреженным. Удалять таким образом элементы не надо, для этого есть метод splice.

## Разреженные (sparse) и плотные (dence) массивы

Разреженные массивы - это массивы с "дырками" между элементами, когда реальное количество элементов меньше свойства length. Плотные массивы - это массивы без дырок.

Несколько способов создать разреженный массив:

```javascript
//         0  1 2 3  4  5 6 7 8
let arr = [5, , , 7, 3, , , , ,];  // length = 9
```

```javascript
let arr = new Array(5);
arr[10] = 777;  // <-- Элемент один, а length = 11
```

Разреженные массивы занимают меньше памяти, чем "плотные" (dence), но за счет этого обрабатываются медленнее. Поиск значения в них работает примерно со скоростью поиска свойства в обычном объекте. Итерирующие методы массивов, вроде map, не обходят "дырки", но если возвращают новый массив на основе старого, то в новом тоже будут дырки, на тех же местах.

Дырки отображаются в браузере как empty, но на самом деле являются undefined-элементами:

```javascript
const arr = new Array(5);
arr[3] = "Hello";
console.log(arr);  // [empty, empty, empty, 'Hello', empty]  // <-- empty это undefined на самом деле

for (const item of arr) {
  if (item === undefined) {
    console.log("Нет понятия empty, есть undefined.");
  } else {
    console.log(item);
  }
};

let dense = arr.filter(() => true);  // <-- Так можно избавиться от дырок
console.log(dense);  // ['Hello']
```

# Перебор элементов

## for ... of

Цикл `for ... of` позволяет нам перебрать только числовые свойства массива, т.е. по сути только сами элементы:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let item of arr) {
  console.log(item);  // "Яблоко", "Апельсин", "Груша"
}
```

Нам доступен только сам элемент, без индекса. Особенности:

* Если в процессе итерации массив изменится, то эти изменения повлияют на итерацию. Например, если внутри цикла обхода добавить элемент в массив, получим бесконечный цикл.

## for

Обычный `for` может пригодиться, если нужны какие-нибудь проверки непосредственно индекса. Например, вывести только элементы на четных позициях:

```javascript
//             0          1         2
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  if (i%2 == 0) console.log(arr[i]);  // Яблоко, Груша
}
```

На самом деле можно получить индекс и через for of, если знать про метод `entries()` и деструктурирующее присваивание:

```javascript
const arr = ["Tom", "Huck", "Mary", "Sid"];

for (const [ind, item] of arr.entries()) {
  console.log(`${ind}: ${item}`);
} 
/*
  0: Tom
  1: Huck
  2: Mary
  3: Sid
*/
```

## for ... in

Этот цикл не рекомендуется использовать для перебора массивов, потому что:

* Он оптимизирован для работы с произвольными объектами, но не массивами.
* Он перебирает все свойства объекта, а в случае массива нас интересуют только числовые. В случае т.н. "псевдомассивов" можем получить лишнее.

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let item in arr) {
  console.log(arr[item]);  // С виду все нормально, но есть нюанс.
}
```

## .forEach()

`.forEach()` это метод массива. Принимает лямбду с тремя параметрами `(текущий элемент, индекс, ссылка на массив)`, из которых только первый обязательный. Ничего не возвращает. Более подробно рассмотрен в конспекте про стандартные методы массивов:

```javascript
const arr = ["Tom", "Huck", "Mary", "Sid"];

arr.forEach((item, ind, farr) => {
  console.log(`${ind}: ${item}`);
});
```

# Многомерные массивы

Элементами массива так же могут быть массивы:

```javascript
let arr = [
  [0, 0, 3],
  [0, 7, 0],
  [4, 0, 0]
];

let center = arr[1][1];  // 7
```

Правильный синтаксис обращения к элементам во вложенном массиве - именно `[i][j]`, а не `[i, j]`.

# Сравнение массивов

## Через оператор ==

Массивы нельзя сравнивать через оператор равенства, потому что он не работает с ними как с каким-то особенным типом. Массив - это объект, поэтому два массива будут равны, только если указывают на один и тот же объект:

```javascript
let arr1 = [7, 5, 3];
let arr2 = arr1;

console.log(arr1 == arr2);  // true
console.log([7, 5, 3] == [7, 5, 3]);  // false
```

Кроме того, сравнение с примитивами может дать хитрый результат:

```javascript
console.log(0 == []);    // true
console.log("0" == []);  // false
```

В первом случае массив преобразуется в примитив - в строку. Он пустой, поэтому превратится в строку `""`. Она для сравнения с 0 преобразуется в число и тоже станет 0. Поэтому итог - true. Во втором случае получится сравнение `"0" == ""`, поэтому будет false.





