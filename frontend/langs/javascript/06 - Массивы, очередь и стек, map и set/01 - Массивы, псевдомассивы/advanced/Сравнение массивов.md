# Оператор равенства не подходит

Массивы нельзя сравнивать через оператор равенства, потому что он не работает с ними как с каким-то особенным типом. Массив - это объект, поэтому два массива будут равны, только если указывают на один и тот же объект:

```javascript
let arr1 = [7, 5, 3];
let arr2 = arr1;

console.log(arr1 == arr2);  // true
console.log([7, 5, 3] == [7, 5, 3]);  // false
```

Кроме того, сравнение с примитивами может дать хитрый результат:

```javascript
console.log(0 == []);    // true
console.log("0" == []);  // false
```

В первом случае массив преобразуется в примитив - в строку. Он пустой, поэтому превратится в строку `""`. Она для сравнения с 0 преобразуется в число и тоже станет 0. Поэтому итог - true. Во втором случае получится сравнение `"0" == ""`, поэтому будет false.

# Как сравнивать

## lodash.isEqual

Самый надежный способ сравнить массивы - использовать библиотеку `lodash`, метод `isEqual`. Он проводит сравнение рекурсивно и сравнивает сложные типы правильно. Т.е. объекты сравниваются не по ссылке а по содержимому и т.д. Так что для сложных массивов это самый адекватный способ.

## Самописные сравнения

Если известно, что в массиве простые значения, например только числа или строки, то можно самому написать сравнение.

Через метод `every()`:

```javascript
function arraysEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) return false;
  return a.every((val, i) => val === b[i]);
}

console.log(arraysEqual([1, 2], [1, 2])); // true
console.log(arraysEqual([1, NaN], [1, NaN])); // false (но NaN !== NaN)
```

Через метод `toString()`:

```javascript
console.log([1, 2, 3].toString() === [1, 2, 3].toString()); // true
console.log([1, NaN].toString() === [1, NaN].toString()); // true ("1,NaN")
```



