# Массивы

## Базовое устройство

* Создание массива
  * Литерал массива
  * Функция-конструктор
    * Пустой массив
    * Массив заданного размера
    * Массив с начальными элементами
  * Фабричные функции
    * `Array.of()`
    * `Array.from(iterable, fn, thisArg)`
      * Формирование массива из псевдомассива или другого iterable-объекта
* Размер массива, свойство length
  * length - это не количество элементов.
* Обращение к элементам массива
  * Квадратные скобки [ ]
  * `arr.at()`
    * Отрицательный и положительный индекс, `arr.at(-1)`
  * `let arr = arr.with(ind, value)`
* Проверка на массив.
  * `typeof` vs `Array.isArray(arr)`
* Массив - это объект.
  * Движок оптимизирует работу с массивами, если не допускать следующих косяков:
    * Дыры в массиве, разнородные данные, добавление произвольных свойств, заполнение массива в обратном порядке.
* Индексы массива - это свойства объекта, причем строковые. Число преобразуется в строку.
  * Синтаксис квадратных скобок у массива - то же самое, что обращение через квадратные скобки к свойствам в обычном объекте.
* Разреженные (sparse) и плотные (dence) массивы.
  * Удаление элемента массива оператором delete как обычного свойства объекта.
* Обход элементов массива.
  * Цикл for ... of обходит только числовые свойства.
    * Получение индекса в for ... of с помощью arr.entries() и деструктуризации.
  * Цикл for.
  * Цикл for ... in
    * Не рекомендуется для обхода массивов.
      * Оптимизирован для обхода свойств обычных объектов, но не массива.
      * Может захватить лишние свойства, не являющиеся числовыми.
  * Метод `arr.forEach(item, index, arrLink)`
* Сравнение массивов через == или === сравнивает ссылки на массив, а не элементы массивов.
* Псевдомассивы.
  * Это объекты, у которых все свойства являются числовыми и есть свойство lenght.
  * Вызов методов массива на псевдомассивах.
    * Прототипом псевдомассива является не массив, поэтому методы не работают.
    * Перегон псевдомассива в настоящий массив.
    * Вызов метода через прототип, например `Array.protototype.filter.call(pseudo, i => i > 5)`

## Стандартный методы

* Статические методы
  * `Array.of(5)`, `Array.of(5, 6, 7)`
  * `Array.from(iterable, fn, thisArg)`
  * `Array.fromAsync(???)` TODO
  * `Array.isArray(arr)`
* Методы экземпляра
  * Обход и проверка элементов
    * Перебор элементов
      * `forEach(function(item, index, array))`
      * `entries()`, `keys()`, `values()` TODO
    * Преобразование элементов
      * `map(function(item, index, array))`
    * Поиск элемента по предикату
      * `filter(function(item, index, array)`
      * `find(fn), findIndex(fn), findLastIndex(fn)`, где `fn = function(item, index, array)`
    * Поиск элемента по значению
      * `indexOf(item [, start])`, `lastIndexOf(item [, start])`
      * `includes(item [, start])`
    * Проверка каждого элемента на условие
      * `some(fn)`, `every(fn)`
    * Расчет итога по массиву
      * `reduce(function(accumulator, item, index, array) [,initialAccumValue])`
      * `reduceRight(тут то же самое)`
  * Модификация структуры массива
    * Плоский массив
      * `flat()`, `flat(2)`
      * `flatMap((item, index, arrayItself), thisArg`
    * Удаление, добавление, замена элементов
      * `splice(start [, deleteCount, item1, item2 ... itemN])`, start мб <0
    * Извлечение подмассива, копирование массива
      * `slice([start, end])`
    * Объединение массивов
      * `concat(arg1, arg2, ... argN)`
  * Изменение порядка элементов
    * Сортировка и инверсия
      * `sort(fn)`, можно не передавать функцию, что тогда?
      * `reverse()`, `toReversed()`
    * Перемещение элементов в пределах массива
      * `copyWithin(insertTo, [takeFrom, takeTo))`
  * Прочее
    * Преобразование массива в строку
      * `join(соединитель)`
      * `toString(), toLocaleString()`
    * Заполнение элементов указанным значением
      * `fill(value, [from, to))`

# Очередь и стек

Роль очереди и стека в JS выполняет массив, т.к. поддерживает добавление и удаление и в конец, и в начало.

## Стек

* `push(item)`
  * Добавляет в конец.
  * Возвращает новую длину массива.
  * Разом можно добавить несколько элементов, через запятую.
* `pop()`
  * Извлекает элемент с конца. Элемент при этом исчезает из массива.
  * Возвращает извлеченный элемент.

## Очередь

* `unshift(a, b, ..., z)`
  * Добавляет в начало.
  * Возвращает новую длину массива.
  * При добавлении нескольких элементов они добавляются в обратном порядке, потому что метод работает так как будто вызван несколько раз с одним значением.
* `shift()`
  * Извлекает из начала. Элемент при этом исчезает из массива.
  * Возвращает извлеченный элемент.

# Map и Set

## Map

* Хранит данные в формате `ключ: значение`.
  * Ключ не приводится к строке, а сохраняет свой тип.
  * Алгоритм, по которому мапа сравнивает ключи, переопределить невозможно.
* Создание мапы.
  * Пустая.
  * С начальными значениями.
  * Из итерируемого объекта.
* Стандартные операции
  * Установка и получение значения.
    * `set(key, value)`
      * Возвращает эту же мапу, поэтому можно делать цепочки из set.
    * `get(key)`
  * Удаление элемента.
    * `delete(key)`
  * Очищение всей коллекции.
    * `clear()`
  * Наличие ключа.
    * `has(key)`
  * Размер коллекции.
    * `size()`
* Перебор элементов.
  * Методы `keys()`, `values()`, `entries()`
* Преобразования.
  * Создать объект из мапы.
    * `Object.fromEntries()` + `m.entries()`

## Set

* Создание сета.
  * Пустого.
  * С начальными значениями.
* Стандартные операции.
  * Добавление элемента.
    * `add(value)`
      * Возвращает тот же сет, поэтому можно делать цепочки из add.
      * Повторное добавление элемента, который уже есть, ни к чему не приводит.
        * Сравнение объектов идет по ссылке, а не по содержимому.
  * Удаление элемента.
    * `delete(item)`
      * Возвращает true, если элемент был в коллекции и удалился. false, если его не было.
  * Очистка всей коллекции.
    * `clear()`
  * Наличие элемента.
    * `has(item)`
  * Размер коллекции
    * `size()`
  * Перебор элементов.
    * Методы `keys()`, `values()`, `entries()`

# Методы keys, values, entries

* Для массивов, мап и сетов
  * Эти методы можно вызвать на самих экземплярах.
  * Возвращают эти методы - итерируемый объект.
* Для объектов
  * Эти методы находятся в функции Object и вызываются с нее.
  * Возвращают эти методы - массив.
* Т.е. получается этакая инверсия - для объектов возвращают массив, а для "массивов \ коллекций" - объект итерируемый.
* Запись - это массив из двух элементов. Под 0 индексом хранится ключ, под 1 индексом - значение.

## Массивы

* `keys()` - возвращает индексы элементов.
* `values()` - возвращают сами элементы.
* `entries()` - возвращают записи, где в 0 лежит индекс элемента, а в 1 - значение.

## Map

* `keys()` - возвращают ключи мапы.
* `values()` - возвращают значения мапы.
* `entries()` - возвращают записи. В 0 лежит ключ, а в 1 - значение.
* Если перебирать непосредственно мапу, без методов, то перебираются записи.

## Set

* `keys()`, `values()` - по сути идентичные методы, т.к. оба возвращают элементы сета.
* `entries()` - возвращают записи, но в обоих индексах записи лежит значение.

## Объекты

* `keys()` - возвращает имена свойств объекта.
* `values()` - возвращает значения свойств объекта.
* `entries()` - возвращает записи, в 0 имя свойства, в 1 - значение свойства.