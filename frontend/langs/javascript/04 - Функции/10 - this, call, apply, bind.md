В этом конспекте уже начинают встречаться объекты, хотя про них конспект идет только в следующем разделе. Но все эти вещи, например касающиеся this, bind и т.д. идеально вписываются в конспект по функциям и разделять их не хочется. В любом случае, если что-то про объекты тут не понятно интуитивно, то можно сначала почитать раздел про объекты.

# this

## Момент вычисления this

`this` - это ключевое слово, а не переменная или поле. В JS значение this определяется каждый раз при [вызове функции](https://stackoverflow.com/questions/28016664/when-you-pass-this-as-an-argument/28016676#28016676). Правило, по которому определяется значение для this, зависит от способа вызова функции.

Есть семь основных правил вычисления this. Пять из них можно отнести к автоматическому, и в двух случаях мы сами явно можем указать значение для this.

# Автоматическое определение this

## this в скрипте

Когда this используется непосредственно в скрипте, он указывает на глобальный объект, независимо от режима (строгий или обычный - не важно).

```javascript
"use strict";
console.log(this.innerWidth);  // 768
```

```javascript
console.log(this.innerWidth);  // 768
```

## Вызов обычной функции

При вызове обычной функции, не принадлежащей объекту, this указывает на глобальный объект (в обычном режиме) или равно undefined (в строгом режиме).

```javascript
function foobar() {
  console.log(this.innerWidth);
}

foobar();  // 990 (текущая ширина вьюпорта)
```

В браузере этот код вернет текущую ширину вьюпорта (окна браузера), потому что this установится на объект window.

Со вложенными функциями то же самое, this будет undefined или указывает на глобальный объект:

```javascript
function outer() {
  
  function inner() {
    console.log(this);
  }

  console.log(this);
  inner();  // Window
}

outer();  // Window
```

## Вызов метода объекта

При вызове функции как метода объекта, this указывает на этот объект.

```javascript
let user = {
  name: "Tom",
  hello() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

user.hello();  // Hello, my name is Tom
```

## Вызов функции через new

Когда функция вызывается с использованием ключевого слова new (т.н. "функция-конструктор"), то в начале этой функции неявно создается новый объект и this указывает на него, а в конце функции он возвращается:

```javascript
function User(name) {
  // this = {};  // Неявно
  this.name = name;
  // return this;  // Неявно
}

let user = new User("Tom");
console.log(user.name);
```

## Лямбды

Чтобы понять, какой this будет в лямбде, надо понять, какой он будет во внешнем блоке в *момент создания лямбды*.

Несколько примеров для наглядности:

► Пример 1.

```javascript
function Foobar(func) {  // <-- Функция-конструктор
  // this = {};
  this.innerWidth = "Ширина";
  func();
  // return this;
}

let f = () => {
  console.log(this.innerWidth);
  // Несмотря на тело лямбды из одной строки, фигурные скобки
  // здесь использованы специально для наглядности, чтобы визуально
  // обозначить вложенность блока лямбды в блок скрипта.
};

Foobar(f);  // <-- Что здесь выведется в консоль?
```

Здесь *момент создания лямбды* - это момент, когда выполнение скрипта доходит до строки `let f = () => console.log(this.innerWidth);`. *Момент выполнения лямбды* - когда выполняется функция Foobar и выполнение скрипта доходит до строки `func();`. Внешний блок в момент создания лямбды - это скрипт. В скрипте this указывает на глобальный объект, window. Стало быть, когда выполняется лямбда, this указывает на window и в консоль выводится цифра - текущая ширина вьюпорта, например 768, а не слово "Ширина".

► Примеры 2 и 3.

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}
```

В этих примерах интерес будет в том, что *лямбда **создается** внутри функции*, стало быть внешним блоком для лямбды является функция foobar. Поскольку функцию можно вызвать по-разному - как обычную функцию и как метод - то от способа ее вызова будет зависеть значение this внутри нее, а значит лямбду это коснется напрямую.

Ситуация 1:

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}

let f = foobar();
f();  // <-- Что здесь выведется в консоль?
```

foobar вызывается как обычная функция, значит this в ней указывает на глобальный объект, window. Поскольку лямбда создается во время выполнения foobar, то получает значение this такое же, какое оно в foobar. Поэтому в консоль лямбда выводит текущее значение свойства innerWidth объекта window, например, 768.

Ситуация 2:

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}

let win = {
  innerWidth: "Ширина"
};

win.foobar = foobar;  // <-- Добавляем в объект win метод foobar

let f = win.foobar();
f();  // <-- Что здесь выведется в консоль?
```

Здесь мы создаем объект `win` с таким же свойством, какое есть у глобального объекта window, innerWidth. Потом добавляем в объект win функцию foobar в качестве метода и вызываем этот метод, чтобы создать лямбду и положить ее в переменную f. При выполнении метода foobar, this в нем указывает на win, стало быть и в созданной лямбде this будет указывать на win. Поэтому когда мы выполняем лямбду, в консоль выводится слово "Ширина", а не цифра с шириной вьюпорта.

# Явное задание this

## Методы call и apply

Это методы объекта функции. Оба они позволяют вызвать функцию, явно указав объект, который надо положить в this. Отличия в том, что call принимает параметры для функции отдельными значениями, а apply - псевдомассивом:

```javascript
call(context, arg1, arg2, argN);  // Параметры - отдельными значениями
```

```javascript
apply(context, [arg1, arg2, argN]);  // Параметры - псевдомассивом
```

Примеры:

```javascript
let tom = { name: "Tom" };
let huck = { name: "Huck" };

let hello = function(age, state) {
  console.log(`Hello! My name is ${this.name}. I'm ${age} years old. I live in ${state}.`);
}

hello.call(tom, 13, "Missouri");  // Каждый параметр вызываемой функции передается отдельно
hello.call(huck, 14, "Illinois");

hello.apply(tom, [13, "Missouri"]);  // Параметры вызываемой функции передаются псевдомассивом
hello.apply(huck, [14, "Illinois"]);
```

Первым параметром передаем контекст, а второй и последующие параметры - собственные параметры вызываемой функции.

## Метод bind

Бывают ситуации, когда нужно передать метод объекта куда-то в качестве колбэка. Но метод, выдернутый из объекта, не будет работать как надо, потому что в момент его вызова, в this будет не этот объект, а что-то другое:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

user.intro();  // I am Tom

setTimeout(user.intro, 1000);  // I am ""
```

На этот случай существует метод `bind`.  Это метод объекта функции, он принимает объект, который надо использовать в качестве this, и возвращает новую функцию с "правильным" this. Подробнее о реализации механики bind - дальше в отдельном разделе. А вот просто пример использования, который чинит ошибку из предыдущего примера:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

user.intro();  // I am Tom

let binded = user.intro.bind(user);  // <-- Прибиваем к методу intro объекта user правильный this
setTimeout(binded, 1000);  // I am Tom
```

# Подробнее о методе bind

## Механика метода bind

Метод bind *не изменяет исходный объект функции*, он возвращает новую функцию-обертку, которая вызывает исходную, передавая ей объект, который нужно использовать в качестве this. Для понимания как это примерно устроено, рассмотрим такой пример "самодельной" реализации bind, названной `link`:

```javascript
function link(zis) {
  let origin = this; // в this лежит объект функции, на которой вызван метод link
  
  return function(...args) {
    origin.call(zis, ...args);
  };
}

let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

user.intro.link = link;
let f = user.intro.link(user);

setTimeout(f, 1000);  // I am Tom
```

Комментарии:

* Если вызвать на функции метод, то внутри него this будет указывать на эту функцию. Все потому, что функция по своей природе является объектом, а при вызове метода на объекте, как известно, this указывает на этот объект.
* Поэтому мы сначала превращаем функцию link в метод функции intro таким образом `user.intro.link = link;`
* Следовательно, когда мы вызываем `user.intro.link(user);`, то this внутри link указывает на функцию intro.
* Т.о., выражением `origin = this;` мы сохраняем в переменную origin исходную функцию intro.
* Затем возвращаем новую функцию-обертку, которая вызывает исходную функцию с помощью call, передавая ей правильный объект под this.
  * Промежуточная переменная origin нужна, чтобы сохранить текущее значение this (замыкания нам в помощь). Нельзя было бы написать в обертке `this.call(pthis)`, потому что this - динамическое и в момент вызова обертки, this указывало бы не на intro, а на что-то другое.
* Через `...args` мы оставляем возможность передавать в функцию параметры.

Можно было бы написать link через лямбду, воспользовавшись тем, что this в лямбде вычисляется в момент ее создания и таким и остается:

```javascript
function link(zis) {
  return (...args) => this.call(zis, ...args)
}
```

this будет указывать на функцию, на которой link вызвана как метод, а zis - это объект, на котором эта функция должна быть вызвана.

## Примеры

Просто несколько примеров на закрепление.

► Прибьем контекст к обычной функции, использующей this:

```javascript
function intro() {  // <-- Обычная функция, но использует this
  console.log("I am " + this.name);
}

let user = {
  name: "Tom"
};

intro();  // I am "" // Нет контекста
let f = intro.bind(user);  // Прибили контекст
f();  // I am Tom  // Контекст появился, поэтому name теперь имеет значение
```

► Сохраним контекст для метода, выдернутого из объекта:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);
f();  // I am Tom
```

► Демонстрация того, что bind не изменяет исходную функцию:

```javascript
function intro() {
  console.log("I am " + this.name);
}

let user = {
  name: "Tom",
}

intro();  // I am ""
intro.bind(user);
intro();  // I am ""  // <-- Исходная функция intro не изменилась, поэтому и результат такой же

let introBinded = intro.bind(user);  // <-- Нужно сохранить новую функцию
// <-- и тогда при ее использовании она вызовет исходную функцию, передав ей контекст
introBinded();  // I am Tom
```

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro;  // <-- Выдернули функцию из объекта, чтобы потерять контекст
f();  // I am ""  // <-- Конекст потерян, поэтому this.name дает пустую строку
let binded = f.bind(user);  // <-- Прибили к функции контекст
binded();  // I am Tom

let fb = user.intro.bind(user);
fb();  // I am Tom
```

► Стирание или *полная* замена исходного объекта другим объектом не повлияет на bind, потому что он запомнил ссылку на исходный объект:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);  // <-- 1. user будет запомнен в его текущей форме

// <-- 2. Делаем вызов с задержкой, чтобы успеть запороть user'а
setTimeout(f, 1000);  // <-- 4. I am Tom  // Все равно все правильно

user = "Стерли!";  // <-- 3. Уничтожаем объект контекста до момента вызова прибитой функции
```

По той же причине, если подменить объект user на другой с аналогичной структурой, на вызов это не повлияет:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Tom

user = {
  name: "Huck",
  intro() {
    console.log("Вообще другая функция.");
  }
}
```

Но вот если *изменить* исходный объект (а не *заменить*), то эти изменения повлияют на вызов прибитой функции:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Huck

user.name = "Huck";  // <-- Новое имя учтется
user.intro = function() {  // <-- А новая реализация метода - нет
  console.log("Вообще другая функция.");
}
```

Функция вызвалась исходная, потому что в момент прибития ссылка запомнилась именно на исхоную функцию. Так что замена метода в объекте на вызов прибитой функции никак не влияет.

Опять же, нюанс, вроде бы очевидый из описания bind, но все же напишу: фиксируется только реализация *прибиваемой* функции. Все остальное - будь то данные, или другие функции, могут изменяться. Пример:

```javascript
let user = {
  name: "Tom",
  intro() {  // <-- Этот метод будем прибивать
    console.log("I am " + this.name);
    this.demo();
  },
  demo() {  // <-- А этот заменим, и прибитая функция вызовет замененную версию
    console.log("foobar");
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  /*
  I am Huck
  HELLO, WORLD!  // а не foobar
*/

user.name = "Huck";
user.intro = function() {
  console.log("Вообще другая функция.");
}
user.demo = function() {
  console.log("HELLO, WORLD!");
}
```

## bindAll

Импровизированный метод замены всех методов объекта на аналогичные, но с прибитым контекстом:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

for (let key in user) {  // <-- "bindAll"
  if (typeof user[key] === 'function') {
    user[key] = user[key].bind(user);
  }
}
```

## Альтернатива bind'у

Пишу просто для справки. Альтернатива с уязвимостью. Можно сохранить контекст, если создать функцию-обертку:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = function() {
  user.intro();  // <-- Используем замыкание, чтобы не потерять контекст
};

f();  // I am Tom
```

Уязвимость заключается в том, что к моменту вызова функции f, в объекте user может измениться реализация метода intro:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = function() { 
  user.intro() 
};

// <-- Отложим вызов, чтобы успеть изменить объект
setTimeout(f, 1000);  // "Вообще другая функция. name: "Huck""

user = {
  name: "Huck",
  intro() {  // <-- Изменили реализацию метода
    console.log("Вообще другая функция. name: " + this.name);
  }
}
```

Как будто такой сценарий маловероятен, какой смысл заменять метод таким образом? Но факт есть факт. Bind бы такого не допустил, т.к. он возвращает новый объект функции на основе существующего и стало быть замена функции в объекте ему нипочем. Однако конечно от замены данных мы не застрахованы:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Tom

user = {
  name: "Huck",
  intro() {
    console.log("Вообще другая функция.");
  }
}
```


