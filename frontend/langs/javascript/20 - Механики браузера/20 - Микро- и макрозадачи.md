# Микро- и макрозадачи

Задачи делятся на микро- и макрозадачи. Вообще, таких терминов вроде бы нет в спеке, есть просто задачи, которые собираются в так называемые [task queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue) и [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) (еще называется PromiseJobs). Соответственно, условно задачи из первой очереди можно для наглядности назвать *макрозадачами*, а задачи из второй очереди - *микрозадачами*.

Написанное далее применимо к браузеру (могут быть технические неточности по сравнению со спекой, но судя по примерам с сайта Кантора, с практической точки зрения выглядит правдопободно):

* Микрозадачи - это:
  * Колбэки, переданные в методы промисов (then, catch, finally).
  * Intersection Observer.
  * Колбэки, переданные в функцию queueMicrotask.
  * Подключенный через динамический import(src) скрипт.
* Макрозадачи - это (несколько примеров, возможно это не все и есть еще):
  * Колбэки, переданные в setTimeout, setInterval.
  * mousemove, mouseover, click и прочие события.
  * И т.д.

# Примеры

Для тренировки понимания очередности выполнения микро- и макрозадач:

### Пример 1

```javascript
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');
```

Сначала выполняется сам главный скрипт. Тело промиса выполняется синхронно, поэтому надпись из него видна сразу. Потом последний вывод в консоль из главного скрипта. Т.к. сам скрипт считается макрозадачей, поэтому дальше должны выполниться все микрозадачи. В данном случае это единственный колбэк для промиса, переданный в then. Ну и потом, поскольку микрозадач больше нет, то берется следующая макрозадача, т.е. колбэк из setTimeout. Ответ:

```
Создание промиса
Конец скрипта
Обработка промиса
Таймаут
```

### Пример 2

```javascript
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve().then(() => console.log(5));
setTimeout(() => console.log(6));
console.log(7);
```

Сначала выполняется основной скрипт, поэтому 1 и 7. Затем идут микрозадачи, поэтому 3 и 5. В микрозадаче из второго промиса ничего не выводится, вместо этого в очередь добавляется новая макрозадача. Микрозадачи завершены, поэтому настал черед выполнять макрозадачи. Поэтому 2 и 6. Ну в конце 4. Ответ:

```
1  ,  7  ,  3  ,  5  ,  2  ,  6  ,  4
```

### Пример 3

```javascript
console.log("Script start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    queueMicrotask(() => console.log("queueMicrotask"));
  })
  .then(() => console.log("Promise 2"));

console.log("Script end");
```

```
Script start
Script end
Promise 1
Promise 2
queueMicrotask  - все микротаски выполняются до макротасок
setTimeout
```

### Пример 4

```javascript
console.log("Старт");

import('./module.js')
  .then(() => console.log("Модуль загружен"));

setTimeout(() => console.log("Таймаут"), 0);

Promise.resolve()
  .then(() => console.log("Промис"));
```

```
Старт
Промис
Модуль загружен
Таймаут
```

А вот если бы последний промис не был зарезолвлен сразу, тогда не было бы гарантий очередности между import и промисом. Тогда бы мы наверняка могли бы сказать, что сначала будет Старт, а в самом конце Таймаут. А что было бы вторым и третим зависело бы от того, что быстрее зарезолвится - импорт или промис.

