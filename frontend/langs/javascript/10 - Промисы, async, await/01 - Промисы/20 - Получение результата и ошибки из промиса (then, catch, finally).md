# Результат промиса

Результат промиса - это значение, которое мы передаем в колбэки resolve или reject в экзекуторе.

Переданное через них значение помещается в системное поле промиса, которое называется `[[PromiseResult]]`. Т.е. как бы и "результат" и "ошибка" по сути одно и то же - и то, и то считается `результатом` промиса и хранится в одном поле.

Получить доступ к результату напрямую из объекта промиса нельзя. Чтобы получить этот результат, мы должны зарегистрировать колбэк через методы `then` или `catch`, которые есть у промиса. Когда промис завершится, эти колбэки будут вызваны и получат результат промиса через свой аргумент.

Колбэки, которые мы передаем в методы then \ catch \ finally, будем называть `подписчиками`. Пригодится в будущих конспектах.

Для хранения подписчиков у промиса есть два системных поля:

* `[[PromiseFulfillReactions]]` - подписчики на успешное завершение промиса.
* `[[PromiseRejectReactions]]` - подписчики на неуспешное завершение промиса (на отклонение).

# Метод .then

```javascript
prom.then(onFulfilled, onRejected);
```

У метода `then` два параметра:

* `onFulfilled` - подписчик на успешное завершение промиса.
* `onRejected` - подписчик на отклонение промиса.

Например:

```javascript
prom.then(
  result => console.log(result),       // Выполнится, если промис fulfilled
  error => console.log(error.message)  // Выполнится, если промис rejected
);
```

Т.о. через then мы можем передать функции-подписчики, которые хотим выполнить после того как промис завершится. Подписчики при выполнении получат результат промиса через свой единственный аргумент.

Можно передать единственную функцию, только под успешное завершение, а ошибку ловить отдельным методом catch:

```javascript
prom.then(
  result => console.log(result)
);
```

# Метод .catch

```
prom.catch(onRejected);
```

У метода `catch` единственный параметр:

* `onRejected` - подписчик на отклонение промиса.

Например:

```javascript
prom.catch(
  error => console.log(error.message)
);
```

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
new Promise((resolve, reject) => {
  foobar();
})
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То мы поймаем ошибку и в том случае, если она возникнет в исходном промисе, и в том, если она возникнет в колбэке из then.

При возникновении ошибки она проскакивает все звенья цепочки до первого попавшегося catch (или then, у которого есть второй колбэк). Если там ее не обработать, она полетит до следующего catch и так до тех пор, пока цепочка не закончится. Если в итоге ее так и не обрабоать, то программа не ляжет, но движок сгенерирует событие unhandledrejection. Подробнее об этом в отдельном конспекте, посвященном ошибкам в промисах. А понять, каким образом технически "ошибка перемещается по звеньям цепочки", можно из конспекта по механике промисов и про цепочки промисов.

# Метод finally

```
prom.finally(onFulfilledAndRejected);
```

У метода `finally` единственный параметр:

* `onFulfilledAndRejected` - функция-подписчик, которого надо выполнить после завершения промиса в любом случае, хоть он успешный, хоть отклоненный.

Например:

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно finally нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый из методов then, catch, finally тоже возвращает промис (подробнее об этом в будущих конспектах), то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => return 10)  // <-- Пытаемся перекрыть результат исходного промиса
  .then(result => {
    console.log(result);  // 5, т.е. finally не "проглотил" результат исходного промиса
  });
```

Подробнее о технической стороне этих методов - другом конспекте.
