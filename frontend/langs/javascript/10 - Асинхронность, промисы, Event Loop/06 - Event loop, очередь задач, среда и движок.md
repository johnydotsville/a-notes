# Движок и среда

*Движок* Javascript - это программа, которая понимает код, написанный на Javascript и выполняет его. В задачу движка входит JIT-компиляция.

> JIT-компиляция (just-in-time, "вовремя") это вид компиляции, когда она производится не заранее, перед запуском программы, а непосредсвенно во время ее работы. Подлежащий выполнению фрагмент исходного кода компилируется единожды и впоследствии, если снова нужен, то повторно компилировать его не приходится. JIT-компиляция позволяет добиться лучшей оптимизации программы, поскольку комплилятору уже известно, в каком именно окружении программа выполняется.

Известные движки:

* V8 - используется в браузере Chrome и среде Node JS.
* SpiderMonkey - используется в браузере Firefox.

Примеры *среды* выполнения:

* Браузер.
* Node JS.

В обязанности среды входит:

* Предоставление API. Например, для браузера это работа с DOM, а для Node JS - работа с файлами. Ввод\вывод и прочая функциональность - тоже предоставлена средой, а не движком.
* Реализация дополнительных вещей, предназначенных для организации выполнения js-кода, например Event Loop.

# Event Loop

## Важное предисловие

Event Loop реализуется средой выполнения (браузер, node js) и не является частью движка или языка. Про EL в браузере можно почитать спецификацию [здесь](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop).

С Event Loop связано очень много мифов и заблуждений. Т.к. его реализация зависит от среды выполнения, а среды могут быть разные, то сделать какое-то универсальное описание, правильное для всех случаев, проблематично.

При желании глубокие технические раскопки можно начать вот с этого [комментария](https://habr.com/ru/articles/762618/#comment_26066934).

## Концепция событийного цикла

Концептуально Event Loop представляет собой бесконечный цикл, основной зачаей которого является проверка, а не появились ли какие-нибудь задачи, которые надо выполнить. Если появились - начать их выполнять. Не появились - ждать и проверять дальше.

Примером такой задачи может быть:

* Генерация события перемещения мыши \ нажатия кнопки и выполнение их обработчиков.
* Выполнение обработчиков промисов.
* Выполнение обработчиков из setTimeout.
* Мб еще что-то.

В общем, задачи могут быть разные и их может быть много, а еще они могут быть связаны и поэтому существует правило последовательности их обработки.

## Правила обработки. Микро- и макрозадачи

Задачи делятся на микро- и макрозадачи. Вообще, таких терминов вроде бы нет в спеке, есть просто задачи, которые собираются в так называемые [task queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue) и [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) (еще называется PromiseJobs). Соответственно, условно задачи из первой очереди можно для наглядности назвать *макрозадачами*, а задачи из второй очереди - *микрозадачами*.

Написанное далее применимо к браузеру (могут быть технические неточности по сравнению со спекой, но судя по примерам с сайта Кантора, с практической точки зрения выглядит правдопободно):

* Микрозадачи - это:
  * Колбэки, переданные в методы промисов (then, catch, finally).
  * Intersection Observer.
  * Колбэки, переданные в функцию queueMicrotask.
* Макрозадачи - это, по сути, все остальное:
  * Сам главный скрипт, выполняющийся синхронно.
  * Колбэки, переданные в setTimeout.
  * mousemove, mouseover, click и прочие события.
  * Подключенный внешний скрипт.
  * И т.д.

Браузер обрабатывает эти задачи по следующему принципу:

1. Выполнить одну макрозадачу.
2. Выполнять микрозадачи до тех пор, пока они есть и появляются.
3. Выполнить рендеринг страницы.
4. Начать заново с пункта 1.

Сами задачи выполняются по принципу FIFO, т.е. кто первым пришел, первым и выполнится. Микрозадачи выполняются до тех пор, пока они есть. Это гарантирует то, что "окружение" (например, значения переменных, координаты мыши и т.д.) будет для всех микрозадач одинаковое.

Рендеринг происходит только когда задачи выполнены. Т.е. пока идет работа над задачами, визуально страница не изменяется.

## Примеры

Для тренировки понимания очередности выполнения микро- и макрозадач:

### Пример 1

```javascript
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');
```

Сначала выполняется сам главный скрипт. Тело промиса выполняется синхронно, поэтому надпись из него видна сразу. Потом последний вывод в консоль из главного скрипта. Т.к. сам скрипт считается макрозадачей, поэтому дальше должны выполниться все микрозадачи. В данном случае это единственный колбэк для промиса, переданный в then. Ну и потом, поскольку микрозадач больше нет, то берется следующая макрозадача, т.е. колбэк из setTimeout. Ответ:

```
Создание промиса
Конец скрипта
Обработка промиса
Таймаут
```

### Пример 2

```javascript
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve().then(() => console.log(5));
setTimeout(() => console.log(6));
console.log(7);
```

Сначала выполняется основной скрипт, поэтому 1 и 7. Затем идут микрозадачи, поэтому 3 и 5. В микрозадаче из второго промиса ничего не выводится, вместо этого в очередь добавляется новая макрозадача. Микрозадачи завершены, поэтому настал черед выполнять макрозадачи. Поэтому 2 и 6. Ну в конце 4. Ответ:

```
1  ,  7  ,  3  ,  5  ,  2  ,  6  ,  4
```





