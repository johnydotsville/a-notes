# Идея цепочки

Мы можем формировать цепочки из методов then, catch и finally за счет того, что каждый из них возвращает промис. Тогда результат колбэка из предыдущего метода будет передаваться в колбэк из следующего метода. 

Пример цепочки промисов:

```javascript
prom
  .then(F1)
  .then(F2)
  .then(F3)
  .catch(F4)
  .finally(F5);
```

А это - не цепочка, потому что каждый метод вызывается на исходном промисе:

```javascript
prom.then(F1);
prom.then(F2);
prom.then(F3);
prom.catch(F4);
prom.finally(F5);
```

# Пример цепочки

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => { 
    console.log(result);  // 5
    return 10;
  })
  .then(result => { 
    console.log(result);  // 10
    return 20;
  })
  .then(result => { 
    console.log(result);  // 20
    throw new Error("Ошибка в then.")
  })
  .catch(error => {
    console.log(error.message);  // Ошибка в then.
    return 40;
  })
  .then(result => { 
    console.log(result);  // 40
    // return undefined;  // Нет return - это return undefined
  })
  .finally(() => console.log("finally прокидывает предыдущий результат дальше."))
  .then(result => { 
    console.log(result);  // undefined
  })
```

Вывод:

```
5
10
20
Ошибка в then.
40
finally прокидывает предыдущий результат дальше.
undefined
```

# Пример не-цепочки

```javascript
const prom = new Promise((resolve, reject) => {
  resolve(5);
});

prom
  .then(result => { 
    console.log(result);  // 5
    return 10;
  });

prom
  .then(result => { 
    console.log(result);  // 5
    return 20;
  })

prom
  .then(result => { 
    console.log(result);  // 5
    throw new Error("Ошибка в then.");
  })
 
prom
  .catch(error => {  // Не отработает вообще, потому что в исходном промисе нет ошибок.
    console.log(error.message);
    return 40;
  })

prom
  .then(result => { 
    console.log(result);  // 5
  })

prom
  .finally(() => console.log("finally прокидывает предыдущий результат дальше."));
```

Вывод:

```
5
5
5
5
finally прокидывает предыдущий результат дальше.
Uncaught (in promise) Error: Ошибка в then.
```

P.S. Почему выводится "Uncaught (in promise) Error: Ошибка в then." см. конспект по ошибкам в промисе.

Поскольку методы в этом примере вызываются не друг на друге, а не на исходном промисе, то и цепочки никакой нет. Все подписчики оказываются в списке подписчиков исходного промиса и выполняются в одной микрозадаче по очереди добавления.

Чтобы получилась цепочка, можно переписать вот так:

```javascript

let prom = new Promise((resolve, reject) => {
  resolve(5);
});

prom = prom
  .then(result => { 
    console.log(result);  // 5
    return 10;
  });

prom = prom
  .then(result => { 
    console.log(result);  // 10
    return 20;
  })

prom = prom
  .then(result => { 
    console.log(result);  // 20
    throw new Error("Ошибка в then.");
  })
 
prom = prom
  .catch(error => {
    console.log(error.message);
    return 40;
  })

prom = prom
  .then(result => { 
    console.log(result);  // 40
  })

prom = prom
  .finally(() => console.log("finally прокидывает предыдущий результат дальше."));
```

```
5
10
20
Ошибка в then.
40
finally прокидывает предыдущий результат дальше.
```

# Промисы не ждут

Как показано в конспекте по механикам промисов, каждый метод возвращает новый Y-промис, у которого в экзекуторе выполняется помещение подписчика и Y-resolve\reject в X-handlers.

> X и Y - это фишка из конспекта по механике, которую я придумал чтобы быстро отличать промисы. Y-промис это следующий промис, который получается при вызове then \ catch \ finalyy на предыдущем, X-промисе.

Иногда пишут, что каждый следующий промис ждет завершения предыдущего. Мне эта формулировка не нравится, потому что ожидание в моем понимании означает какой-то активный процесс. На самом же деле выполнение идет строго по цепочке просто из-за способа организации подписчиков. Просто Y-resolve\reject выполняется в микрозадаче, поставленной X-планировщиком при завершении X-промиса. Соответственно, срабатывание Y-resolve\reject приводит к тому, что Y-планировщик ставит микрозадачу, в которой срабатывает Z-resolve\reject и так далее. Т.е. здесь дело не в ожидании, а в том, что завершение одного промиса как в эффекте домино приводит к завершению следующего. Получается, что никакого ожидания нет, просто промисы висят в памяти до тех пор, пока не завершится исходный, а потом завершаются друг за другом по эффекту домино.

P.S. В памяти промисы удерживаются за счет того, что resolve \ reject оформлены в виде лямбд и замыкают this. Так что, сохрнаняя resolve \ reject, мы предотвращаем удаление промисов из памяти.

# Результаты подписчиков

Колбэки, которые мы передаем в then \ catch \ finally, могут возвращать разный результат. Например, объект, промис или не возвращать ничего, а еще в них может произойти непойманная ошибка. Поскольку любой такой результат должен быть передан в колбэк из следующего метода, будет не лишним рассмотреть возможные случаи.

Вспомним как выглядит модель выполнения подписчика и завершение Y-промиса:

```javascript
_scheduleHandlers() {
  queueMicrotask(() => {
    while (this.handlers.length) {
      const { onFulfilled, onRejected, resolve, reject } = this.handlers.shift();
      try {
        if (this.state === 'fulfilled') {
          const result = onFulfilled ? onFulfilled(this.value) : this.value;
          this._handleResult(result, resolve, reject);
        } else if (this.state === 'rejected') {
          if (onRejected) {
            const result = onRejected(this.value);
            this._handleResult(result, resolve, reject);
          } else {
            reject(this.value);
          }
        }
      } catch (error) {
        reject(error);
      }
    }
  });
}

_handleResult(result, resolve, reject) {
  if (result instanceof MyPromise) {
    result.then(resolve, reject);
  } else {
    resolve(result);
  }
}
```

Теперь упростим код для каждого случая для более наглядного понимания.

## В колбэке произошла ошибка

```javascript
try {
  ...
  this._handleResult(result, resolve, reject);
  ...
} catch (error) {
  reject(error);
}
```

Колбэк выполняется внутри блока try-catch, так что если в нем происходит ошибка, то Y-промис просто отклоняется с этой ошибкой.

Пример:

```javascript
new Promise((resolve, reject) => { resolve(1337) })
  .then(result => {
    throw new Error("Ошибка в колбэке then-1.");
  })
  .catch(error => {
    console.log("Поймал ошибку: " + error.message);
  });
```

```
Поймал ошибку: Ошибка в колбэке then-1.
```

Необработанная ошибка в then привела к тому, что Y-промис оклонился с этой ошибкой. Мы можем сказать, что промис отклоненный, потому что сработал колбэк из catch. А то, что результатом этого промиса стала именно та ошибка, которая произошла в колбэке, понятно по ее сообщению.

## Результат - обычное значение

```javascript
this._handleResult(result, resolve, reject);
...
resolve(result);
```

В случае, когда ошибка не происходит, а результатом является какое-то значение, например, строка, объект или результата нет (что аналогично return undefined), тогда Y-промис просто резолвится с этим значением.

Пример:

```javascript
new Promise((resolve, reject) => { resolve(1337) })
  .then(result => {
    return { name: "Tom Sawyer", state: "Missouri" };
  })
  .then(result => {
    console.log(result.name + " from " + result.state);
  });
```

```
Tom Sawyer from Missouri
```

## Результат - промис

```javascript
this._handleResult(result, resolve, reject);
...
if (result instanceof MyPromise) {
  result.then(resolve, reject);
}
```

Когда результатом колбэка является промис, то Y-resolve\reject просто становятся подписчиками этого промиса. Т.е. вместо того чтобы завершить этот Y-промис прямо сейчас (как в случае с обычным результатом), его завершение привызывается к завершению "промиса-результата".

Пример:

```javascript
new Promise((resolve, reject) => { resolve(1337) })
  .then(result => {  // <-- Создается Y-промис
    console.log("Результатом этого then является промис, который завершится через 3 секунды.");
    return new Promise((resolve, reject) => {  // <-- Y-промис завершится после завершения этого промиса
      setTimeout(() => { resolve(1337) }, 3000);
    });
  })
  .then(result => {
    console.log("Это сообщение вы должны были увидеть через 3 секунды после предыдущего.");
    console.log("А результат - это результат 'промиса-результата': " + result);
  });
```

```
Результатом этого then является промис, который завершится через 3 секунды.
Это сообщение вы должны были увидеть через 3 секунды после предыдущего.
А результат - это результат 'промиса-результата': 1337
```

Чтобы не прокручивать каждый раз эти механизмы в голове, можно просто сделать краткий вывод: если колбэк возвращает промис, то он выполнится вперед Y-промиса, и его результат станет результатом Y-промиса.

## Колбэк не выполнился

Колбэк не выполняется, если статус промиса ему не подходит. В этом случае новый промис просто получает такой же статус и результат, как и предыдущий. Т.е. можно сказать, что концептуально старый промис просто прокидывается по цепочке вперед, хотя технически это уже другой промис.

Например:

```javascript
new Promise((resolve, reject) => { resolve(1337) })
  .then(result => {
    console.log("then-1");
    throw new Error("Ошибка в первом then.");
  })
  .then(result => console.log("then-2"));
  .catch(error => console.log("catch: " + error.message));
```

```
then-1
catch: Ошибка в первом then.
```

Колбэк из then-2 не сработал, потому что then-1-промис отклоненный. Вместо этого then-2-промис тоже стал отклоненным и в качестве результата у него такой же результат, как у then-1-промиса, т.е. ошибка, произошедшая в колбэке.

# Бонусные случаи

Просто чтобы позадротствовать и для размышления и проверки понимания как работают промисы.

## Промис просто создается в колбэке

Ситуация, когда внутри колбэка создается промис, возможно с собственными цепочками, но он не является результатом. Т.е. они выступают просто в роли обычных операторов среди прочих в теле колбэка.

```javascript
new Promise((resolve, reject) => { 
  resolve(1337);
})
  .then(result => {  // then-1
    console.log("then-1");
    new Promise((resolve, reject) => {  // <-- IN-промис
      console.log("Экзекутор вложенного промиса.");
      resolve();
    })
      .then(result => console.log("then-a"))   // then-a
      .then(result => console.log("then-b"));  // then-b
    return 1337;
  })
  .then(result => {  // then-2
    console.log("then-2")
  });
```

В таких случаях полезно понимать, какой промис попадает на вход методу - пендинг-промис или завершенный, и представлять себе очередь микрозадач.

На текущем примере: исходный промис завершенный, значит then-1 сразу планирует микрозадачу T1. Т.о. сейчас в очереди одна микрозадача - T1. Поскольку микрозадача выполнится только потом, то then-1-промис является пендинг-промисом. Поэтому then-2 не планирует микрозадачу, а просто добавляет подписчика к then-1-промису.

Начинает работать микрозадача T1, т.е. выполняться then-1-колбэк. В нем создается промис, который завершается синхронно. Так что then-a вызывается на завершенном промисе, поэтому планирует микрозадачу T2. Она, опять же, выполнится только потом, поэтому then-b вызывается на пендинг-промисе и не планирует еще одну микрозадачу. В очереди сейчас одна микрозадача T2 (ну и T1 сейчас выполняется, так что она как бы уже не в очереди можно сказать).

Микрозадача T1 завершается, т.е. then-1-колбэк отработал, и then-1-промис завершился. Это тригерит планирование его подписчиков, т.е. then-2-колбэк ставится в очередь микрозадач, это T3 микрозадача и теперь в очереди уже T2, T3, именно в таком порядке.

Выполняется микрозадача T2, что тригерит планирование then-b-колбэка, он попадает в очередь как микрозадача T4. Очередь выглядит как T3, T4. Ну и потом соответственно они выполняются и больше подписчиков нет, программа завершенеа.

Т.о., правильный ответ:

```
then-1
Экзекутор вложенного промиса.
then-a
then-2
then-b
```

## Отложенное завершение

Тот же пример, только IN-промис завершается асинхронно:

```javascript
new Promise((resolve, reject) => { 
  resolve(1337);
})
  .then(result => {  // then-1
    console.log("then-1");
    new Promise((resolve, reject) => {  // <-- IN-промис
      console.log("Экзекутор вложенного промиса.");
      setTimeout(() => resolve(), 0);
    })
      .then(result => console.log("then-a"))   // then-a
      .then(result => console.log("then-b"));  // then-b
    return 1337;
  })
  .then(result => {  // then-2
    console.log("then-2")
  });
```

Правильный ответ:

```
then-1
Экзекутор вложенного промиса.
then-2
then-a
then-b
```

# Резюме

Итого, ключ к пониманию всех этих последовательностей - это понимание двух вещей:

* На каком промисе вызывается метод then \ catch \ finally - на завершенном или на пендинге.
  * Если на завершенном, то сразу идет планирование микрозадачи с колбэком.
* Как выглядит очередь микрозадач в каждый момент.

Когда промис завершается, планируются его подписчик (если он есть). Поскольку добавление подписчика происходит тоже в промисе, то этот промис завершается, когда выполнился подписчик и результат подписчика становится результатом промиса. Если результатом подписчика является промис, то "out-промис" завершается только когда завершится этот промис.

