# Непойманное исключение в экзекуторе

Если в экзекуторе возникает непойманное исключение, это то же самое, что вызвать reject и передать в него это исключение. Это происходит, потому что промис оборачивает вызов экзекутора в  try-catch и при возникновении исключения вызвает reject, передавая ему объект ошибки:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  console.log("Вызовем ошибку в экзекуторе и не будем ее обрабатывать.");
  throw new Error("Эту ошибку промис поймал сам и отклонился.");
})  
  .catch(error => {
    console.log("Работает catch.");
    console.log(error);
  });
```

# Непойманное исключение в подписчике

P.S. Вопрос затрагивает более глубокое понимание промисов, для осознания возможно придется перечитать конспекты про механику промисов и цепочки промисов.

Когда в подписчике возникает непойманное исключение, это приводит к тому, что Y-промис отклоняется с этой ошибкой:

```javascript
new Promise((resolve, reject) => {
  resolve();
})
  .then(result => {
    throw new Error("Необработанная ошибка в подписчике.");  // <-- Ошибка в подписчике.
  })
  .catch(error => {
    console.log("Работает catch.");
    console.log(error.message);
  });

//  Работает catch.
//  Необработанная ошибка в подписчике.
```

Y-промис из then отклоняется с ошибкой, возникшей в подписчике. Эта ошибка попадет в подписчика, которого Z-промис из catch добавит Y-промису.

# Асинхронные ошибки в промисе

Важный момент касательно ошибок в промисах. Если написать вот так:

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => { 
    throw new Error("Асинхронная ошибка.");  // <-- throw в setTimeout
  }, 0);
  reject("Колбэк из catch выполнился до возникновения асинхронной ошибки.");
})
  .catch(error => console.log(error));
```

то в catch она не попадет. Хотя не поймать ошибку в экзекуторе - это все равно, что отклонить промис с этой ошибкой, но есть нюанс - ошибки "ловятся автоматически" только если происходят непосредственно в коде экзекутора.

Здесь же в коде экзекутора выполняется setTimeout, т.е. лишь операция планирования макрозадачи и никаких ошибок нет. Ошибка происходит внутри этой макрозадачи, которая к нашему промису никакого отношения не имеет, кроме того что он просто ее создал.

Чтобы лучше понимать техническую часть, почему это так работает, надо прочитать конспект про Event Loop, про микро- и макрозадачи. Применительно к этому примеру суть такова: в теле промиса создается макрозадача. Когда скрипт (который сам по себе тоже является макрозадачей) отрабатывает, то начинают обрабатывается *микро*-задачи, в данном случае это колбэк из метода catch. И только когда все микро-задачи обработаются, начинает выполняться следующая макрозадача, т.е. функция, которую мы закинули в setTimeout.

Получаем следующие факты:

* Ошибка возникает не в самом промисе, а в задаче, которая выполнится в будущем. В промисе же эта задача просто запланирована.
* Колбэк из catch технически выполнится до того, как начнет работу запланированная через setTimeout задача, т.е. фактически до возникновения ошибки. Так что в любом случае невозможно было бы в нем обработать эту ошибку, потому что она еще не возникла.

# Отклонение без обработки

## Отклоненный промис без catch

Если промис отклоняется, но нет обработчика отклонения (не приделали его через then или catch), тогда движок запомнит такой промис и выдаст сообщение в консоль. Например:

```javascript
new Promise((resolve, reject) => {
  reject(new Error("Движок отслеживает отклоненные промисы, которые не были обработаны."));
});

// Uncaught (in promise) Error: Движок отслеживает отклоненные промисы, которые не были обработаны.
```

Это помогает избежать "тихих ошибок", которые возникают, но никак не визуализируются. В данный момент необработанные отклоненные промисы не кладут программу, но это поведение может измениться в будущем. Поэтому к отклонению промиса надо относиться как к обычной потенциальной ошибке в синхронном коде и добавлять обработку для избежания проблем:

```javascript
new Promise((resolve, reject) => {
  reject(new Error("Движок отслеживает отклоненные промисы, которые не были обработаны."));
})
  .catch(error => console.log("Обработали отклоненный промис, движок не беспокойся."));
```

## Момент поиска необработанных отклонений

Когда движок проверяет, есть ли отклоненные промисы без обработчиков отклонения? Он делает это после выполнения всех микрозадач, но до рендера.

## Глобальная обработка необработанных промисов

Когда движок находит необработанный промис, он генерирует событие `unhandledrejection` и таким образом мы можем обрабатывать пропущенные ошибки:

```javascript
window.addEventListener("unhandledrejection", (e) => {
  console.error("Поймал необработанный промис:", e.reason);
});

new Promise((resolve, reject) => {
  reject(new Error("Ошибка в промисе."));
});
```

Особенности:

* Важно добавлять обработчик до того, как промис отклонится.
* Событие срабатывает на каждый отклоненный без обработки промис. Т.е. если таких промисов 5, то и событие сработает 5 раз.

P.S. Этот код у меня почему-то не работал, хотя должен. Не стал возиться, оставлю до момента, когда ситуация реально будет требовать разобраться.

## Отложенная обработка

Когда мы обрабатываем промис, который изначально был отклонен без обработки, через событие unhandledrejection, то возникает другое событие - `rejectionhandled`:

```javascript
window.addEventListener("rejectionhandled", (event) => {
  console.log("Ошибка теперь обработана:", event.reason);
});
```

Такое может случиться, когда catch на промис добавляется не сразу, а потом, например:

```javascript
window.addEventListener("rejectionhandled", (event) => {
  console.log("Ошибка теперь обработана:", event.reason);
});

const p = Promise.reject(new Error("Позже обработаем."));

setTimeout(() => {
  p.catch(() => { console.log("Обработали отклоненный промис.") }); // <-- Обрабатываем позже.
}, 1000);
```

