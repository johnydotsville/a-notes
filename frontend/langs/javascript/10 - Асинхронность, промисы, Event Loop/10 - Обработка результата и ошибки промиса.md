# Цепочки методов then, catch, finally

Эти методы можно объединять в цепочки, потому что каждый из них тоже возвращает промис. Более детально об этом в следующем конспекте про механики методов then, catch, finally.

# Метод then, результат + ошибка

Получить доступ к результату или ошибке промиса можно с помощью метода `then`, который принимает две функции:

```javascript
prom.then(
  result => console.log(result),        // Выполнится, если промис fulfilled
  error => console.log(result.message)  // Выполнится, если промис rejected
);
```

 ```javascript
prom.then(  // Если не планируем обрабатывать ошибки, второй колбэк можно не передавать.
  result => console.log(result)
);
 ```

Если промис завершился успешно, то выполнится первый колбэк и через свой параметр он получит результат промиса. Если промис отклонился, то выполнится второй колбэк и через свой параметр он получит ошибку, приведшую к отклонению.

> Технически, ошибка это тоже просто результат промиса. А с помощью двух колбэков авторы API избавили нас от необходимости как-то вручную проверять статус промиса.

Передавая колбэки в then, мы ставим их в очередь микрозадач и выполняться они будут асинхронно, после того как выполнится основной скрипт.

В итоге можно сказать, что "получить результат промиса" непосредственно - невозможно. Грубо говоря, мы не можем извлечь этот результат из объекта промиса. Единственный способ добраться до результата - это передать колбэк в метод then и тогда промис отдаст нам свой результат через параметр этого колбэка. Это замечание будет полезно для лучшего понимания цепочки промисов дальше.

# Метод catch, только ошибка

Для обработки результата отклоненного промиса ("ошибки") есть отдельный метод `catch`. От then он отличается тем, что у него только один колбэк и соответственно выполнится этот колбэк только если промис будет отклонен:

```javascript
prom.catch(
  error => console.log(result.message)
);
````

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
prom
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То можно принять ошибку не только из prom, но и из then.

При возникновении ошибки она проскакивает все звенья цепочки до первого попавшегося catch (или then, у которого есть второй колбэк). Если там ее не обработать, она полетит до следующего catch и так до тех пор, пока цепочка не закончится и скрипт не ляжет.

# Метод finally

Метод `finally` принимает функцию без аргументов:

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно он нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис - успешно или нет. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый метод возвращает промис (подробнее об этом в будущих конспектах), то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => {
    console.log("Выполняем общие действия.");
    return 10;  // <-- Пытаемся перекрыть результат исходного промиса
  })
  .then(result => {
    console.log(result);  // 5, т.е. finally не "проглотил" результат исходного промиса
  });
```

Подробнее о технической стороне этих методов - другом конспекте.

