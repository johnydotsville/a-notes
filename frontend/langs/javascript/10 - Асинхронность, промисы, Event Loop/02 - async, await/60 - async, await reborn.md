

---

`sync/await` работает только с Promise. Если вы `await` не-Promise, значение будет обернуто в Promise автоматически.

`async` функции всегда возвращают Promise, даже если вы возвращаете простое значение.







# Варианты асинхронности в Javascript

В js есть разные способы работы с асинхронным кодом:

* С помощью колбэков. Например, setTimeout. Мы передаем колбэк и он потом выполняется.
* События. Например, в случае с indexeddb мы запрашиваем открытие БД, получаем объект запроса, а у него есть события. Мы подписываем функции на события и движок их вызывает, когда событие происходит.
* Промисы. Передаем в промис экзекутор, а потом через then формируем подписчиков.
* Еще какие-нибудь.

Из всех этих способов async \ await работают в паре именно с промисами.

# async

```javascript
async function foo() {
  return "Hello, async!";
}
```

```javascript
const bar = async () => {
  return "Привет, async!";
}
```

`async` - это ключевое слово, применяется к функции при ее объявлении. async позволяет использовать внутри функции слово await.

Если функция, объявленная с async, возвращает какой-то результат, то этот результат оборачивается в успешно завершенный промис. Если внутри функции возникает исключение, то оно оборачивается в отклоненный промис. Eсли функция ничего не возвращает и в ней не произошло исключение, то можно считать, что возвращается промис с resolve() без значения.

Т.е. в любом случае результатом async-функции является промис.

Не надо только воспринимать тело async-функции как экзекутор этого промиса. Там более сложные механизмы.

# await

`await` используется для извлечения результата из промиса. Применяется как непосредственно к промисам, так и к функциям, возвращающим промис.

Если применить await к промису, то вернется значение, с которым промис был зарезолвлен. Если же промис отклонен, то await выбросит исключение с отклоненным значением.

# Механизм async \ await

`async` и `await` это ключевые слова, которые упрощают работу с промисами, позволяя организовать асинхронный код в линейном виде, похожим на синхронный. Благодаря этому можно, например, ставить точки останова так же, как в синхронном коде или использовать асинхронность в условиях, циклах.

Внутреннее устройство async \ await я не хочу трогать, оно мутное. Там каким-то образом намешаны промисы, генераторы и прочая чушь.

Внешне все работает так:

* Код async-функции выполняется синхронно до первого await.
* Весь код после await концептуально можно воспринимать как колбэк для then. Т.е. если у нас `await P`, то когда промис P завершится, то код после await запланируется в микрозадачу MT1.
  * Соответственно, если в этом коде тоже есть await, то когда начнет работать MT1 и мы снова дойдем до await, то ситуация повторится: после завершения очередного промиса код после await поставится в микрозадачу. И так будет работать вся цепочка await'ов: промис завершается - образуется микрозадача, в которой выполнение идет дальше.

TODO: Спросить у дипси про генераторы, мб если получше понять как генераторы работают технически, то будет проще понять эту концепцию остановки \ возобновления? UPD. Вряд ли.

# Пример

Возьмем обычный промис:

```javascript
function doSome() {  // <-- Сымитируем функцию, которая делает что-то асинхронно, типа fetch    
  return new Promise((resolve, reject) => {
    console.log("Промис начал работу");
    const value = Math.random() * 10;
    const success = value >= 5;
    if (success)
      resolve(value);
    else
      reject(new Error("doSome не смогла выполниться"));
  });
}
```

## Промис без async \ await

Извлечем из него результат без использования await:

```javascript
doSome()  // <-- Чтобы получить результат, нам придется использовать then
  .then(result => {
    console.log("Результат получен");
    console.log(result);
  })
  .catch(err => console.log(err.message));

console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

В данном случае мы должны писать код, которому нужен результат, внутри then, что все же затрудняет восприятие и менее симпатично, чем линейный код без колбэков.

## Промис с async \ await

Теперь обработаем результат, но будем использовать await:

```javascript
async function foobar() {
  try {
    const result = await doSome();  // <-- Получаем результат промиса через await
    console.log("Результат получен");  // <-- Сюда попадаем только после завершения промиса
    console.log(result);
  } catch (err) {
    console.log(err.message);
  }
}

foobar();
console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

Больше then не требуется - await извлекает из промиса непосредственно сам результат и возвращает его. Если там ошибка и промис отклонен, то await дает эффект, будто эта ошибка выбросилась, поэтому ее можно поймать обычным try-catch. Если не поймать, то async-функция вернет rejected-промис.

Все, что идет со следующей строки после await, выполнится только после завершения промиса. При этом код остается асинхронным, т.е. грубо говоря, все что идет после await просто как бы становится колбэком для ожидаемого промиса, как будто мы все это поместили в then.

Из тонкостей: await можно использовать только внутри async-функций и нельзя использовать на уровне скрипта. Хотя в будущем планируют добавить такую возможность.