# Кто реализует Event Loop

Event Loop реализуется средой выполнения (браузер, node js) и не является частью движка или языка. Про EL в браузере можно почитать спецификацию [здесь](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop).

С Event Loop связано очень много мифов и заблуждений. Т.к. его реализация зависит от среды выполнения, а среды могут быть разные, то сделать какое-то универсальное описание, правильное для всех случаев, проблематично.

При желании глубокие технические раскопки можно начать вот с этого [комментария](https://habr.com/ru/articles/762618/#comment_26066934).

# Концепция событийного цикла

Концептуально Event Loop представляет собой бесконечный цикл, основной зачаей которого является проверка, а не появились ли какие-нибудь задачи, которые надо выполнить. Если появились - начать их выполнять. Не появились - ждать и проверять дальше.

Примером такой задачи может быть:

* Генерация события перемещения мыши \ нажатия кнопки и выполнение их обработчиков.
* Выполнение обработчиков промисов.
* Выполнение обработчиков из setTimeout.
* Мб еще что-то.

В общем, задачи могут быть разные и их может быть много, а еще они могут быть связаны и поэтому существует правило последовательности их обработки.

# Микро- и макрозадачи, правила обработки

Задачи делятся на микро- и макрозадачи. Вообще, таких терминов вроде бы нет в спеке, есть просто задачи, которые собираются в так называемые [task queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue) и [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) (еще называется PromiseJobs). Соответственно, условно задачи из первой очереди можно для наглядности назвать *макрозадачами*, а задачи из второй очереди - *микрозадачами*.

Написанное далее применимо к браузеру (могут быть технические неточности по сравнению со спекой, но судя по примерам с сайта Кантора, с практической точки зрения выглядит правдопободно):

* Микрозадачи - это:
  * Колбэки, переданные в методы промисов (then, catch, finally).
  * Intersection Observer.
  * Колбэки, переданные в функцию queueMicrotask.
* Макрозадачи - это, по сути, все остальное:
  * Сам главный скрипт, выполняющийся синхронно.
  * Колбэки, переданные в setTimeout.
  * mousemove, mouseover, click и прочие события.
  * Подключенный внешний скрипт.
  * И т.д.

Браузер обрабатывает эти задачи по следующему принципу:

1. Выполнить одну макрозадачу.
2. Выполнять микрозадачи до тех пор, пока они есть и появляются.
3. Выполнить рендеринг страницы.
4. Начать заново с пункта 1.

Сами задачи выполняются по принципу FIFO, т.е. кто первым пришел, первым и выполнится. Микрозадачи выполняются до тех пор, пока они есть. Это гарантирует то, что "окружение" (например, значения переменных, координаты мыши и т.д.) будет для всех микрозадач одинаковое.

Рендеринг происходит только когда задачи выполнены. Т.е. пока идет работа над задачами, визуально страница не изменяется.

# Примеры

Для тренировки понимания очередности выполнения микро- и макрозадач:

### Пример 1

```javascript
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');
```

Сначала выполняется сам главный скрипт. Тело промиса выполняется синхронно, поэтому надпись из него видна сразу. Потом последний вывод в консоль из главного скрипта. Т.к. сам скрипт считается макрозадачей, поэтому дальше должны выполниться все микрозадачи. В данном случае это единственный колбэк для промиса, переданный в then. Ну и потом, поскольку микрозадач больше нет, то берется следующая макрозадача, т.е. колбэк из setTimeout. Ответ:

```
Создание промиса
Конец скрипта
Обработка промиса
Таймаут
```

### Пример 2

```javascript
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve().then(() => console.log(5));
setTimeout(() => console.log(6));
console.log(7);
```

Сначала выполняется основной скрипт, поэтому 1 и 7. Затем идут микрозадачи, поэтому 3 и 5. В микрозадаче из второго промиса ничего не выводится, вместо этого в очередь добавляется новая макрозадача. Микрозадачи завершены, поэтому настал черед выполнять макрозадачи. Поэтому 2 и 6. Ну в конце 4. Ответ:

```
1  ,  7  ,  3  ,  5  ,  2  ,  6  ,  4
```

### Пример 3

```javascript
console.log("Script start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    queueMicrotask(() => console.log("queueMicrotask"));
  })
  .then(() => console.log("Promise 2"));

console.log("Script end");
```

```
Script start
Script end
Promise 1
Promise 2
queueMicrotask  - все микротаски выполняются до макротасок
setTimeout
```





