# Старт промиса

## Экзекутор

Когда мы создаем промис, то через конструктор передаем ему колбэк. Этот колбэк называется `executor` ("экзекутор"). Можно сказать, что это и есть работа, которую выполняет промис.

Промис запускает экзекутор непосредственно у себя в конструкторе, так что как-то явно запускать промис в работу не надо:

```javascript
new Promise((resolve, reject) => {  // <-- "Экзекутор"
  console.log("Этот колбэк выполнится непосредственно в конструкторе промиса.");
  resolve("Промис завершен успешно.");
});
```

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно.

# Завершение промиса

## Колбэки resolve и reject

Экзекутор имеет два параметра. Общепринятые названия для них - resolve и reject. Это функции. Промис создает их у себя в конструкторе и передает экзекутору, когда запускает его.

Мы должны вызвать resolve \ reject в экзекуторе, чтобы перевести промис в завершенное состояние:

* `resolve(value)` - успешное завершение. Промис получает статус `fulfilled`.
* `reject(value)` - неуспешное завершение. Промис получает статус `rejected`.

До тех пор, пока не вызван ни один из этих колбэков, промис считается незавершенным и находится в статусе `pending` (пендинг-промис).

Обычно в resolve передают результат работы экзекутора, например:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  resolve({ foobar: 1337 });  // <-- Промис завершается успешно.
});
```

А в reject передают ошибку, возникшую в процессе работы экзекутора, например:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  reject(new Error("Сервер не ответил вовремя."));  // <-- Промис завершается неуспешно.
});
```

Хотя технически что в resolve, что в reject можно передать любое значение. В любом случае оно будет считаться `результатом` работы промиса.

## Выход из экзекутора

Вызов resolve или reject не прерывает выполнение экзекутора. Если после них есть какой-то код, он выполнится: 

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  resolve({ foobar: 1337 });
  console.log("Вызов resolve \ reject не прерывает экзекутор.");
});

/*
Работает экзекутор.
Вызов resolve  reject не прерывает экзекутор.
*/
```

Поэтому, если вдруг каким-то образом код устроен так, что resolve или reject не являются заключительными операторами в экзекуторе, но при этом надо прервать его выполнение, то для этого можно вызвать return:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  resolve({ foobar: 1337 });
  return;
  console.log("Это сообщение вы не увидите.");
});
```

# Статус промиса

Итого, промис может находиться в одном из трех статусов:

* Незавершенный (пендинг-промис).
  * `pending` - "незавершенный". Этот статус промис получает сразу при создании.
* Завершенный.
  * `fulfilled` - "завершенный успешно". Этот статус промис получает при вызове колбэка resolve в экзекуторе.
  * `rejected` - "завершенный не успешно", "отклоненный". Этот статус промис получает при вызове колбэка reject в экзекуторе.

Статус хранится в системном поле промиса, которое называется `[[PromiseState]]`. Явно прочитать его нельзя, изменить вручную тоже, оно относится к внутренним механикам промиса и с ним непосредственно работают только собственные методы промиса.