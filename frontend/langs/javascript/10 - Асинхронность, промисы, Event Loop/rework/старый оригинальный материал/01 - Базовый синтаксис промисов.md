# Базовый синтаксис промисов

Промис - это объект, который позволяет нам синхронно выполнить какой-то код, а когда он завершится, асинхронно выполнить дополнительные действия. TODO: мне теперь не нравится эта формулировка, подумать как лучше описать суть промиса.

```javascript
let prom = new Promise((resolve, reject) => {
  let num = Math.random() * 10;
  if (num >= 7) {
    resolve(num);
  } else {
    if (num >= 4)
      reject(new Error("Полученное число недостаточно большое."));
    else
      throw new Error("Произошла непредвиденная ошибка.");
  }
});

prom.then(
  result => console.log("Результат задачи из промиса: " + result),
  error => console.log("Задача в промисе завершилась некорректно: " + error.message)
);
```

# Колбэки resolve и reject, статус промиса

> Я одновременно использую слова колбэк и функция намеренно, чтобы не было тавтологии и было проще воспринимать текст. Колбэк сам по себе - это просто функция, которую вызываем не мы, а код, которому мы этот колбэк передаем.

При создании промиса мы передаем ему через конструктор колбэк. Этот колбэк называется `executor` (экзекутор).

У экзекутора два параметра. Общепринятые названия для них - resolve и reject. Это функции. Когда движок будет выполнять наш экзекутор, то передаст ему эти функции. Соответственно, в экзекуторе мы должны вызвать их, чтобы отметить успешное, либо неуспешное завершение работы промиса.

На старте статус промиса `pending` ("выполняется") и если не вызвать resolve или reject, то промис останется в этом состоянии и будет считаться незавершенным. Если мы вызываем resolve или reject, тогда промис становится завершенным.

Вызов `resolve(результат)` концептуально означает успешное завершение экзекутора. Состояние промиса при этом становится `fulfilled`.

Вызов `reject(ошибка)` концептуально означает не успешное завершение экзекутора. Промис при этом переходит в состояние `rejected`.

В обоих случаях значение, которое мы передадим в resolve() или reject() будет считаться `результатом промиса`. В resolve обычно передают какое-то значение, а в reject - объект Error, хотя можно передать и просто код ошибки или сообщение, технически это не важно.

**Очень важно**: после вызова resolve и reject, помимо того что меняется состояние промиса и устанавливается его результат, кроме этого, колбэки которые мы передаем в методы then, catch и finally, попадают в очередь микрозадач. Об этих методах и микрозадачах будет в следующих конспектах, но важно этот факт упомянуть и здесь.

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно. Так же как и статус меняется только один раз. Получить статус тоже невозможно.

# Прерывание промиса

Вызов resolve или reject не прерывает код промиса. Если после них есть какой-то код, он выполнится. Поэтому, если вдруг в какой-то момент мы понимаем, что работа окончена и мы хотим, например, сделать resolve и прерваться, то прерываемся вручную, через явный вызов return.

# Непойманное исключение в промисе

Если возникает непойманное исключение, это то же самое, что вызвать reject и передать в него это исключение. Т.е. промис в этом случае как бы сам ловит это исключение и отклоняется с этой ошибкой.

# Синхронная работа - асинхронная обработка результата

Экзекутор начинает выполняться сразу при создании промиса, так что как-то явно запускать промис в работу не надо. Экзекутор выполняется синхронно, а обработка результата его работы происходит асинхронно. Подробнее о синхронности и асинхронности и как это организовано - в конспекте про Event Loop.

> Важное замечание: при рассмотрении примеров из ближайших разделов может возникнуть вопрос: "Если промис выполняется синхронно, то почему результат обрабатывается когда-то там потом, а не сразу?". Ответ такой: непосредственно в языке JS нет асинхронных операций, они есть только в платформе - браузере или Node. Поэтому я просто не мог написать синтетические примеры с асинхронностью. В реальных ситуациях (например из задачи в начале этого конспекта по подключению скрипта), в колбэке промиса обычно присутствуют операции, которые запускают некий реально асинхронный процесс, который завершится когда-то в будущем, а промис этого завершения не ждет и программа идет дальше.

Пока же просто визуально посмотрим на последовательность вывода в консоль:

```javascript
console.log("Начало скрипта");

new Promise((resolve, reject) => {
  console.log("В начале промиса");  // <-- Экзекутор выполняется СИНХРОННО
  for (let i = 0; i < 10; i++) {
    syncDelay();
  }
  console.log("В конце промиса");
  resolve(7);
})
  .then(result => {  // <-- Обработка результата экзекутора происходит АСИНХРОННО
    console.log("Результат промиса: " + result);
  });

console.log("В конце скрипта");

function syncDelay() {  // <-- Имитация долгой синхронной работы, просто очень большой цикл
  for (let i = 0; i < 999999999; i++);
}
/*
  Начало скрипта
  В начале промиса
  В конце промиса
  В конце скрипта
  Результат промиса: 7  // <-- Т.к. обработка результата асинхронная, мы видим это на последнем месте
*/
```

# Опциональность resolve и reject

Строго говоря, в экзекуторе не обязательно указывать параметры, т.е. промис можно написать и вот так:

```javascript
let prom = new Promise(() => {  // <-- Нет resolve и reject в параметрах
  throw new Error("Шеф, все пропало!");
});

prom.catch(err => console.log(err.message));  // Шеф, все пропало!
```

Просто в этом случае у нас не будет возможности завершить промис самостоятельно. Например, промис из примера выше автоматически завершится reject'ом, потому что внутри колбэка выброшена ошибка. Но самостоятельно мы бы не смогли его заreject'ить, т.к. передали промису колбэк без параметров.

Соответственно, можно передать колбэк всего с одним параметром, под resolve:

```javascript
let prom = new Promise((resolve) => {
  resolve("Привет, мир!");
});

prom.then(result => console.log(result));  // Привет, мир!
```

