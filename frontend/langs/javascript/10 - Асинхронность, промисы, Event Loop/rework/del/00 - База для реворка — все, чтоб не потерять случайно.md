# Базовый синтаксис промиса

```javascript
new Promise((resolve, reject) => {
  let num = Math.random() * 10;

  if (num >= 7) { resolve(num); }
  else if (num >= 4) { reject(new Error("Полученное число недостаточно большое.")); }
  else { throw new Error("Произошла непредвиденная ошибка."); }
})
  .then(result => console.log(result))
  .catch(error => console.log(error))
  .finally(() => console.log("finally работает."));
```





# Экзекутор, колбэки resolve и reject

Колбэк, который мы передаем в конструктор промиса, называется называется `executor` (экзекутор).

У экзекутора два параметра. Общепринятые названия для них - resolve и reject. Это функции. Они предназначены для 

Когда экзекутор начинает работать, 

Когда движок будет выполнять наш экзекутор, то передаст ему эти функции. Соответственно, в экзекуторе мы должны вызвать их, чтобы отметить успешное, либо неуспешное завершение работы промиса.







# Старт промиса

Когда мы создаем промис, то через конструктор передаем ему колбэк. Этот колбэк называется `executor` ("экзекутор"):

```javascript
new Promise((resolve, reject) => {  // <-- "Экзекутор"
  console.log("Работает экзекутор.");
  resolve("Промис завершается синхронно.");
})
  .then(() => console.log("Работает then."))
```

Экзекутор начинает выполняться синхронно, сразу при создании промиса, так что как-то явно запускать промис в работу не надо.

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно.



# Завершение промиса

Промис можно перевести в завершенное состояние, вызвав один из двух методов:

* `resolve(value)` - успешное завершение промиса. Он получает статус `fulfilled`.
* `reject(value)` - неуспешное завершение промиса. Он получает статус `rejected`.

До тех пор, пока не вызван ни один из этих методов, промис считается незавершенным и находится в статусе `pending`.

> Далее в конспектах я буду писать "резолвить" и "реджектить" вместо "когда промис завершается успешно" и "когда промис отклоняется" и прочих ситуациях, потому что так быстрее и нагляднее.

Статус хранится в системном поле промиса, которое называется `[[PromiseState]]`. Явно прочитать его нельзя, изменить вручную тоже, оно относится к внутренним механикам промиса и с ним непосредственно работают только собственные методы промиса.

Обычно в resolve передают результат промиса, например `resolve(1337)`, а в reject передают ошибку, например `reject(new Error("Сервер не ответил вовремя."))`. Хотя технически это не обязательно и можно в reject передать любое значение.

# Прерывание промиса

Вызов resolve или reject не прерывает код промиса. Если после них есть какой-то код, он выполнится. Поэтому, если вдруг в какой-то момент мы понимаем, что работа окончена и мы хотим, например, сделать resolve и прерваться, то прерываемся вручную, через явный вызов return.



# Итого

Промис может находиться в одном из трех статусов:

* Незавершенный.
  * `pending` - "незавершенный". Этот статус промис получает сразу при создании.
* Завершенный.
  * `fulfilled` - "завершенный успешно". Этот статус промис получается после вызова колбэка resolve в экзекуторе.
  * `rejected` - "завершенный не успешно", "отклоненный". Этот статус промис получается после вызова колбэка reject в экзекуторе.





# Результат промиса

Результат промиса - это значение, которое мы передаем в методы resolve или reject. Переданное через них значение хранится в системном поле промиса, которое называется `[[PromiseResult]]`. Получить доступ напрямую к нему нельзя.

Чтобы получить этот результат, мы должны зарегистрировать колбэк через методы then или catch и тогда, когда эти колбэки будут вызваны, они получат через свой параметр результат промиса:

TODO: написать примеры получения результата.



# Микрозадачи и resolve, reject, then, catch, finally

У промиса помимо прочих есть два системных поля:

* `[[PromiseFulfillReactions]]` - список колбэков, которые нужно выполнить при резолве ("резолв-список").
* `[[PromiseRejectReactions]]` - список колбэков, которые нужно выполнить при реджекте ("реджект-список").

Когда мы вызываем методы resolve или reject, то они проверяют соответствующие списки. Если в списках есть колбэки, то они ставятся в очередь микрозадач.

Если списки пустые, значит промис завершился синхронно. Если не пустые - значит промис завершился асинхронно.

Это объясняется тем, что resolve \ reject работают как бы в паре c then \ catch \ finally. Разберем механику.

## Промис завершается синхронно

Ситуация 1: промис завершается синхронно, т.е. resolve или reject вызваны непосредственно в экзекуторе:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  resolve("Промис завершается синхронно.");  // <-- Синхронно
})
  .then(() => console.log("Работает then."))
```

Одно из поведений метода then - это положить переданный ему колбэк в резолв-список. Но как известно, экзекутор работает синхронно, так что пока он не выполнится, метод then не сработает. Соответственно, если resolve выполняется синхронно (как в данном пример), то список будет пуст, т.к. then еще не выполнился. Поскольку список пуст, то метод resolve не может ничего поставить в очередь микрозадач. Поэтому он просто переводят промис в завершенный статус.

Далее управление доходит до then. then видит, что промис находится в завершенном статусе. Поэтому then не помещает колбэк в резолв-список промиса, а сразу ставит этот колбэк в очередь микрозадач.

## Промис завершается асинхронно

Ситуация 2: промис завершается асинхронно, т.е. resolve или reject вызываются не в экзекуторе непосредственно, а в асинхронном коде. Например:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  setTimeout(() => resolve("Промис завершается а-синхронно."), 0);  // <-- Асинхронно
})
  .then(() => console.log("Работает then."))
```

В этом примере промис завершится в макрозадаче, запланированной через setTimeout. Соответственно, когда экзекутор отработает, сам промис будет еще в незаверешнном состоянии. Поэтому когда then начнет работу и увидит, что промис еще не завершился, он не сможет создать микрозадачу из колбэка, потому что колбэку надо передать результат работы промиса. А это невозможно сделать, т.к. промис еще не завершился.

Поэтому then в этой ситуации добавляет колбэк в резолв-список промиса. Соответственно, когда выполнится метод resolve, список будет не пустой и тогда сам resolve сформирует микрозадачу из колбэков, лежащих в этом списке, и передаст им результат работы промиса.

## Итого

В итоге можно сказать, что resolve работает в паре с then в том смысле, что каждый из них способен поставить колбэки в очередь микрозадач. А кто именно из них это сделает - зависит от ситуации. Если then выполняется на завершенном промисе, то микрозадачу формирует then. Если then выполняется на незавершенном промисе, то он добавляет колбэк в список, а микрозадачу формирует resolve.

Все то же самое относится и к остальным методам, т.е. к resolve \ reject + then \ catch \ finally. Только finally будет класть свой колбэк сразу в оба списка.











# Промис завершается синхронно

```javascript
console.log("Основной скрипт начал работу.");

const promise = new Promise((resolve, reject) => {
  console.log("Работает экзекутор промиса, выполняется синхронно.");
  resolve("Результат оригинального промиса.");
})
  .then(() => console.log("Работает then."))

console.log("Основной скрипт завершен.");
```

Вывод:

```
Основной скрипт начал работу.
Работает экзекутор промиса, выполняется синхронно.
Основной скрипт завершен.
Работает then.
```





# Промис завершается асинхронно

```javascript
console.log("Основной скрипт начал работу.");

const promise = new Promise((resolve, reject) => {
  console.log("Работает экзекутор промиса, выполняется синхронно.");
  setTimeout(() => resolve("Результат оригинального промиса."), 0);
})
  .then(() => console.log("Работает then."))

console.log("Основной скрипт завершен.");
```

Вывод:

```
Основной скрипт начал работу.
Работает экзекутор промиса, выполняется синхронно.
Основной скрипт завершен.
Работает then.
```







