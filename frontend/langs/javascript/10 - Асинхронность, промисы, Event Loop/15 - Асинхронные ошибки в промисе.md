# Асинхронные ошибки в промисе

Важный момент касательно ошибок в промисах. Если написать вот так:

```javascript
new Promise(() => {
  setTimeout(() => { 
    throw new Error("Ошибка в промисе!");  // <-- throw в setTimeout
  }, 1000);
})
  .then(result => console.log(result))
  .catch(err => console.log(err.message));
```

то в catch мы не попадем. Хотя не поймать ошибку в экзекуторе - это все равно, что отклонить промис с этой ошибкой, но есть нюанс - ошибки "ловятся автоматически" только если происходят синхронно, непосредственно в коде экзекутора. Здесь же в коде экзекутора выполняется setTimeout, т.е. лишь операция планирования макрозадачи и никаких ошибок нет. Ошибка происходит внутри этой макрозадачи, которая к нашему промису никакого отношения не имеет, т.к. выполняется уже после микрозадач, зарегистрированных через then и catch.

Вообще, чтобы понимать, почему это так работает, надо прочитать конспект про Event Loop, про микро- и макрозадачи. Применительно к этому примеру суть такова: в теле промиса создается макрозадача. Когда скрипт (который сам по себе тоже является макрозадачей) отрабатывает, то начинают обрабатывается *микро*-задачи, коими тут являются колбэки из методов then и catch. И только когда они обработаются, начинает выполняться следующая макрозадача, т.е. то, что мы закинули в setTimeout. Отсюда становится понятно, что на момент выполнения колбэка из catch ошибка еще не возникла, поэтому и не обрабатывается.

