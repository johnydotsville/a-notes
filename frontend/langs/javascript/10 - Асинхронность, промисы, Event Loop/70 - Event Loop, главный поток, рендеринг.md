# Event Loop, главный поток, рендеринг

## Поточность в браузере

Весь код JS, который мы пишем, выполняется в одном потоке, который называется `главным` потоком. У браузера есть пул потоков и он использует потоки из пула для разных целей. Например, один для выполнения JS-кода. Еще один - для отсчеча таймеров, заданных через setTimeout и setInterval. Плюс еще дополнительные потоки для fetch, рендеринга и т.д. Т.е. для решения каждой из этих задач браузер берет потоки из пула.

Т.е. потоков у браузера много под разные служебные нужды, но весь JS несмотря на это выполняется в одном потоке. Поэтому часто говорят, что "JS - однопоточный".

## Event Loop

Event Loop - это бесконечный цикл, который запускается после того, как движок выполнил весь начальный JS-код. Это выглядит примерно так: браузер загрузил скрипты, подключенные к странице, и сопутствующие скрипты внутри них (подключенные через статический import) и начинает выполнять их. В процессе их выполнения могут запускаться асинхронные операции, которые попадают в очередь задач и будут выполнены в будущем, после окончания выполнения всех этих начальных скриптов.

В итоге, когда код этих скриптов выполнился, запускается Event Loop и бесконечно крутится, проверяя очереди микро- и макротасок и выполняя их и рендер страницы по необходимости. На псевдокоде это выглядит примерно так:

```javascript
// 1. Выполнить ВЕСЬ начальный синхронный код (все <script>)
runAllInitialScripts();

// 2. Стартовать Event Loop
while (true) {
  // 1. Выполнить ВСЕ микротаски (пока очередь не опустеет)
  while (hasMicrotasks()) {
    execute(dequeueMicrotask());
  }

  // 2. Проверить, не пора ли рендерить (~60 FPS)
  if (shouldRender()) {
    render(); // Style → Layout → Paint → Composite
  } else if (hasMacrotasks()) {
    // 3. Если рендер не нужен (или уже выполнен) — взять одну макротаску
    execute(dequeueMacrotask());
  }
}
```

Т.о., вся дальнейшая работа страницы контролируется Event Loop'ом. Например, пользователь нажал кнопку. В результате этого API браузера поместил обработчик этой кнопки в очередь макротаксок. Потом Event Loop извлечет эту макротаску из очереди и запустит на выполнение. Рендер не обязательно выполняется в каждой итерации Event Loop'а, потому что частота выполнения рендера плюс-минус фиксированная и если таски легкие, то можно успеть выполниться несколько итераций цикла, прежде чем возникнет необходимость провести рендер.

P.S. Event Loop обрабатывает очереди задач только когда Call Stack пуст, т.е. когда в данный момент нет выполняющегося кода. Для браузеров этот факт не очень актуален, потому что по определению Event Loop запускается только когда выполнится весь "начальный код", соответственно после его выполнения Call Stack пуст, а в процессе выполнения задач из очередей Call Stack наполняется и опустошается, так что к новой итерации цикла Call Stack опять же пуст. Но этот факт важен для других сред, т.к. теоретически Call Stack может быть не пуст. Соответственно, Event Loop не должен ничего делать в этом случае, он должен дождаться, пока код из стэка отработает, и только потом запускать задачи из очередей.

## Рендеринг

Рендеринг - это процесс, состоящий из нескольких этапов:

1. `Style calculation` (пересчёт стилей)
2. `Layout` (расчёт геометрии элементов)
3. `Paint` (отрисовка в bitmap)
4. `Composite` (слоистое наложение + вывод на экран)

Часть этой работы (начальные этапы) выполняется в главном потоке, а часть - в отдельных. Какие именно где - отдельная тема, не суть важно, главное понять, что часть рендеринга выполняется в главном потоке со всеми остальными задачами и они могут эти этапы рендеринга задержать, если выполняются долго.

Суть рендеринга - преобразование DOM и стилей в реальные пиксели на экране.

Браузер пытается выполнять рендер с частотой 60 кадров в секунду. Это значит, что рендер должен выполняться примерно каждые 16.6 мс. Но поскольку часть вычислений, которые нужны для рендера, выполняются в главном потоке, то если в нем запускается тяжелая задача (например, мы написали обработчик для кнопки, в котором крутится долгий цикл, имитируя тяжелую работу), которая запустилась и выполняется дольше этих 16.6 мс, тогда браузер не может выполнить рендер, пока тяжелая задача не завершится. Соответственно, "новый" кадр отсутствует, браузер отображает вместо него старый и из-за этого складывается впечатление, что страница тормозит.

У микрозадач абсолютный приоритет. Пока очередь микрозадач не пуста, они выполняются, а рендер - нет. Поэтому, если в микротаске рекурсивно создавать микротаски, то до рендера дело не дойдет вообще. Когда все микрозадачи выполнились, тогда идет проверка - пришло ли время делать рендер?

* Если не пришло, тогда браузер выполняет одну макрозадачу.
* Если оказалось, что время рендера пришло и "просрочено", тогда браузер может пойти двумя путями - если просрочилось чуть-чуть, тогда выполняется рендер. Если просрочилось сильно, тогда рендер пропускается и выполняется макрозадача.

Затем итерация Event Loop'а повторяется.

# Микро- и макрозадачи

Задачи делятся на микро- и макрозадачи. Вообще, таких терминов вроде бы нет в спеке, есть просто задачи, которые собираются в так называемые [task queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue) и [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) (еще называется PromiseJobs). Соответственно, условно задачи из первой очереди можно для наглядности назвать *макрозадачами*, а задачи из второй очереди - *микрозадачами*.

Написанное далее применимо к браузеру (могут быть технические неточности по сравнению со спекой, но судя по примерам с сайта Кантора, с практической точки зрения выглядит правдопободно):

* Микрозадачи - это:
  * Колбэки, переданные в методы промисов (then, catch, finally).
  * Intersection Observer.
  * Колбэки, переданные в функцию queueMicrotask.
  * Подключенный через динамический import(src) скрипт.
* Макрозадачи - это (несколько примеров, возможно это не все и есть еще):
  * Колбэки, переданные в setTimeout, setInterval.
  * mousemove, mouseover, click и прочие события.
  * И т.д.

# Примеры

Для тренировки понимания очередности выполнения микро- и макрозадач:

### Пример 1

```javascript
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');
```

Сначала выполняется сам главный скрипт. Тело промиса выполняется синхронно, поэтому надпись из него видна сразу. Потом последний вывод в консоль из главного скрипта. Т.к. сам скрипт считается макрозадачей, поэтому дальше должны выполниться все микрозадачи. В данном случае это единственный колбэк для промиса, переданный в then. Ну и потом, поскольку микрозадач больше нет, то берется следующая макрозадача, т.е. колбэк из setTimeout. Ответ:

```
Создание промиса
Конец скрипта
Обработка промиса
Таймаут
```

### Пример 2

```javascript
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve().then(() => console.log(5));
setTimeout(() => console.log(6));
console.log(7);
```

Сначала выполняется основной скрипт, поэтому 1 и 7. Затем идут микрозадачи, поэтому 3 и 5. В микрозадаче из второго промиса ничего не выводится, вместо этого в очередь добавляется новая макрозадача. Микрозадачи завершены, поэтому настал черед выполнять макрозадачи. Поэтому 2 и 6. Ну в конце 4. Ответ:

```
1  ,  7  ,  3  ,  5  ,  2  ,  6  ,  4
```

### Пример 3

```javascript
console.log("Script start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    queueMicrotask(() => console.log("queueMicrotask"));
  })
  .then(() => console.log("Promise 2"));

console.log("Script end");
```

```
Script start
Script end
Promise 1
Promise 2
queueMicrotask  - все микротаски выполняются до макротасок
setTimeout
```

### Пример 4

```javascript
console.log("Старт");

import('./module.js')
  .then(() => console.log("Модуль загружен"));

setTimeout(() => console.log("Таймаут"), 0);

Promise.resolve()
  .then(() => console.log("Промис"));
```

```
Старт
Промис
Модуль загружен
Таймаут
```

А вот если бы последний промис не был зарезолвлен сразу, тогда не было бы гарантий очередности между import и промисом. Тогда бы мы наверняка могли бы сказать, что сначала будет Старт, а в самом конце Таймаут. А что было бы вторым и третим зависело бы от того, что быстрее зарезолвится - импорт или промис.

