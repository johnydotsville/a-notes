# Обертки для примитивов

Все примитивные типы, кроме null и undefined, имеют обертки. Называются они так же как примитивы, только с большой буквы:

| Примитив | Обертка | Пример                                  |
| -------- | ------- | --------------------------------------- |
| number   | Number  | const a = new Number(7)                 |
| string   | String  | const str = new String("Hello, world!") |
| boolean  | Boolean | const flag = new Boolean(true)          |
| symbol   | Symbol  | const sym = new Symbol("foobar")        |
| bigint   | BigInt  | const big = BigInt(10)  // без new!     |

Обертка нужна, чтобы работать с примитивом как с объектом. Это дает нам возможность вызвать на примитиве метод, например `"hello, world!".toUpperCase()`. 

Обертка по сути - это функция-конструктор. Исключением является BigInt - он не обертка, он сам по себе, это не функция-конструктор, поэтому к нему нельзя применить new.

Обертки содержат все методы для работы с соответствующим типом. Это их основное назначение.

# Механика оберток

Механика такая:

* Когда на примитиве вызывается метод, то
  * Создается объект-обертка.
  * Метод выполняется и возвращает значение.
  * Объект-обертка уничтожается.

Т.о., обертка живет весьма не долго.

Пример:

```javascript
let message = "Hello, world!";
let capsed = message.toUpperCase();

console.log(capsed);  // HELLO, WORLD!
```

Метод обертки получает данные, хранящиеся в примитиве, обрабатывает их и возвращает результат. После этого обертка уничтожается. За кулисами движок может делать разные оптимизации, так что мб и не совсем уничтожается, но именно с логической точки зрения обертка перестает существовать после того, как метод выполнен.

Еще пример и одновременно вопрос:

```javascript
let str = "Привет";
str.test = 5;
alert(str.test);  // Что здесь будет?
```

Ответ: в строгом режиме будет ошибка, а в обычном - undefined. При попытке обратиться к свойству test на примитиве, создается обертка. Строгий режим не позволяет ее редактировать, поэтому присвоение даст ошибку. Нестрогий режим ошибку не даст, но после присвоения обертка уничтожится. Так что повторная попытка обратиться к свойству даст undefined.

P.S. Здесь у меня есть несколько вопросов, которые впрочем с практической точки зрения не сильно важны, поэтому ковыряться я не стану, а просто оставлю их и если когда-нибудь случайно вдруг узнаю ответы, запишу их. Вопросы такие:

* `str.test = 5;` в строгом режиме. Ошибку вызывает именно попытка инициализации свойства или сам факт попытки добавить свойство?
* `alert(str.test)` - здесь undefined появляется из-за того, что свойство именно отсутствует? Или из-за того что заново создается обертка, в нее добавляется test, но из-за того, что там нет значения, получается undefined? Вроде как должен быть первый вариант, потому что undefined мы получаем когда пытаемся обратиться к несуществующему в объекте свойству.