# Динамическая типизация

Динамическая типизация предполагает, что в одной переменной в разные моменты времени могут храниться значения разных типов. Javascript относится к динамически типизированным языкам:

```javascript
let foo = "Сейчас тут хранится строка";
foo = 255;  // А теперь - число. И это нормально.
```

# Типы данных

## Примитивные

### Число

Тип `number` выражает все числа, и целочисленные, и с плавающей точкой. Границы $±(2^{53}-1)$.

У него так же может быть три "специальных числовых значения":

* Бесконечность - получается при делении на ноль.

  * `Infinity`
  * `-Infinity`

* `NaN` - "not a number", получается в результате некорректной математической операции.

  ```javascript
  let result = "Строка" / 2;  // Тип значения в result получился NaN
  ```

  NaN в любой математической операции дает в результате NaN. Единственное исключение:

  ```javascript
  let result = "Строка" / 2;  // Nan
  let foo = result ** 0;  // 1, вместо NaN получилась единица.
  ```
  
  ** - оператор возведения в степень.

Математические операции в js безопасны. Скрипт не остановится из-за деления на ноль и т.д., просто в результате может получиться странный тип.

### BigInt

Тип `bigint` нужен для хранения очень больших чисел, которые не помещаются в number. Требуется редко, но все же. Для объявления такого числа в конец добавляется суффикс `n`:

```javascript
const bigInt = 1234567890123456789012345678901234567890n;  // n в конце.
```

### Строка

Тип `string`. Строки в js *неизменяемые*. Как только строка создана, изменить ее невозможно, только перезаписать полностью. Строки в js бывают двух типов:

* Обычные, заключаются в двойные или одинарные кавычки, без разницы:

  ```javascript
  let firstname = "John";  // Обычная строка.
  let lastname = 'Connor';  // Еще одна обычная строка.
  ```

* Вычисляемые, заключаются в обратные кавычки (на букве Ё и тильде). В таких строках можно разместить любое выражение внутри `${ }`, оно будет вычислено и станет частью строки:

  ```javascript
  let firstname = "John";
  let lastname = 'Connor';
  let fullname = `Полное имя: ${lastname + ", " + firstname}`;  // Полное имя: Connor, John
  ```

Специального типа для отдельного символа в js нет. Так что отдельный символ это тоже строка.

### Булевый

Тип `boolean`, хранит два значения:

* `true`
* `false`

### null

`null` является отдельным типом. Его концептуальный смысл - "значение неизвестно", "пусто", "ничего".

```javascript
let foo = null;
```

### undefined

Тип `undefined` означает "значение не присвоено".

```javascript
let foo = null;  // null
let bar;  // undefined
```

Можно явным образом присваивать undefined:

```javascript
let foo = 'Hello, world!';
foo = undefined;
```

Однако делать это не желательно. Для пустых значений есть null, а undefined обычно используется как раз для проверки, было ли присвоено переменной значение или нет.

### Символы

Тип `symbol`. Описал в разделе про объекты.

## Объекты

Тип `object` используется для хранения коллекций и значений, более сложных, чем примитивы. Описан в отдельном разделе про объекты.

## Обертки

Для примитивных типов существуют "обертки". Про них я написал в отдельном конспекте (в этом же разделе). Здесь же просто упоминание, чтобы знать просто что они есть.

# Определение типа

## typeof оператор

Определить тип значения можно с помощью оператора `typeof`. Он возвращает строку с именем типа и имеет две формы вызова:

* `typeof 5` - без скобок. Используется, когда значение простое.
* `typeof(5 + " рублей")` - со скобками. Используется, когда значение вычисляется и требуется явно указать оператору все значение целиком во избежание недоразумений.

Например:

```javascript
let type = typeof 5;  // В type будет строка "number"
```

```javascript
let type = typeof 5 + " рублей";  // В type будет строка "number рублей"
```

Во втором случае оператор вернул тип пятерки, т.е. строку number и слил ее со строкой " рублей".

```javascript
let type = typeof(5 + " рублей");  // В type будет строка "string"
```

Здесь мы объединили выражение в скобки и отдали его целиком оператору. В результате сначала произведена конкатенация пятерки со строкой, что дало строку, а уже потом эта строка ушла в typeof и он вернул string.

## Применение к переменным

Можно конечно применять typeof к переменным:

```javascript
let foo = "Просто строка";
let type = typeof foo;
```

## Особые случаи

Примеры вывода typeof:

```javascript
typeof undefined // "undefined"
typeof 0         // "number"
typeof 10n       // "bigint"
typeof true      // "boolean"
typeof "foo"     // "string"
typeof Symbol("id") // "symbol"
typeof Math      // "object"
```

Особые случаи:

```javascript
typeof null  // "object"
typeof alert // "function"
```

Особенность здесь вот в чем:

* null на самом деле не является объектом, потому что null это отдельный тип. Так что такой вывод typeof является признанной ошибкой оператора, которая осталась для совместимости.
* В js нет отдельного типа `function`. Функции в js являются объектами, но такой вывод typeof весьма удобен для определения функций, поэтому так и оставили.