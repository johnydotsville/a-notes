# Общие рекомендации:

* В функции, которая использует fetch (или любое другое средство отправки запросов), нужно ловить все возможные технические ошибки, обрабатывать их (логировать \ слать в мониторинговую систему) и перевыбрасывать user-friendly ошибку.
  * Такая ошибка должна содержать понятный пользователю текст и в ней не должно быть чувствительных технических данных.
    * Пример нейтрального и понятного пользователю сообщения без чувствительной информации: "Возникли временные трудности. Пожалуйста, повторите попытку позже".
    * Пример плохого сообщения пользователю: "Запрос по адресу 'тут-url-с-параметрами' не выполнился из-за того что параметр param не может быть преобразован в число".
* Логирование ошибок должно осуществляться через единую точку. Зачем это и что значит на практике?
  * В проде не должно быть вывода в консоль, потому что консоль видна пользователю.
    * Вывод в консоль допустим только в режиме разработки.
  * Поэтому вместо console.log нужно пользоваться логерами, например winston.
    * Они позволяют настроить каналы вывода логов - в консоль, в файл, в БД, в системы мониторинга и т.д.
    * Настройку этих каналов можно сделать в зависимости от переменных окружения.
      * Т.о. можем сделать так, чтобы в dev и test средах логировалось в консоль и файлы, а в prod отправлялось в систему мониторинга (например, Sentry).
* Это общая концепция работы с ошибками.

TODO: можно дополнить потом по мере применения этих советов в реальности. Например, подключу Winston, Sentry, и посмотрю как они вместе работают.



# Возможные ошибки запросов

Пока на примере fetch. Общий шаблон обработки ошибок запроса:

TODO: дописать аборт через signal.

```javascript
export async function fetchData<T>(url: string): Promise<T> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      if (response.status === 401) {
        throw new HttpError('Пожалуйста, пройдите авторизацию.', 401);
      } else if (response.status === 403) {
        throw new HttpError('У вас нет доступа к этому ресурсу.', 403);
      } else if (response.status === 404) {
        throw new HttpError('Данные не найдены.', 404);
      } else if (response.status === 500) {
        throw new HttpError('На сервере возникли неполадки. Попробуйте позже.', 500);
      }
      const body = await response.json().catch(() => {});
      const reason = body ?? 'Неизвестно.';
      logger.error('Сервер не вернул данные. Статус: ${response.status}. Причина: ${reason}');
      throw new HttpError('К сожалению, нам не удалось выполнить ваш запрос. Попробуйте позже.', response.status);
    }
    return await response.json();
  } catch (error) {
    if (error instanceof TypeError) {
      logger.error('Ошибка сети: ' + error.message);
    } else if (error instanceof DOMException && error.name === 'AbortError') {
      logger.error('Запрос прерван по таймауту: ' + error.message);
    } else if (error instanceof SyntaxError){
      logger.error('Ошибка при парсинге JSON ответа: ' + error.message);
    } else if (error instanceof Error) {
      logger.error('Ошибка: ' + error.message);
    } else if (error instanceof HttpError) {
      logger.error('HTTP-ошибка: ' + error.message);
      throw error;
    }
    throw new Error('Возникли временные трудности. Попробуйте еще раз позже.');
  }
}

class HttpError extends Error {
  constructor(message, status) {
    super(message);
    this.name = 'HttpError';
    this.status = status;
  }
}
```

## Технические, сетевые

```javascript
if (error instanceof TypeError) {
  logger.error('Ошибка сети: ' + error.message);
```

Когда fetch сталкивается с:

- Отсутствием интернета
- CORS-ошибками
- Некорректными URL (например, 'http://')
- DNS-ошибками (url корректный, но такого сервера не существует)

Он выбрасывает TypeError. Как-то надежно отличить что есть что их этих четырех не выйдет, так что в целом их можно считать абстрактной "ошибкой сети".

---

```javascript
if (error instanceof DOMException && error.name === 'AbortError') {
  logger.error('Запрос прерван по таймауту: ' + error.message);
```

Это исключение появляется, когда запрос прерывается с помощью signal. Отдельного класса для него нет, поэтому проверяется так.

---

```javascript
if (error instanceof SyntaxError){
  logger.error('Ошибка при парсинге JSON ответа: ' + error.message);
```

Такую ошибку получаем, когда парсинг JSON ответа заканчивается с какой-то ошибкой.

---

```javascript
if (error instanceof Error) {
  logger.error('Неизвестная ошибка: ' + error.message);
```

Это можно считать любой другой ошибкой, не относящейся к первым трем.

## HTTP-ошибки

Это не технические ошибки, а как бы логические. Например, когда сервер вернул ответ 500, 404, 403 и т.д. Т.е. мы ответ получили, технически все отработало как надо, но логически это может быть ошибкой. Например, запросили данные, а у пользователя нет к ним доступа, значит с логической точки зрения при получении данных возникла ошибка.

Чтобы удобнее отлавливать такие ошибки, можно создать отдельный класс, например HttpError.

```javascript
if (!response.ok) {
  if (response.status === 401) {
    throw new HttpError('Пожалуйста, пройдите авторизацию.', 401);
  } else if (response.status === 403) {
    throw new HttpError('У вас нет доступа к этому ресурсу.', 403);
  } else if (response.status === 404) {
    throw new HttpError('Данные не найдены.', 404);
  } else if (response.status === 500) {
    throw new HttpError('На сервере возникли неполадки. Попробуйте позже.', 500);
  }
  const body = await response.json().catch(() => {});
  const reason = body ?? 'Неизвестно.';
  logger.error('Сервер не вернул данные. Статус: ${response.status}. Причина: ${reason}');
  throw new HttpError('К сожалению, нам не удалось выполнить ваш запрос. Попробуйте позже.', response.status);
}
```

Основная идея в том, что мы проверяем статусы и выбрасываем соответствующие исключения для тех статусов, которые хотим отдельно обработать, чтобы показать пользователю осмысленное сообщение. Для всех прочих не-ok статусов выбрасываем дефолтную ошибку. А в catch ловим это исключение, логируем как и прочие и спокойно перевыбрасываем, потому что чувствительных данных в сообщении нет.