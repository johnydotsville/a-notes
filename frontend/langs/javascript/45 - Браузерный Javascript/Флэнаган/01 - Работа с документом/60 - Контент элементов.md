# Контент элемента

```html
<p>Мороз и солнце, <i>день</i> чудесный!</p>
```

В этой разметке контент внутри тега `p` можно рассматривать с двух позиций:

* HTML-строка `Мороз и солнце, <i>день</i> чудесный!`, т.е. как полноценный html-фрагмент с тегами.
* Голый текст `Мороз и солнце, день чудесный!`.

Для обоих ситуаций есть свои свойства.

## .innerHtml и .outerHtml

```html
<p>Мороз и солнце, <i>день</i> чудесный!</p>
```

Свойство `.innerHTML` - это содержимое тега в виде html, т.е. строка с тегами:

```javascript
const p = document.querySelector("p");
console.log(p.innerHTML);  // Мороз и солнце, <i>день</i> чудесный!
```

Свойство `.outerHTML` - то же самое, что innerHTML, но включая и сам тег объекта, на котором вызвано свойство:

```javascript
const p = document.querySelector("p");
console.log(p.outerHTML);  // <p>Мороз и солнце, <i>день</i> чудесный!</p>
```

Когда мы присваиваем что-то в innerHTML, браузер парсит этот текст и преобразует его в соответствующие объекты. Это происходит с хорошим быстродействием. Однако конкатенация с innerHTML, т.е. `innerHTML+=` происходит медленнее, потому что сначала браузеру приходится сериализовать (привести к строке) значение в innerHTML. Когда нужно что-то добавить, лучше не работать непосредстенно с innerHtml, а пользоваться методами добавления.

Никогда нельзя вставлять ввод пользователя в страницу, потому что это может быть текст сомнительного скрипта.

## .textContent и .innerText

```html
<p>Мороз и солнце, <i>день</i> чудесный!</p>
```

Свойство `.textContent` позволяет получить только текст из тега. Грубо говоря, в нем собраны текстовые ноды из самого тега и из всех вложенных в него тегов:

```javascript
const p = document.querySelector("p");
console.log(p.textContent);  // Мороз и солнце, день чудесный!
```

Поэтому, когда мы хотим получить \ вставить фрагмент в виде текста, то пользуемся свойством textContent. Оно рассматривает любые символы вроде скобок, амперсандов и т.д. как обычный текст.

Свойство .`innerText` не рекомендуется использовать, потому что у него есть дополнительное поведение вроде попыток сохранить форматирование таблиц, что не идет на пользу производительности, а также у него плохая совместимость между браузерами.

## script для хранения данных

Тег `script` можно использовать для хранения в странице произвольных данных. Для этого тегу script:

* Не надо задавать атрибут src.
* Надо задать атрибут `type="text/x-custom-data"`, тогда браузер не будет пытаться парсить и выполнять скрипт.

```html
<body>
  <p>Мороз и солнце, <i>день</i> чудесный!</p>
  <script id="myData" type="text/x-custom-data">Автор этих строк - Пушкин А.С.</script>
</body>
```

Получить содержимое скрипта можно свойством `.text`:

```javascript
const s = document.querySelector("#myData");
console.log(s.text);  // Автор этих строк - Пушкин А.С.
```

# Добавление контента

Для добавления контента есть несколько методов. У них у всех два параметра:

* Позиция добавления - строка, возможные значения: beforebegin, afterbegin, beforeend, afterend.
* Фрагмент, который надо добавить. Строка или объект.

Наглядная демонстрация позиций:

```yaml
# beforebegin
<p>
# afterbegin
Привет, мир!
# beforeend
</p>
# afterend
```

## .insertAjacentHTML()

[Документация](https://developer.mozilla.org/ru/docs/Web/API/Element/insertAdjacentHTML). Парсит строку, создает элементы и вставляет их в указанную позицию.

```html
<body>
  <p>Предвижу все: вас оскорбит</p>
</body>
```

```javascript
const p = document.querySelector("p");
p.insertAdjacentHTML("afterend", "<p>Печальной тайны объясненье.</p>");
```

Стало:

```html
<body>
  <p>Предвижу все: вас оскорбит</p>
  <p>Печальной тайны объясненье.</p>
</body>
```

## .insertAjacentText()

[Документация](https://developer.mozilla.org/ru/docs/Web/API/Element/insertAdjacentText). Вставляет строку в указанную позицию как обычный текст. Браузер не парсит эту строку, поэтому когда надо вставить именно обычный текст, лучше пользоваться этим методом, работать будет быстрее.

Метод ничего не возвращает.

```html
<body>
  <p>Предвижу все: вас оскорбит</p>
</body>
```

```javascript
const p = document.querySelector("p");
console.log(p.childNodes.length);  // 1
p.insertAdjacentText("beforeend", " печальной тайны объясненье.");
console.log(p.childNodes.length);  // 2
```

Как видно, вызов метода приводит к созданию новой текстовой ноды, а не модификации существующей.

## .insertAjacentElement()

[Документация](https://developer.mozilla.org/ru/docs/Web/API/Element/insertAdjacentElement). Вставляет элемент в указанную позицию. Возвращает null, если вставка не удалась и сам элемент, если удалась.

```html
<body>
  <p>Предвижу все: вас оскорбит</p>
</body>
```

```javascript
const p = document.querySelector("p");

const h1 = document.createElement("h1");
h1.innerText = "Письмо Онегина к Татьяне";

p.insertAdjacentElement("beforebegin", h1);
```





