# Типы и общая идея

| Тип              | Документация                                                 | Комментарий                                                  |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `IDBTransaction` | [MDN](https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction) | Любая работа с данными может выполняться только внутри транзакции. |

Любая работа с данными хранилища (не только запись, но и чтение) может выполняться только внутри транзакции. Как минимум потому, что технически единственный способ получить объкт хранилища - это создать транзакцию, а из нее вытащить хранилище.

# Болванка для примеров

```html
<body>
  <button id="deleteDb">Удалить БД</button>
  <button id="dosome">Выполнить код</button>
</body>
```

```javascript
let db;
const dbname = "idb";
const dbversion = 1;
const storageName = "person";

const openRequest = window.indexedDB.open(dbname, dbversion);

openRequest.onupgradeneeded = (event) => {
  const database = event.target.result;
  const storage = database.createObjectStore(storageName, { keyPath: "id" });
}

openRequest.onsuccess = (event) => {
  db = event.target.result;
}

document.querySelector("#deleteDb").addEventListener("click", () => {
  if (db) {
    db.close();
    const delReq = indexedDB.deleteDatabase(dbname);
    delReq.onsuccess = (event) => {
      console.log("БД удалена.");
    }
  }
});

document.querySelector("#dosome").addEventListener("click", () => {
  // <-- Здесь создаем транзакции
});
```

# Создание транзакции

Транзакция стартует методом `db.transaction(storage, mode)` на объекте БД ([документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction)). Он возвращает объект транзакции:

```javascript
const tx = db.transaction("myStorage", "readwrite");
```

```javascript
const tx = db.transaction(["storage_A", "storage_B"], "readwrite");
```

У метода три параметра:

* Имя хранилища - строковое имя хранилища, которое затрагивает транзакция.
  * Может быть массивом имен, если транзакция задействует несколько хранилищ. Если хочется задействовать сразу все хранилища, то пригодится свойство db.objectStoreNames.
* Режим транзакции:
  * `readonly` - дефолтное значение. В такой транзакции можно только читать данные. Несколько таких транзакций не блокируют друг друга и могут выполняться одновременно. У этой транзакции лучшая производительность, так что если надо только читать, надо использовать именно ее.
  * `readwrite` - в такой тракзакции можно и читать, и писать данные. Эти транзакции блокирующие. Пока такая транзакция выполняется, остальные будут ждать, пока она закончится и только тогда смогут работать.
  * `versionchange` - такой тип транзакции невозможно создать самостоятельно. indexeddb создает такую транзакцию при создании чистой БД, либо при открытии БД с повышением версии.
* options - TODO, не критично вроде.

# Момент начала транзакции

Транзакция стартует сразу как создана, а не когда в ней начинается выполнение запроса.

```javascript
const tx1 = db.transaction("book", "readwrite");  // <-- tx1 начинается уже тут.
const tx2 = db.transaction("book", "readwrite");
const s1 = tx1.objectStore("book");
const s2 = tx2.objectStore("book");
s2.put("200", 1);  // данные, ключ
s1.put("100", 1);
```

Смысл примера в том, что если смотреть последовательность операторов, то можно подумать, что в хранилище под ключом 1 должно сохраниться число 100, т.к. put перезаписывает данные, если такой ключ уже есть. 

Однако сохранится 200, потому что транзакция tx1 начинается уже на строчке 1. Поскольку обе транзакции являются readwrite, т.е. блокирующие, то tx2 будет ждать, пока выполнится tx1. Т.о., команда `s2.put("200", 1);` фактически выполнится после  `s1.put("100", 1);` из-за организации транзакций.

# Состояния транзакции

Транзакция может быть в нескольких состояниях:

* active - в этом состоянии транзакция находится в момент создания и в моменты событий success и error запросов, которые в ней выполняются.
* inactive - в этом состоянии транзакция находится, когда event loop переключается на выполнение других задач, не связанных с транзакцией и ее запросами.
* commiting - в это состояние транзакция переходит, когда нет новых запросов и она пытается закоммитится. "Хуков" для отлова этого состояния вроде бы нет.
* finished - в это состояние транзакция переходит, когда успешно закоммитилась или произошла ошибка. Когда тригерятся события abort \ complete на транзакции, она находится в finished-состоянии.

Основная идея такая: пока транзакция активна, мы можем с ней работать, например, добавлять новые запросы. Когда транзакция не активна - мы не можем этого делать. Работа транзакции связана с работой event loop. Когда в event loop попадает функция, в которой мы создаем транзакцию, то мы тут же можем и накидать в нее запросов. Когда функция завершается и event loop начинает выполнять другую задачу, например, обрабатывать какой-нибудь setTimeout или click, то транзакция в это время становится inactive и мы бы никак не могли в нее ничего добавить. Когда запрос из транзакции выполняется и для него срабатывает success \ error событие, то в этот момент транзакция опять active, а значит в обработчиках этих событий мы снова можем поработать с транзакцией, например накидать в нее новых запросов.

Когда больше нет новых запросов, транзакция переходит в inactive, из него - в commiting. После попытки закоммититься она переходит в состояние finished. В момент выполнения событий complete \ abort она является finished.

# Коммит, откат транзакции

У транзакции есть три метода ([документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction#instance_methods)):

* `.objectStore()` - для получения хранилища.
* `.commit()` - для принятия транзакции. Вручную обычно не вызывается.
* `.abort()` - для отката транзакции.

Коммитить транзакцию вручную обычно не нужно, потому что она автоматически коммитится, когда все запросы успешно выполнены, а новых не поступило.

Отменять транзакцию вручную тоже, скорее всего, обычно не приходится. Потому что если при выполнении запросов, входящих в транзакцию, возникает ошибка, то транзакция автоматически откатывается. С виду кажется, что ручной откат может пригодиться в случае обнаружения какой-то логической ошибки. Но как будто бы есть смысл сначала проверять данные на такие ошибки, а потом уже добавлять в БД. Т.е. сначала полностью понять, что нужно сделать, а потом уже делать.

# События транзакции + пример

## События транзакции

У транзакции есть три события:

* `complete` - происходит, когда транзакция успешно завершилась.
* `error` - происходит, когда в каком-то из запросов, выполняющихся внутри транзакции, возникает ошибка. Например, вставляется объект с дублирующимся ключом. Тогда возникает error на самом запросе, а потом error на транзакции.
* `abort` - возникает при откате транзакции.
  * Если откат вызван ошибкой в запросах, тогда срабатывает error на транзакции, а потом уже abort.
  * Если явно вызвать на транзакции метод abort(), тогда сразу сработает событие abort, без события error.

```javascript
const tx = db.transaction(storageName, "readwrite");
tx.oncomplete = (event) => {  // <-- Успешное завершение транзации.
  console.log("complete событие на транзакции.");
}
tx.onerror = (event) => {  // <-- Ошибка при выполнении транзакции.
  // event.preventDefault();  // <-- Отмена авто-отката в случае ошибки.
  console.log("error событие на транзакции.");
}
tx.onabort = (event) => {  // <-- Откат транзакции.
  console.log("abort событие на транзакции.");
}

const data = {
  id: 1,
  name: "Tom Sawyer"
}

const storage = tx.objectStore(storageName);
const addRequest = storage.add(data);

addRequest.onsuccess = (event) => {  // <-- Запрос успешно завершился.
  console.log("complete событие на запросе добавления данных.");
  // tx.abort();  // <-- Можно явно прервать транзакцию, если нужно.
}
addRequest.onerror = (event) => {  // <-- Ошибка в запросе.
  console.log("error событие на запросе добавления данных.");
}
```

## Откат - это дефолтное действие

Ошибка в запросе всплывает до транзакции и это приводит к откату транзакции. Откат транзакции - это *дефолтное действие*, а значит мы можем его отменить, вызвав метод preventDefault() на объекте события. Это можно сделать как в error-событии запроса, так и в error-событии самой транзакции:

```javascript
const tx = db.transaction(storageName, "readwrite");
tx.oncomplete = (event) => {
  console.log("complete событие на транзакции.");
}
tx.onerror = (event) => {
  // event.preventDefault();  // <-- Можно отменить авто-откат тут
  console.log("error событие на транзакции.");
}
tx.onabort = (event) => {
  console.log("abort событие на транзакции.");
}

const data = {
  id: 1,
  name: "Tom Sawyer"
}

const storage = tx.objectStore(storageName);
const addRequest = storage.add(data);

addRequest.onerror = (event) => {
  // event.preventDefault();  // <-- Или тут.
  console.log("error событие на запросе добавления данных.");
}
```

Если не отменять авто-откат, то срабатывает error + abort события транзакции. Если отменить, то error + complete.

### Польза отмены авто-отката

От отмены авто-отката может быть польза в случае, когда у нас множество запросов в одной транзакции, но они не связаны друг с другом и поэтому ошибка в одном не должна влиять на других. Например, мы сохраняем  100 объектов и в одном окажется неправильный ключ. Вероятно нам захочется не откатывать все объекты, а просто выдать информацию, что "такой-то объект не сохранен, а остальные сохранились нормально":

```javascript
const tx = db.transaction(storageName, "readwrite");
const storage = tx.objectStore(storageName);

const result = [];  // <-- Сюда сложим отчет по результатам сохранения объектов.

const data = [
  { id: 1, name: "Tom Sawyer" },
  { id: 1, name: "Huck Finn" },  // <-- Ошибка будет при сохранении второго объекта.
  { id: 3, name: "Jim" }
];

data.forEach(x => {
  const addRequest = storage.add(x);
  addRequest.onerror = (event) => {
    console.log("Ошибка при сохранении данных.");
    result.push({ suceeded: false, data: x, error: event.target.error })
  }
  addRequest.onsuccess = (event) => {
    console.log("Данные успешно сохранены.");
    result.push({ succeeded: true, data: x, error: null })
  }
});

tx.onerror = (event) => {
  event.preventDefault();  // <-- Отменим авто-откат.
}
tx.oncomplete = () => {
  console.log("Транзакция завершена.");
  console.log(result);
}
```

