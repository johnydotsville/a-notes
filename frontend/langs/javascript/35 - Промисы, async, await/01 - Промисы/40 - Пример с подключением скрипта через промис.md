# Идея промиса

Промис - это объект, который позволяет нам синхронно выполнить какой-то код, а когда он завершится, асинхронно выполнить дополнительные действия.

Сразу практический пример: подключить библиотеку lodash и с помощью нее вывести в консоль случайное число:

```javascript
function addScript(src) {
  return new Promise((resolve, reject) => {  // <-- Этот код выполнится синхронно.
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Не удалось подключить скрипт ${src}.`));
    document.head.append(script);  // <-- Скачивание начинается в этот момент. Происходит асинхронно.
  });  
}

addScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js")
  .then(result => printRandomNumber(1, 100))  // <-- А этот - асинхронно
  .catch(err => console.log(err.message));  // <-- И этот тоже.

function printRandomNumber(min, max) {
  console.log(_.random(min, max));
}
```

Комментарии:

* Функция добавления скрипта на страницу возвращает промис.
  * В данном случае мы подключаем скрипт lodash. Он лежит по известному адресу в интернете.
  * Подключение заключается в создании элемента `<script>` и добавлении его на страницу программным способом.
  * Скачивание начинается в момент выполнения .append. Оно происходит асинхронно.
    * По сути, основной скрипт только производит настройку, раздает указания. Когда он завершается, то начинается скачивание и подключение. Когда оно завершается, выполняются настроенные на соответствующие события колбэки.
  * Если элемент скрипта добавился на страницу нормально, то браузер выполняет onload, а если есть проблемы - onerror.
    * Именно поэтому мы на эти события навешиваем лямбды с вызовом resolve и reject.
    * Т.о. промис завершится, когда сработает одно из этих событий.
* На промис мы вешаем обработчики результата и ошибки.
  * В случае успеха вызываем функцию, которая пользуется lodash'ем для генерации случайного числа.
    * Как такового "результата" работы у нашего работяги нет, поэтому вызываем `resolve()`  без аргументов. Результатом является сам факт успешной загрузки скрипта и добавление его на страницу.
  * В случае ошибки просто выводим текст ошибки в консоль.

Основная польза от промисов - снижение фактора callback-hell. Вложенность колбэков становится ниже за счет того, что промисы удобно организовывать в цепочки.

В этом конспекте больше рассмотрено внешнее пользование промисами, обзорное, а более детальные механики работы методов будут в следующих конспектах.