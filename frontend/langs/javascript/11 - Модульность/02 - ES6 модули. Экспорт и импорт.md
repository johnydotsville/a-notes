# Оформление модулей

Чтобы модули заработали в браузере, достаточно подключить стартовый скрипт как модуль, а все остальные модули, которые импортируются в нем и дальше, подключатся автоматически:

```html
<script type="module">import "./scripts/foobar.js";</script>
```

> P.S. Запускать такой файл нужно через Go Live в VS Code. Если просто открыть в браузере html-файл, будет ошибка CORS.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Javascript полигон</title>
</head>
<body>
  <div id="poetry">
    <span class="phrase">Раз прислал мне барин чаю</span>
    <span class="phrase">И велел его сварить.</span>
    <div>
      <cite>Народное творчество</cite>
    </div>
  </div>
  <!-- Подключаем стартовый скрипт как модуль, а все остальные подтянутся сами -->
  <script type="module">import "./scripts/foobar.js";</script>
</body>
</html>
```

Сам модуль - это обычный js-файл, в котором написаны переменные, классы и прочие вещи, которые мы можем экспортировать:

```javascript
export const defaultUnits = "cm";  // <-- Экспортируем константу
const version = 1.0.0;  // <-- А эта константа не будет доступна вне модуля
```

И импортировать:

```javascript
import { defaultUnits } from "./WideUsedValues.js";  // <-- Импортируем константу из модуля
console.log(defaultUnits);  // cm
```

# Несколько общих слов об экспорте и импорте

* Для всех вещей, будь то переменные или функции, синтаксис экспорта \ импорта работает одинаково (почти).
* Экспорт \ импорт бывает трех видов, и для каждого свои правила синтаксиса.
  * Дефолтный.
  * Именованный.
    * Комбинация дефолтного и именованного.
  * Импорт без экспорта. 
* import и export реализуют *статический* экспорт \ импорт. Это означает, что сначала загружаются все модули, а потом только скрипт начинает выполняться.

# Указание путей до файлов

* Импорты принято писать в начале модуля, это является хорошей практикой.
  * Хотя технически это не обязательно, т.к. импорты всплывают (hoisting).
* В качестве имени файла используется строка в кавычках.
  * Использовать вычисляемую строку или переменную со строкой - нельзя. Только литерал строки.
  * Обязательно нужно указывать расширение файла.
  * Положение подключаемого файла можно задать несколькими способами:
    * Рассчитать *относительно* от файла, в котором производится импорт, с помощью `./` или `../`
    * Задать *абсолютно* от корня программы (условно, index.html) с помощью `/`

# Дефолтный экспорт и импорт

## Дефолтный экспорт

* Только одну вещь можно экспортировать из модуля как дефолтную.

  ```javascript
  const firstname = "Huck";
  const lastname  = "Finn";
  
  export default firstname;
  export default lastname;  // <-- Ошибка, дефолтный экспорт мб только один.
  ```

* Ключевые слова `default` и `const` не дружат, когда стоят рядом. Поэтому, например, функцию мы можем экспортировать сразу же при объявлении:

  ```javascript
  export default function fullname(firstname, lastname) {  // <-- Нормально
    return `${firstname} ${lastname}`;
  }
  ```

  А переменную - не можем, и должны делать экспорт отдельной строкой:

  ```javascript
  export default const fullname = "Huck Finn";  // <-- Ошибка, default и const не дружат
  ```

  ```javascript
  const fullname = "Huck Finn";
  export default fullname;  // <-- Приходится экспортировать отдельной строкой
  ```

## Дефолтный импорт

* Обычно выполняется без фигурных скобок `{ }`
* Можно написать произвольное имя для дефолтно экспортированной вещи.
  
  * Оно может быть такое же как в экспорте:
  
    ```javascript
    import lastname from "./WideUsedValues.js";  // <-- Импорт делаем без скобок { }
    ```
  
  * Или другое:
  
    ```javascript
    import surname from "./WideUsedValues.js";  // <-- Для деф. экспорта можно задать любое имя.
    ```

* Есть возможность использовать синтаксис *именованного* импорта для импорта *дефолтно экспортированной* вещи. Это дает нам еще один вариант импорта дефолта под произвольным именем: `import { default as someName }` - слово default указывает, что имя задается для дефолтно экспортированной вещи:

  ```javascript
  import { default as surname }  // <-- Произвольное имя для дефолтной вещи, через синтаксис именованного импорта
  ```

# Именованный экспорт и импорт

## Экспорт

### База

* Именованный экспорт можно выполнить на одной строке с объявлением:

  ```javascript
  export const units = "cm";  // <-- export на одной строке с объявлением
  ```

* Можно выполнить на отдельной строке, для этого потребуются скобки `{ }`

  ```javascript
  const units = "cm";
  export { units }  // <-- Для экспорта отдельной строкой нужны скобки { }
  ```


### Экспорт под другим именем

Синтаксис позволяет экспортировать вещи под другими именами. Это может быть полезно, когда внутри модуля используются краткие имена, а наружу хочется выставить более описательные:

```javascript
const un = "cm";  // <-- Краткие имена для внутримодульного пользования
const sz = 200;

export { un as units, sz as size }  // <-- Описательные имена для клиентов модуля
```

## Импорт

### База

* Имя берется в фигурные скобки `{ }`
  
  * Имена должны быть такие же, как и в экспорте.
  
* Можно в одних скобках указывать несколько импортируемых вещей через запятую:

  ```javascript
  import { units, size } from "./WideUsedValues.js";
  ```

*  Можно импортировать каждую вещь отдельно:

  ```javascript
  import { units } from "./WideUsedValues.js";
  import { size } from "./WideUsedValues.js";
  ```

### Переименование

При импорте допускается переименование, синтаксис `{ origName as newName }`. Может быть полезно (или даже необходимо), если например несколько модулей экспортируют вещи под одинаковыми именами, а мы хотим их импортировать.

```javascript
import { units as dimensions } from "./WideUsedValues.js";  // <-- Переименовали вещь при импорте
console.log(dimensions);
```

Такой синтаксис позволяет также захватить и дефолтный экспорт и задать ему имя. `import { default as someName }` - слово default указывает, что имя задается для дефолтно экспортированной вещи.

```javascript
export const units = "cm";
const fixed = true;
export default fixed;

import { 
  default as nochange,  // <-- Задаем имя для дефолтной вещи, используя синтаксис именованного импорта
  units
} from "./WideUsedValues.js";
console.log(nochange);
```

### import *

* Можно разом импортировать все не-дефолтные вещи и поместить их в свойства объекта.
  * Имя объекту даем произвольное.
  * Имена свойств будут такие же, как имена вещей.

```javascript
// <-- Импортируем все вещи разом и они попадают в одноименные свойства объекта dim
import * as dim from "/scripts/WideUsedValues.js";
console.log(dim.units);  // <-- Пользуемся нужными вещами через свойства объекта
console.log(dim.size);
```

# Комбинированный экспорт и импорт

Модуль может совмещать экспорты. Например, кроме дефолтного сделать еще несколько обычных:

```javascript
export const units = "cm";
export const size = 200;
const fixed = true;
export default fixed;
```

При импорте тоже можно комбинировать синтаксис дефолтного и именованного импорта:

```javascript
import fixed, { units, size } from "/scripts/WideUsedValues.js";
console.log(units);
console.log(size);
```

# Импорт без экспорта (выполнение кода)

Можно импортировать модули, в которых ничего не экспортируется:

```javascript
import "/scripts/WideUsedValues.js";  // <-- Просто указываем сам модуль, безо всяких имен
```

В этом случае модуль просто выполнит свой код единожды. Повторные импорты не приведут к повторному выполнению этого кода. Это может пригодиться, когда модуль, например, навешивает какие-то обработчики или выполняет какие-то вычисления, в общем, ему просто незачем что-то экспортировать. Сам он при этом может пользоваться импортами.

```javascript
// <-- Модуль ничего не экспортирует
const arr = [5, 7, 3, 8];
const sum = arr.reduce((acc, cur) => acc + cur);
alert(`Сумма элементов массива: ${sum}`);
```

```javascript
// <-- При импорте выполнится только один раз
import "/scripts/WideUsedValues.js";
import "/scripts/WideUsedValues.js";  // <-- Не приведет к повторному выполнению
```

# Ре-экспорт

## База

Если у нас есть много файлов с разными вещами на экспорт, то мы можем подготовить единый файл, и реэкспортировать из него все эти вещи. Т.о. конечному пользователю не придется делать импорты из множества файлов - он воспользуется этим "файлом-сборником". Пример:

Два отдельных файла с экспортами:

```javascript
// Файл math.js
export const plus = (a, b) => a + b;
export const minus = (a, b) => a - b;
```

```javascript
// Файл message.js
export const hello = () => console.log("Hello!");
export const goodbye = () => console.log("Goodbye!");
```

Файл с ре-экспортом:

```javascript
// Файл combo.js
// Тут не надо ничего импортировать. Ре-экспорт делается СРАЗУ, без импорта.
export { plus, minus } from "./math.js";  // <-- Ре-экспортируем вещи из math.js
export { hello, goodbye } from "./message.js";  // <-- Ре-экспортируем вещи из message.js
```

Файл конечного пользователя:

```javascript
import { plus, minus, hello, goodbye } from "./combo.js";  // <-- Импорт из "комбо-файла"

hello();
console.log(plus(5, 7));
console.log(minus(7, 2));
goodbye();
```

## Ре-экспорт с переименованием

При ре-экспорте можно переименовать вещи:

```javascript
// Файл combo.js
// Тут не надо ничего импортировать. Ре-экспорт делается СРАЗУ, без импорта.
export { 
  plus as sum,  // <-- Ф-ию plus переименовали в sum
  minus
} from "./math.js";
export { 
  hello as hi,  // <-- hello в hi
  goodbye as bye  // <-- а goodbye в bye
} from "./message.js";
```

Теперь клиент должен использовать новые имена:

```javascript
import { sum, minus, hi, bye } from "./combo.js";

hi();
console.log(sum(5, 7));
console.log(minus(7, 2));
bye();
```

## Ре-экспорт всего (*)

Если мы хотим реэкспортировать вообще все, что есть в файле, то можем воспользоваться звездочкой `*`:

```javascript
// Файл combo.js
// Тут не надо ничего импортировать. Ре-экспорт делается СРАЗУ, без импорта.
export * from "./math.js";
export * from "./message.js";
```

В этом случае клиент использует оригинальные имена вещей:

```javascript
import { plus, minus, hello, goodbye } from "./combo.js";

hello();
console.log(plus(5, 7));
console.log(minus(7, 2));
goodbye();
```

## Ре-экспорт дефолта

Если оригинальный файл содержит дефолтный экспорт:

```javascript
// Файл message.js
const hello = () => console.log("Hello!");
export const goodbye = () => console.log("Goodbye!");

export default hello;  // <-- В оригинальном файле есть дефолтный экспорт
```

То этот дефолтный экспорт ре-экспортируется вот так:

```javascript
// Файл combo.js
export * from "./math.js";
export {
  goodbye,
  default as hello  // <-- Ре-экспортируем дефолт из message.js под именем hello
} from "./message.js";
```

## Ре-экспорт как дефолт

```javascript
// Файл message.js
export const hello = () => console.log("Hello!");
export const goodbye = () => console.log("Goodbye!");
```

Если нужно из самого комбо-файла экспортировать что-то как дефолт:

```javascript
// Файл combo.js
export {
  goodbye as default,  // <-- Обычную функцию ре-экспортируем как дефолт
  hello
} from "./message.js";
```

Клиентский файл:

```javascript
import { hello, default as goodbye } from "./combo.js";

hello();
goodbye();
```
