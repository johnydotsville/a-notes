# История переходов, объект History

Когда location изменяется, то все его значения сохраняются в виде списка, по которому можно перемещаться вперед и назад. Скрипты не имеют доступа непосредственно к содержимому этого списка, чтобы не было возможности заполучить историю посещений.

Список хранится в объекте `History`, а он лежит в свойстве `window.history`. У него есть свойство `.length`, содержащее количество сохраненных url. Для только что открытой вкладки длина будет `1`.

Методы объекта History:

* `.back()`, `.forward()` - переход назад и вперед, работают так же как кнопки назад и вперед браузера.
* `.go(2)` - метод позволяет перейти не на один, а на указанное количество шагов вперед (если число положительное) или назад (если число отрицательное). Если указать 0, тогда текующая страница перезагрузится.

На странице могут присутствовать и другие страницы, встроенные например через тег `iframe`. В таком случае история переходов внутри встроенной страницы объединяется с историей родительской страницы. Тогда переход вперед-назад вполне может оставлять родительскую страницу без изменений, а влиять на location встроенной страницы.

Эти методы в основном относятся к работе со статичными страницами, которые целиком загружаются с сервера. Когда страницы являются динамическими и работа с ними больше похожа не на переход между разными страницами, а на переход страницы из одного состояния в другое, то используются иные техники для работы с историей:

* Кодирование состояния страницы в hash и использование события `hashchange`.
* Сохранение состояния с помощью метода `.pushState()`

# Событие window.hashchange

Этот подход основывается на следующих особенностях работы hash-части url:

* Изменение hash приводит к появлению нового элемента в истории посещений.
  * При этом hash не обязательно должен указывать на какую-то часть страницы. Это может быть произвольная строка.
* При изменении hash возникает событие `hashchange`, которое получает текущий hash.

Соответственно, суть подхода заключается в том, чтобы написать функцию кодирования \ декодирования состояния приложения в короткую строку и использовать эту строку в качестве hash. Изменилось состояние? Кодируем его, меняем hash. Т.о. в истории оказывается приложение в определенном состоянии. Можно даже в закладки его добавить. Изменился hash? Декодируем его, получаем состояние и приводим приложение к этому состоянию.

Очень приблизительный пример как это могло бы выглядеть: сделаем поле ввода строки и будем запоминать каждый ввод:

```html
<body>
  <input type="text" />
  <button>Запомнить</button>
</body>
```

```javascript
const input = document.querySelector("input");
const button = document.querySelector("button");

window.addEventListener("hashchange", (event) => {
  const restored = (new URL(event.newURL)).hash.substring(1);
  input.value = restored;
});

button.addEventListener("click", () => {
  window.location.hash = input.value;
});
```

TODO: переписать этот пример на более качественный, когда буду знать как именно это лучше сделать.

# Методы history.pushState() и replaceState()

| Артефакт         | Документация                                                 |
| ---------------- | ------------------------------------------------------------ |
| popstate событие | [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) |

Более аккуратный способ управлять состоянием приложения с помощью истории - это использование метода `history.pushState()` в комбинации с событием `window.popstate`.

У метода `pushState()` три параметра:

* Состояние - значение, которое надо сохранить. Это может быть любой сложный объект. Для его сериализации используется Structured Clone Algorithm.
* Комментарий - это строка, что-то вроде пояснения к состоянию. Параметр обязательный, но обычно используется пустая строка.
* URL - url, который надо ассоциировать с состоянием. Необязательный параметр. Можно задавать абсолютный или относительный url. При переходах по истории браузер будет отображать этот url в адресной строке. Может понадобиться, если нужно сделать возможность добавления приложения в определенном состоянии в закладки.

Еще есть метод `window.replaceState()`. У него такие же параметры и работает он так же, только замещает текущее состояние новым, а не добавляет.

Важные замечания:

* С помощью этих методов можно заменять URL в адресной строке, но это не приводит к перезагрузке страницы. Этот факт используется фреймворками вроде React для организации переходов в одностраничных приложениях.

Когда осуществляется переход по истории (например, кнопками Назад и Вперед), то возникает событие `popstate`, которое можно обработать на window. У объекта события есть свойство `state`, которое содержит сохраненное через pushState состояние.

При использовании этого подхода при управлении состоянием на старте приложения имеет смысл вызвать replaceState() и передать начальное состояние. Также надо помнить, что в момент первого открытия страницы событие popstate может не возникнуть (зависит от браузера). Так что если пользователь добавил закладку, а потом открыл ее, то логичнее восстановление состояния реализовать на уровне скрипта, а не события.

Пример: запоминаем историю ввода в текстовое поле:

```html
<body>
  <input type="text" />
  <button>Запомнить</button>
</body>
```

```javascript
history.replaceState({ text: "" }, "");

const input = document.querySelector("input");
const button = document.querySelector("button");

window.addEventListener("popstate", (event) => {
  input.value = event.state.text;
});

button.addEventListener("click", () => {
  history.pushState({ text: input.value }, "", `?text=${input.value}`);
});
```

