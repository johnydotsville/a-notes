# Типы и общий принцип

| Тип                | Дока                                                         | Назначение                                                   |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `IDBFactory`       | [IDBFactory](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory) | Интерфейс для организационной работы с базами данных - открыть, удалить, получить список БД-шек. Реализация интерфейса - объект `window.indexedDB` |
| `IDBOpenDBRequest` | [IDBOpenDBRequest](https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest), [IDBRequest](https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest) | Интерфейс запроса на открытие \ удаление БД. Содержит события, через подписку на которые мы можем обработать момент, когда действие открытия \ удаления завершилось. Объект, реализующий этот интерфейс, нам возвращают методы открытия \ удаления. |
| `IDBDatabase`      | [IDBDatabase](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase) | Интерфейс БД-соединения (connection). На нем мы стартуем транзакции для непосредственной работы с БД (добавление \ удаление данных и т.д.). Объект соединения мы получаем из свойства `.result` запроса на открытие БД. |

Общая схема работы такая: создаем запрос на открытие БД. Вешаем обработчики на события. В событии успешного открытия извлекаем объект БД из запроса. Работаем с БД.

# Открытие и создание БД

## Запрос на открытие-создание, метод .open()

```javascript
const request = window.indexedDB.open("myIDB", 1);
```

БД создается и открывается одним и тем же методом - `.open()`. Метод - асинхронный. У него два параметра:

* Имя БД.
* Версия БД.

Метод возвращает `запрос` на создание \ открытие БД. У запроса четыре события:

* Собственные:
  * `onupgradeneeded` - срабатывает в двух случаях:
    * Когда БД еще не существует.
    * Когда в open указана версия старше, чем текущая версия БД.
  * `onblocked` - срабатывает, когда БД уже открыта, а ее пытаются открыть повторно с повышенной версией. В этом же случае срабатывает событие `versionchange` на объекте самой БД.
* Унаследованные от IDBRequest:
  * `onsuccess` - срабатывает, когда БД открылась успешно.
  * `onerror` - срабатывает, когда при открытии БД произошла ошибка.

`onupgradeneeded` и `onsuccess` срабатывают последовательно. Например, если БД не существует или версия увеличилась, то сначала сработает onupgradeneeded, а потом onsuccess.

Целью всех этих событий является сам запрос. Поэтому все эти события получают объект события, у которого в свойстве  `.target` находится объект запроса.

Пример для проверки событий, связанных с открытием \ закрытием БД:

```html
<body>
  <input id="DBVersion" type="text" value="1" placeholder="Версия БД"/>
  <button id="buttonCreateOrOpenDB">Создать \ открыть БД</button>
  <button id="buttonCloseDB">Закрыть БД</button>
  <button id="buttonDeleteDB">Удалить БД</button>
  <button id="buttonShowDBInfo">Информация об открытой БД</button>
</body>
```

```javascript
window.onload = () => {
  let db;
  const dbname = "idbtraining";

  const inputDBVersion = document.querySelector("#DBVersion");
  const buttonCreateOrOpenDB = document.querySelector("#buttonCreateOrOpenDB")
  const buttonCloseDB = document.querySelector("#buttonCloseDB");
  const buttonDeleteDB = document.querySelector("#buttonDeleteDB");
  const buttonShowDBInfo = document.querySelector("#buttonShowDBInfo");
  
  buttonCreateOrOpenDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка создания \\ открытия БД.");
    const dbversion = inputDBVersion.value;
    const request = window.indexedDB.open(dbname, dbversion);

    request.onupgradeneeded = (event) => {
      console.log("upgrageneeded событие на запросе открытия.");
    }

    request.onsuccess = (event) => {
      console.log("success событие на запросе открытия.");
      db = event.target.result;
      db.onversionchange = (event) => {
        console.log("versionchange событие на БД.");
      };
    }

    request.onerror = (event) => {
      console.log("error событие на запросе открытия.");
    }

    request.onblocked = (event) => {
      console.log("blocked событие на запросе открытия.");
    }
  });

  buttonCloseDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка закрытия БД.");
    db.close();
  });

  buttonShowDBInfo.addEventListener("click", () => {
    console.log("> > > Нажата кнопка получения информации о БД.");
    console.log("Имя БД: " + db.name);
    console.log("Версия БД: " + db.version);
  });

  buttonDeleteDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка удаления БД.");
    window.indexedDB.deleteDatabase(dbname);
  });
}
```

## Версия БД

По мере развития приложения может меняться структура хранения данных. В этом случае нужно писать миграции - код по переносу уже имеющихся у пользователя данных в новую структуру. Чтобы отловить факт изменения структуры БД, при открытии БД мы указываем версию. Например, в первый месяц после выхода приложения версия БД - 1, а через месяц - 2. Если пользователь начал пользоваться приложением в момент его выхода, то у него будет версия 1. Когда он зайдет в приложение через месяц, то БД будет открываться у него с версией 2.

Факт несовпадения версий мы можем отловить в событии `upgradeneeded`. У объекта события будут два свойства о версиях:

* `oldVersion` - версия, которая у пользователя сейчас.
* `newVersion` - версия, с которой БД пытается открыться в данный момент.

```javascript
const request = indexedDB.open("localdb", 5);

request.onupgradeneeded = (event) => {
  console.log(event.oldVersion);  // <-- Версия БД в данный момент.
  console.log(event.newVersion);  // <-- Версия из текущего запроса на открытие.
  const db = request.result;
}
```

Анализируя текущую версию и новую, мы должны написать соответствующий код переноса данных. Об этом подробнее в отдельном конспекте. TODO: особенно интересно, как написать прыжки через версию, если например у пользователя версия 1, а текущая не 2, а 10.

## Получение объекта БД, свойство .result

У запроса на открытие есть свойство `.result`, в котором после успешного открытия лежит объект БД:

```javascript
const request = indexedDB.open("localdb", 5);

request.onsuccess = (event) => {    
  const db = request.result;  // <-- Получаем объект БД из запроса.
}
```

В объекте события success свойство target содержит ссылку на запрос открытия. Поэтому БД можно было бы получить еще вот так (по сути то же самое):

```javascript
const request = indexedDB.open("localdb", 5);

request.onsuccess = (event) => {    
  const db = event.target.result;  // <-- Обращаемся к запросу через объект события.
}
```

## Ошибки при открытии

> Ошибку при открытии можно спровоцировать, если например при открытии БД указать версию ниже, чем текущая.

Если в запросе на открытие БД происходит ошибка, то она кладется в свойство `.error` запроса на открытие. Это обычный объект исключения, в котором есть поля type и message:

```javascript
const request = indexedDB.open("localdb", 3);

request.onerror = (event) => {
  const err = request.error;  // <-- Получаем ошибку из запроса.
  const err = event.target.error;  // <-- Или через объект события.
  console.log("Ошибка при открытии БД.");
  console.log(err.messge);
}
```

# Проверка существования БД

Современные браузеры поддерживают метод `indexedDB.databases()`. Он возвращает промис, а результатом промиса является массив с именами БД в виде строк. Так что можно проверить наличие нужного имени в этом массиве:

```javascript
window.indexedDB.databases().then(x => {
  const exist = x.map(db => db.name).includes(dbname);
  console.log(exist);
});
```

Можно переписать через await вот так:

```javascript
const exist = (await window.indexedDB.databases())
  .map(db => db.name)
  .includes("idbTest");
```

P.S. Надо помнить, что await можно использовать только внутри async-функции, так что вставить этот фрагмент абы куда не получится.

# Удаление БД

```javascript
const request = window.indexedDB.deleteDatabase("localdb", options);
```

[Документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase). При удалении БД есть несколько моментов:

* Запрос удаления имеет тип IDBOpenDBRequest, т.е. тот же тип, что и запрос на открытие.
* Если попытаться удалить БД, которой не существует, то это не вызовет исключение. Все пройдет так же, как будто БД успешно удалена.
* При успешном удалении возникает событие `success`, а в объекте события в поле .result должен быть undefined.
* При удалении БД все прочие соединения с БД получают событие `versionchange` (TODO: интересно, а я представлял себе работу с idb как шаг за шагом, не параллельную)
* Параметр options пока экспериментальный, о нем написано в документации. Связан с удалением БД из постоянного или временного хранилища. TODO на будущее.

Пример:

```javascript
new Promise((resolve, reject) => {
  const deleteRequest = window.indexedDB.deleteDatabase("localdb");

  deleteRequest.onerror = (event) => {
    console.log("Ошибка при удалении БД.");
    console.log(event);
    reject(event);
  };

  deleteRequest.onsuccess = (event) => {
    console.log("БД удалена успешно.");
    console.log(event.result);
    resolve(event.result);
  }
});
```

TODO: Пока не знаю, как спровоцировать ошибку удаления БД и поэтому не понятно, где будет храниться ошибка удаления. Дописать этот момент, когда реально возникнет ошибка удаления.

# Закрытие БД

Соединение с БД можно закрыть методом `.close()` [Документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/close)

Особенности метода:

* Метод вызывается на объекте БД.
* Метод ничего не возвращает.
* Новые транзакции на закрытой БД стартовать нельзя, будет исключение.
  * Но уже запущенные транзакции доработают. Т.е. close не обрубает соединение моментально.
* TODO: похоже, никаких исключений и прочих обвязок не имеет.

# Объект БД

У объекта БД есть следующие интересные вещи:

* Свойства

  * `name` - имя БД.
  * `version` - версия БД.

* События

  * `versionchange` - возникает, когда изменяется версия БД. TODO: ваш кэш. Написать поподробнее.
  * `abort`
  * `close`
  * `error`

  Если вешать обработчики через addEventListener, то можно использовать эти имена. Если же вешать через свойства, то даем именам префикс on.

# Событие versionchange на БД

У объекта БД есть событие `versionchange`. Оно возникает на объекте БД, при осуществлении попытки открыть БД с повышением версии, когда она уже открыта. Например, мы вызвали open("myDb", 1), а потом open("myDb", 2). Это приведет к возникновению на БД события versionchange.

# Вопросы

* Такое ощущение, что пока БД открыта, такие вещи как удаление, повышение версии как бы не работают. При перезагрузке страницы, пока еще БД не открыта, они работают. Также они работают, если сначала закрыть БД программно.
* Если закрыть БД, потом удалить, а потом запросить инфу, то инфа выводится. Т.е. как будто в переменной, в которую мы сохраняли БД, остается что-то.
  * Возможно, закрытие означает не прямо-таки уничтожение объекта БД, а просто закрытие приема новых транзакций или вреде того.

# Пример

TODO: потом как-нибудь возможно стоит переписать этот пример на более хороший, в котором было бы видно не только получение объекта БД, но и куда его лучше сохранить и как потом с ним работать дальше.

Как и прочие асинхронные операции, открытие БД удобно оборачивать в промис и вызывать в событиях запроса resolve и reject. Пример, как можно дождаться промиса и получить объект БД из него:

```javascript
const dbname = "idbTest";
const dbversion = 1;

async function init() {
  const pdb = new Promise((resolve, reject) => {
    const request = indexedDB.open("localdb", 5);  // <-- Делаем запрос на открытие.

    request.onupgradeneeded = (event) => {
      console.log("БД еще не существует, либо версия увеличилась.");
      const db = request.result;  // <-- Получаем объект БД из запроса.
    }

    request.onsuccess = (event) => {
      console.log("БД открыта успешно!");
      const db = request.result;  // <-- Получаем объект БД из запроса.
      resolve(db);
    }

    request.onerror = (event) => {
      console.log("Ошибка при открытии БД: " + request.error);
      reject(request.error);  // <-- Получаем ошибку из запроса.
    }
  });

  let db;
  try {
    db = await pdb;  // <-- Теперь объект БД лежит в переменной db.
  } catch (err) {
    console.log(err);
  }
}

init();
```

