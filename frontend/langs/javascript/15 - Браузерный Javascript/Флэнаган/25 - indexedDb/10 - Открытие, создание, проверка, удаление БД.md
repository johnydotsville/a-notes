# Типы и общий принцип

| Тип                     | Дока                                                         | Назначение                                                   |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `IDBFactory`            | [IDBFactory](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory) | Интерфейс для организационной работы с базами данных - открыть, удалить, получить список БД-шек. Реализация интерфейса - объект `window.indexedDB` |
| `IDBOpenDBRequest`      | [IDBOpenDBRequest](https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest), [IDBRequest](https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest) | Интерфейс запроса на открытие \ удаление БД. Содержит события, через подписку на которые мы можем обработать момент, когда действие открытия \ удаления завершилось. Объект, реализующий этот интерфейс, нам возвращают методы открытия \ удаления. |
| `IDBDatabase`           | [IDBDatabase](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase) | Интерфейс БД-соединения (connection). На нем мы стартуем транзакции для непосредственной работы с БД (добавление \ удаление данных и т.д.). Объект соединения мы получаем из свойства `.result` запроса на открытие БД. |
| `IDBVersionChangeEvent` | [IDBVersionChangeEvent](https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeEvent) | Тип объекта event в некоторых событиях запроса на открытие \ удаление БД. |

Общая схема работы такая:

* Создаем запрос на открытие БД.
* Вешаем обработчики на его события. 
* В событии успешного открытия извлекаем объект БД из запроса. 
* Работаем с БД.



IDBVersionChangeEvent - тип объекта события в upgradeneeded, в blocked

Event - тип объекта события в success запроса на открытие.

# Пример для демонстрации работы событий

Пример для проверки событий, связанных с открытием \ закрытием БД. В каждом разделе, будь то открытие, закрытие, удаление, описаны особенности поведения при разных сценариях \ комбинациях операций. Этот пример поможет убедиться, что они работают именно так, как написано.

```html
<body>
  <input id="DBVersion" type="text" value="1" placeholder="Версия БД"/>
  <button id="buttonCreateOrOpenDB">Создать \ открыть БД</button>
  <button id="buttonCloseDB">Закрыть БД</button>
  <button id="buttonDeleteDB">Удалить БД</button>
  <button id="buttonShowDBInfo">Информация об открытой БД</button>
</body>
```

```javascript
window.onload = () => {
  let db;
  const connections = [];
  const dbname = "idbtraining";

  const inputDBVersion = document.querySelector("#DBVersion");
  const buttonCreateOrOpenDB = document.querySelector("#buttonCreateOrOpenDB")
  const buttonCloseDB = document.querySelector("#buttonCloseDB");
  const buttonDeleteDB = document.querySelector("#buttonDeleteDB");
  const buttonShowDBInfo = document.querySelector("#buttonShowDBInfo");
  
  buttonCreateOrOpenDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка создания \\ открытия БД.");
    const dbversion = inputDBVersion.value;
    const request = window.indexedDB.open(dbname, dbversion);

    request.onupgradeneeded = (event) => {
      console.log("upgrageneeded событие на запросе открытия.");
    }

    request.onsuccess = (event) => {
      console.log("success событие на запросе открытия.");
      if (db) {
        const isNewDbInstance = (db !== event.target.result);
        console.log("Открытое соединение с БД является новым: " + isNewDbInstance);
      }
      db = event.target.result;
      connections.push(db);
      db.onversionchange = (event) => {
        console.log("versionchange событие на БД.");
      };
    }

    request.onerror = (event) => {
      console.log("error событие на запросе открытия.");
    }

    request.onblocked = (event) => {
      console.log("blocked событие на запросе открытия.");
    }
  });

  buttonCloseDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка закрытия БД.");
    connections.forEach(db => db.close());
  });

  buttonShowDBInfo.addEventListener("click", () => {
    console.log("> > > Нажата кнопка получения информации о БД.");
    console.log("Имя БД: " + db.name);
    console.log("Версия БД: " + db.version);
  });

  buttonDeleteDB.addEventListener("click", () => {
    console.log("> > > Нажата кнопка удаления БД.");
    const request = window.indexedDB.deleteDatabase(dbname);

    request.onsuccess = (event) => {
      console.log("success событие на запросе удаления.");
    }

    request.onerror = (event) => {
      console.log("error событие на запросе удаления.");
    }

    request.onblocked = (event) => {
      console.log("blocked событие на запросе удаления.");
    }
  });
}
```

# Открытие\создание и удаление БД

## Интерфейс IDBOpenDBRequest

Открытие и создание БД выполняются одним и тем же методом - `indexedDB.open(dbName, dbVersion)`, а удаление - методом `indexedDB.deleteDatabase(dbName)`. У этих методов есть общая черта - они возвращают запрос одного типа - `IDBOpenDBRequest`.

У запроса такие полезные свойства:

* `result` - в случае запроса на открытие БД в этом свойстве окажется объект БД. В случае запроса на удаление там будет undefined.

У запроса четыре события:

* Собственные:
  * `onupgradeneeded` - возникает, когда БД открывается впервые или открывается с повышением версии относительно текущей. В случае запроса на удаление, вполне возможно что не тригерится никогда.
  
    Когда срабатывает это событие, то внутри него стартует т.н. `version change transaction`, внутри которой (и только внутри нее) можно создавать хранилища. Есть событие version change у БД, но оно к version change transaction никак не относится. Поэтому, по сути, хранилища можно создавать только в событии upgradeneeded запроса на открытие БД.
  
  * `onblocked` - возникает, когда запрос открытия \ удаления не может завершиться из-за блокирующих факторов. На данный момент я думаю, что такой блокирующий фактор один - то что БД уже открыта.
* Унаследованные от IDBRequest:
  * `onsuccess` - возникает, когда запрос открытия \ удаления успешно завершился.
  * `onerror` - возникает, когда при запросе открытия \ удаления произошла ошибка и запрос упал. От blocked отличается, вероятно, тем что blocked продолжится, когда блокирующие факторы исчезнут, а вот при error запрос именно что падает наглухо.

Целью всех этих событий является сам запрос. Поэтому все эти события получают объект event, у которого в свойстве  `.target` находится объект запроса. Тип event в этих событиях разный, зависит от вида запроса, может быть либо Event, либо IDBVersionChangeEvent. Какой именно тип в каком событии - написано в разделах про открытие \ удаление. А здесь посмотрим, что интересного находится в этих типах.

### Тип IDBVersionChangeEvent

Полезные свойства:

* `newVersion` и `oldVersion` - пара свойств, которые позволяют ориентироваться в версиях в событиях, где это актуально. Например, при запросе на открытие БД можно понять, БД создается впервые или открывается с той же версией или открывается с повышением версии. Про конкретные значения - в конспекте про открытие и удаление.

### Тип Event

В целом ничего особенно интересного не содержит.

* `target` - стандартное свойство всех событий. В данном случае будет содержать объект запроса на открытие \ удаление.



## Запрос на открытие\создание

```javascript
const request = window.indexedDB.open("myIDB", 1);
```

БД создается и открывается одним и тем же методом - `.open()`. Метод - асинхронный. У него два параметра:

* Имя БД.
* Версия БД.

При открытии БД возможны три варианта:

* БД еще не существует.
* БД существует и
  * Запрос открытия с такой же версией как у БД.
  * Запрос открытия с понижающей версией.
  * Запрос открытия с повышающей версией.

Рассмотрим их отдельно.

* БД еще не существует.

  В этом случае она создается и последовательно срабатывают события upgradeneeded и success на запросе. В event в updgradeneed свойство oldVersion будет 0, а newVersion - та, с которой открывают сейчас. Соответственно, если oldVersion 0, это признак создания БД.

* БД существует и версия понижается.

  Это считается ошибкой и срабатывает событие error на запросе.

* БД существует и версия такая же.

  В этом случае срабатывает событие success на запросе и мы получаем экземпляр соединения с БД. Если несколько раз сделать запрос на открытие с одинаковой версией, то каждый раз мы будем получать новое соединение. В том, что оно новое, можно убедиться из примера, нащелкав несколько раз кнопку открытия с одной и той же версией, а потом повысить версию и еще раз щелкнуть открытие. Тогда в консоли появится несколько надписей "versionchange событие на БД". Все потому, что каждый раз при открытии мы вешаем вот такой обработчик на открытую БД:

  ```javascript
  db.onversionchange = (event) => {
    console.log("versionchange событие на БД.");
  };
  ```

  И при изменении версии все соединения получают событие. Соответственно, если бы open возвращал все время одно и то же соединение, то обработчик бы перезаписывался и мы видели бы только одну надпись. А раз надписей несколько, это значит что обработчик навешивается каждый раз на новый экземпляр соединения с БД. Кроме того, в пример добавлена проверка, которая сравнивает предыдущий сохраненный объект БД с вновь полученным из запроса открытия. И эта проверка показывает, что это разные объекты.

  TODO: А что если объект-то новый, а "суть" - одна и та же как-то? Ну то есть как бы оболочка новая, но внутри это все же одно и то же соединение? Как это проверить? Пока не знаю. Возможно, как нибудь при добавлении данных уже. Обдумать этот момент как-нибудь потом, когда лучше стану понимать. P.S. Все-таки соединение наверное новое, потому что если было бы одно и то же, то достаточно было бы через любой объект его закрыть и оно тогда как бы закрылось бы на "всех остальных" объектах.

* БД существует и версия выше.

  Если БД закрыта, то открытие с повышающей версией приводит к событиям upgradeneeded и success на запросе, как и при создании несуществующей БД. Но если БД уже открыта, то запрос на открытие с повышением версии приведет к двум событиям: blocked на запросе открытия и versionchange на объекте БД (или объект*ах*, если вдруг их несколько). Соответственно, если в upgradeneeded в аргументе event oldVersion не 0, то это признак открытия новой версии БД.

### Тип объекта event в событиях запроса открытия

* upgradeneeded - IDBVersionChangeEvent.

  Быстрый совет: если oldVersion 0, значит БД создается с нуля. Если не 0, то значит БД существует и открывается сейчас с новой версией. В этом случае на основе newVersion можно понять, какие миграции надо делать.

* success - Event

* error - Event

* blocked - IDBVersionChangeEvent

### Получение объекта БД, свойство .result

У запроса на открытие есть свойство `.result`, в котором после успешного открытия лежит объект БД:

```javascript
const request = indexedDB.open("localdb", 5);

request.onsuccess = (event) => {    
  const db = request.result;  // <-- Получаем объект БД из запроса.
}
```

В объекте события success свойство target содержит ссылку на запрос открытия. Поэтому БД можно было бы получить еще вот так (по сути то же самое):

```javascript
const request = indexedDB.open("localdb", 5);

request.onsuccess = (event) => {    
  const db = event.target.result;  // <-- Обращаемся к запросу через объект события.
}
```

### Ошибки при открытии

> Ошибку при открытии можно спровоцировать, если например при открытии БД указать версию ниже, чем текущая.

Если в запросе на открытие БД происходит ошибка, то она кладется в свойство `.error` запроса на открытие. Это обычный объект исключения, в котором есть поля type и message:

```javascript
const request = indexedDB.open("localdb", 3);

request.onerror = (event) => {
  const err = request.error;  // <-- Получаем ошибку из запроса.
  const err = event.target.error;  // <-- Или через объект события.
  console.log("Ошибка при открытии БД.");
  console.log(err.messge);
}
```

### Несколько открытых соединений

Открытие нескольких соединений пока видится как ошибка, потому что если эти соединения не собирать в пул, то они легко могут заблокировать остальные операции. Поэтому в данный момент видится, что надо при открытии соединения сохранять его и при попытках открытия смотреть, а нет ли уже открытого. Ну либо действительно как-то в пул их организовывать.

## Запрос на удаление БД

```javascript
const request = window.indexedDB.deleteDatabase("localdb", options);
```

[Документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase). Параметры метода:

* Имя БД.
* Параметр options пока экспериментальный, о нем написано в документации. Связан с удалением БД из постоянного или временного хранилища. TODO на будущее.

При удалении БД возможны такие сценарии:

* При успешном удалении на запросе возникает событие success, а в объекте события в поле .result должен быть undefined.
* Если попытаться удалить БД, которой не существует, то это не вызовет исключение. Все пройдет так же, как будто БД успешно удалена, т.е. на запросе возникает событие success.
* Если в момент запроса удаления БД открыта, то на запросе возникает событие blocked, а на объекте БД - versionchange. БД не удалится, пока не закрыть все соединения. Если их все закрыть, тогда БД удалится и на запросе удаления сработает success.
  * Если БД не открыта, то versionchange не возникает.

### Тип объекта event в событиях запроса удаления

* upgradeneeded - не думаю, что это событие вообще тригерится в случае удаления БД.
* success - IDBVersionChangeEvent.
* error - не встречал, как тригернуть это событие.
* blocked - IDBVersionChangeEvent.

# Версия БД

По мере развития приложения может меняться структура хранения данных. В этом случае нужно писать миграции - код по переносу уже имеющихся у пользователя данных в новую структуру. Чтобы отловить факт изменения структуры БД, при открытии БД мы указываем версию. Например, в первый месяц после выхода приложения версия БД - 1, а через месяц - 2. Если пользователь начал пользоваться приложением в момент его выхода, то у него будет версия 1. Когда он зайдет в приложение через месяц, то БД будет открываться у него с версией 2.

Факт несовпадения версий мы можем отловить в событии `upgradeneeded` запроса открытия и в событии `versionchange` объекта БД. У объекта event в событии будут два свойства о версиях:

* `oldVersion` - версия, которая у пользователя сейчас.
* `newVersion` - версия, с которой БД пытается открыться в данный момент.

```javascript
const request = indexedDB.open("localdb", 5);

request.onupgradeneeded = (event) => {
  console.log(event.oldVersion);  // <-- Версия БД в данный момент.
  console.log(event.newVersion);  // <-- Версия из текущего запроса на открытие.
  const db = request.result;
}
```

```javascript
db.onversionchange = (event) => {
  console.log(event.oldVersion);  // <-- Версия БД в данный момент.
  console.log(event.newVersion);  // <-- Версия из текущего запроса на открытие.
};
```

Анализируя текущую версию и новую, мы должны написать соответствующий код переноса данных. Об этом подробнее в отдельном конспекте (который пока не написан, кек). TODO: особенно интересно, как написать прыжки через версию, если например у пользователя версия 1, а текущая не 2, а 10.

У самого объекта БД версия хранится в свойстве `version`:

```javascript
console.log(db.version);
```

# Проверка существования БД

Современные браузеры поддерживают метод `indexedDB.databases()`. Он возвращает промис, а результатом промиса является массив с именами БД в виде строк. Так что можно проверить наличие нужного имени в этом массиве:

```javascript
window.indexedDB.databases().then(x => {
  const exist = x.map(db => db.name).includes(dbname);
  console.log(exist);
});
```

Можно переписать через await вот так:

```javascript
const exist = (await window.indexedDB.databases())
  .map(db => db.name)
  .includes("idbTest");
```

P.S. Надо помнить, что await можно использовать только внутри async-функции, так что вставить этот фрагмент абы куда не получится.



# Закрытие БД

Соединение с БД можно закрыть методом `.close()` [Документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/close)

Особенности метода:

* Метод вызывается на объекте БД.
* Метод ничего не возвращает.
* Закрытие БД позволяет заблокированным операциям (например, удаление БД, открытие с повышением версии) продолжить работу.
* Новые транзакции на закрытой БД стартовать нельзя, будет исключение.
  * Но уже запущенные транзакции доработают. Т.е. close не обрубает соединение моментально.
* TODO: похоже, никаких исключений и прочих обвязок не имеет.

# Объект БД (объект соединения)

У объекта БД (синоним понятия "объект соединения", connection, тип IDBDatabase) есть следующие интересные вещи:

* Свойства

  * `name` - имя БД.
  * `version` - версия БД.

* События ([документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase#events))

  * `versionchange` - возникает на объекте БД в таких случаях:
    * При осуществлении попытки открыть БД с повышением версии, когда она уже открыта. Например, мы вызвали open("myDb", 1), а потом open("myDb", 2). Это приведет к возникновению на БД события versionchange.
    * При попытке удалить БД, когда она открыта. В этом случае можно отличить удаление от повышение версии тем, что при удалении в поле newVersion объекта события будет null, а не число новой версии.
  * `abort` - TODO
  * `close` - возникает, когда соединение с БД закрывается *неожиданно*.
  * `error`
  
  Если вешать обработчики через addEventListener, то можно использовать эти имена. Если же вешать через свойства, то даем именам префикс on.

# Пример с промисами

TODO: потом как-нибудь возможно стоит переписать этот пример на более хороший, в котором было бы видно не только получение объекта БД, но и куда его лучше сохранить и как потом с ним работать дальше.

Как и прочие асинхронные операции, открытие БД удобно оборачивать в промис и вызывать в событиях запроса resolve и reject. Пример, как можно дождаться промиса и получить объект БД из него:

```javascript
const dbname = "idbTest";
const dbversion = 1;

async function init() {
  const pdb = new Promise((resolve, reject) => {
    const request = indexedDB.open("localdb", 5);  // <-- Делаем запрос на открытие.

    request.onupgradeneeded = (event) => {
      console.log("БД еще не существует, либо версия увеличилась.");
      const db = request.result;  // <-- Получаем объект БД из запроса.
    }

    request.onsuccess = (event) => {
      console.log("БД открыта успешно!");
      const db = request.result;  // <-- Получаем объект БД из запроса.
      resolve(db);
    }

    request.onerror = (event) => {
      console.log("Ошибка при открытии БД: " + request.error);
      reject(request.error);  // <-- Получаем ошибку из запроса.
    }
  });

  let db;
  try {
    db = await pdb;  // <-- Теперь объект БД лежит в переменной db.
  } catch (err) {
    console.log(err);
  }
}

init();
```

