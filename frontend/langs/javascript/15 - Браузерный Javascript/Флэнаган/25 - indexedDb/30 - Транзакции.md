# Типы и общая идея

| Тип              | Документация                                                 | Комментарий                                                  |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `IDBTransaction` | [MDN](https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction) | Любая работа с данными может выполняться только внутри транзакции. |
|                  |                                                              |                                                              |
|                  |                                                              |                                                              |

Любая работа с данными хранилища (не только запись, но и чтение) может выполняться только внутри транзакции. 

# Создание транзакции

Транзакция стартует методом `db.transaction(storage, mode)` на объекте БД ([документация](https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction)). Он возвращает объект транзакции:

```javascript
const tx = db.transaction("myStorage", "readwrite");
```

У метода три параметра:

* Имя хранилища - строковое имя хранилища, которое затрагивает транзакция. Может быть массивом имен, если транзакция задействует несколько хранилищ. Если хочется задействовать сразу все хранилища, то пригодится свойство db.objectStoreNames.
* Режим транзакции:
  * `readonly` - дефолтное значение. В такой транзакции можно только читать данные. Несколько таких транзакций не блокируют друг друга и могут выполняться одновременно. У этой транзакции лучшая производительность, так что если надо только читать, надо использовать именно ее.
  * `readwrite` - в такой тракзакции можно и читать, и писать данные. Эти транзакции блокирующие. Пока такая транзакция выполняется, остальные будут ждать, пока она закончится и только тогда смогут работать.
  * `versionchange` - такой тип транзакции невозможно создать самостоятельно. indexeddb создает такую транзакцию при создании чистой БД, либо при открытии БД с повышением версии.
* options - TODO, не критично вроде.

# Момент начала транзакции

Транзакция стартует сразу как создана, а не когда в ней начинается выполнение запроса.

```javascript
const tx1 = db.transaction("book", "readwrite");  // <-- tx1 начинается уже тут.
const tx2 = db.transaction("book", "readwrite");
const s1 = tx1.objectStore("book");
const s2 = tx2.objectStore("book");
s2.put("200", 1);  // данные, ключ
s1.put("100", 1);
```

Смысл примера в том, что если смотреть последовательность операторов, то можно подумать, что в хранилище под ключом 1 должно сохраниться число 100, т.к. put перезаписывает данные, если такой ключ уже есть. 

Однако сохранится 200, потому что транзакция tx1 начинается уже на строчке 1. Поскольку обе транзакции являются readwrite, т.е. блокирующие, то tx2 будет ждать, пока выполнится tx1. Т.о., команда `s2.put("200", 1);` фактически выполнится после  `s1.put("100", 1);` из-за организации транзакций.

# Состояния транзакции

Транзакция может быть в двух состояниях:

* active
* inactive

Она переключается между этими состояниями в процессе своей работы. Когда ее выполняет ивент-луп, она активна. Когда он выполняет что-то другое, она не активна. Еще она активна в обработчиках success и error запросов, которые выполняются внутри транзакции.

TODO: можно потом подробнее догуглить. Записал это просто чтобы отметить.

# Простой пример транзакции

Базовый пример использования транзакции для сохранения данных в хранилище:

```javascript
const storageName = "myStorage";
const transactionType = "readwrite";
const data = {
  id: 1,
  name: "Tom Sawyer"
}

let tx = db.transaction(storageName, transactionType);  // <-- Стартуем транзакцию.
let storage = tx.objectStore(storageName);  // <-- Получаем хранилище из транзакции.

const saveRequest = storage.add(data);  // <-- Создаем запрос на сохранение данных.

saveRequest.onsuccess = (event) => {  // <-- Обрабатываем успешное сохранение.
  console.log("Данные успешно сохранены.");
};

saveRequest.onerror = (event) => {  // <-- Обрабатываем ошибку сохранения.
  console.log("Ошибка при сохранении данных.")
};
```


