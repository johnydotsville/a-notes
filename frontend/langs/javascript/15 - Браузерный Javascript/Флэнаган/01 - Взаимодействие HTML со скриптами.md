# Скрипты и HTML

Браузеры не выполняют js-код сам по себе. Для этого его нужно подключить в виде скрипта к html-странице. Тогда при загрузке этой страницы браузер выполнит и код.

Для подключения кода к странице используется парный тег `<script></script>`. Есть два способа оформить код с помощью него:

* Написать код непосредственно в теге.
* Указать путь к скрипту через атрибут `src` (такой скрипт называется "внешний"), например:
  *  `<script src='./js-scripts/simplescript.js'></script>`
  * `<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>`

Вариант с указанием через src предподчтительнее, потому что:

* Позволяет использовать один и тот же скрипт на нескольких страницах.
* Позволяет браузеру закешировать скрипт и не загружать его повторно при использовании на других страницах.
* Позволяет использовать скрипты, экспортированные веб-серверами.

# Момент выполнения скриптов

## Историческая справка

Когда браузер загрузил html-страницу, он начинает ее парсить и на ходу формировать DOM-дерево. Момент, когда скрипт начнет выполняться, зависит от следующих вещей:

* Место, где скрипт расположен на странице.
* Наличие атрибутов `async` и `defer` у скрипта.

Технически, скрипт может располагаться в любом месте страницы - хоть перед тегом head, хоть внутри него, хоть в body, хоть после закрывающего html. И браузер, как только встретит тег script, тут же начинает его загружать и выполнять. На время загрузки и выполнения скрипта, соответственно, дальнейший парсинг html-страницы приостанавливается.

Такое поведение вызвано историческими причинами. Когда JS только появился, еще не было развитого API по модификации страницы. Т.е. если браузер уже распарсил страницу и нарисовал, то ничего изменить в ней уже было невозможно. Единственным способом кастомизации было прямо в процессе парсинга что-то вписать в текст страницы с помощью скрипта.

Это делалось методом `document.write();` примерно так:

```html
<body>
  <h1>Момент выполнения скриптов.</h1>
  <script>
    document.write("<p>Внедрились в страницу и нарисовали в ней еще один параграф</p>");
  </script>
  <div>Заключение: ну нифига себе!</div>
</body>
```

В результирующей странице сначала будет идти заголовок `<h1>`, потом параграф `<p>` и в конце `<div>`. Т.о. браузер обязан начать загрузку и выполнение скрипта сразу, как только встретит его в тексте страницы, на случай если там используется такой метод. Потому что если такой скрипт пропустить и выполнить его, например, в конце, тогда получим неправильную последовательность элементов - `<h1>`, `<div>` и только потом `<p>`.

## Отложенное выполнение скрипта, атрибуты defer и async

Если браузер каждый раз будет останавливать парсинг страницы, чтобы загрузить и выполнить скрипт, то страницу мы можем увидеть с очень большой задержкой, поскольку скрипты могут быть большими и их может быть подключено много.

Поскольку единственной причиной такого поведения было использование `document.write()`, а теперь он уже не используется, то во время парсинга страницы и формирования DOM логичнее не прерываться на загрузку и выполнение скриптов, а загружать их параллельно и выполнять уже потом, когда страница готова.

Для этого у тега `<script>` существует два атрибута - `defer` и `async`:

```html
<script defer src="./js/foobar.js"></script>
```

```html
<script async src="./js/foobar.js"></script>
```

Общие особенности этих атрибутов:

* И тот, и другой не блокируют парсинг страницы и построения DOM-дерева. Они загружаются параллельно этому процессу.
* Эти атрибуты работают только для внешних скриптов, т.е. для тех, путь до которых указан в src. Если код написан непосредственно в теле тега `<script>`, то атрибуты defer и async игнорируются и скрипт выполняется мгновенно, блокируя парсинг страницы.
* Если у скрипта стоят оба этих атрибута, то async имеет приоритет.

Отличия атрибутов:

|       | Порядок выполнения                                           | Событие DOMContentLoaded                                     |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| defer | defer-скрипты выполняются в том порядке, в котором идут в тексте страницы. Если скрипт A загрузился быстрее скрипта B, но подключен после него, то он будет ждать, пока загрузится и выполнится B. Это полезно при подключении зависимых скриптов. Например, если один скрипт является библиотекой, а второй скрипт пользуется функциями этой библиотеки, тогда очевидно что он должен дождаться, пока библиотека загрузится и выполнится, и только после этого сможет выполниться сам. | Это событие генерируется только после того как все defer-скрипты загрузятся и выполнятся. Т.е. оно их ждет и только потом возникает. |
| async | async-скрипты выполняются в том порядке, в каком успели загрузиться. Они никого не ждут и их никто не ждет. Поэтому атрибут async подходит для маркировки самостоятельных скриптов, которые ни от кого не зависят и от них тоже никто не зависит. Например, какие-нибудь счетчики посещения. TODO: когда-нибудь вписать побольше примеров. | Это событие и async-скрипты друг от друга не зависят.        |

> Событие `DOMContentLoaded` возникает, когда DOM-дерево полностью построено. Оно хорошо подходит для того, чтобы начать навешивать обработчики на элементы. Однако такие вещи как картинки могут быть еще не загружены.

Приблизительной альтернативой использованию async и defer является размещение тегов `<script>` после закрывающего `</html>`. Тогда когда парсер дойдет до них, DOM-дерево и так уже будет построено.

## Динамическое подключение скрипта

Если не использовать модули, то динамическое подключение скрипта реализуется через программное создание элемента script и добавление его в документ. Под "динамическим" подключением подразумевается, что изначально мы этот скрипт не упоминаем в разметке, а добавляем его уже после того, как разметка отрисовалась. Например, когда пользователь нажал кнопку. Пример реализации:

Пишем какой-нибудь скрипт, который будем подключать динамически, и сохраняем его в отдельный файл, например `helloscript.js`:

```javascript
function message(text) {
  console.log(text);
}
```

Теперь мы хотим подключить этот скрипт к странице, чтобы иметь возможность пользоваться функцией message.

```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>HTML CSS Project</title>
    <link rel="stylesheet" href="css/styles.css">
    <script defer src="js/prog.js"></script>
  </head>
  <body>
    <button onclick="start()">Загрузить скрипт</button>
    <button onclick="message('Hello, script')">Выполнить функцию</button>
  </body>
</html>
```

Здесь у нас к странице подключается базовый скрипт prog.js, который выглядит так:

```javascript
function include(url) {  // <-- Функция загрузки и подключения скрипта к странице.
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.onload = () => resolve();
    script.onerror = (err) => reject(err);
    script.src = url;
    document.head.append(script);
  });
}

async function start() {  // <-- Функция запуска загрузки.
  try {
    // Путь надо указывать от страницы, на которой выполняется текущий скрипт (prog.js)
    await include("js/helloscript.js");
    console.log("Скрипт успешно добавился на страницу.");
  } catch(err) {
    console.log(err.message);
  }
}
```

Теперь, если нажать на первую кнопку, то скрипт загрузится и функция message станет доступна для использования. Если же мы сразу нажмем вторую кнопку, то будет ошибка, что функция message неизвестна.



