План на этот конспект:

* Написать про все методы.
* Почитать получше про Element, NodeList, HTMLCollection.
  * После этого вернуться сюда и поправить неточности, если они есть (например, если вдруг выяснится, что свойство children и прочие - это не свойства элемента, а свойство еще чего-то. Мб это вообще геттер, грубо говоря).



# Дети, потомки, сиблинги

* Дети элемента - это элементы, которые вложены в него *непосредственно*.
* Потомки элемента - это *любые* вложенные в него элементы, т.е. не только дети, но и дети детей и т.д.
* Сиблинги элемента - слово сиблинг означает брата или сестру. Т.е. сиблинг для элемента - это элемент, который находится в разметке *на одном уровне* вложенности с ним. Или можно сказать иначе - "сосед". Просто в свойствах используется слово sibling, поэтому лучше привыкнуть к оригинальному термину.

 Например:

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и <i>велел</i> его сварить.</p>
  <!-- А я отроду не знаю, как хороший чай варить -->
</body>
```

Здесь `h1` и `p` - это дети для `body`. А `i` является ребенком для `p` и потомком для `body`.  `h1`, `p` и комментарий являются сиблингами.

Текстовые элементы тоже являются детьми \ потомками \ сиблингами по такому же принципу. В разметке сверху 4 текстовых элемента, которые легко заметить - "Стихотворение", "Раз прислал мне барин чаю", "велел", "его сварить". И еще 4 текстовых элемента, о которых легко забыть - это текст, состоящий из переноса строки и двух пробелов, который находится после каждого тега. Так вот, забывать о них не надо, они являются полноценными участниками дерева.

Для удобства все свойства для работы с детьми, сиблингами и родителем существуют в двух видах: один учитывает элементы всех типов, а другой вид реагирует только на элементы-теги.

# Дети

## Коллекции детей, .children и .childNodes

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и <i>велел</i> его сварить.</p>
  <!-- А я отроду не знаю, как хороший чай варить -->
</body>
```

### .childNodes, все дети

```javascript
const childNodes = document.body.childNodes;
```

* Свойство элемента `.childNodes` содержит все дочерние элементы всех видов (текст, теги, комментарии и т.д).
* Элементы хранятся в коллекции NodeList.

Для разметки из примера childNodes будет содержать 7 элементов: 2 тега, 1 комментарий и 4 текста. Эти тексты состоят из переноса строки и двух пробелов. Соответственно, первый текст после body, второй после h1, третий после p и четвертый после комментария.

### .children, дети-теги

```javascript
const children = document.body.children;
```

* Свойство элемента `.children` содержит дочерние элементы-теги.
* Элементы хранятся в коллекции HTMLCollection.
* `.childrenElementCount` - свойство содержит количество детей-тегов. То же самое, что `.children.length`.

Для разметки из примера children будет содержать 2 элемента: h1 и p, потому что только они являются тегами.

## Геттеры для детей

### .firstChild, .lastChild

`firstChild`, `lastChild` - первый \ последний ребенок, без ограничений по типу. Для разметки из примера :

```javascript
const bfc = document.body.firstChild;  // text
const blc = document.body.lastChild;   // text
```

### .firstElementChild, .lastElementChild

`firstElementChild`, `lastElementChild` - первый \ последний ребенок-тег. Для разметки из примера:

```javascript
const bfc = document.body.firstElementChild;  // h1
const blc = document.body.lastElementChild;   // p1
```

## Детские методы

### .hasChildNodes()

Метод `.hasChildNodes()` позволяет проверить, есть ли у элемента дети.

```javascript
console.log(document.body.hasChildNodes());  // true
```

# Сиблинги (соседи)

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и <i>велел</i> его сварить.</p>
  <!-- А я отроду не знаю, как хороший чай варить -->
</body>
```

## .nextSibling, .previousSibling

`nextSibling`, `previousSibling` - следующий \ предыдущий сиблинг, без учета типа.

```javascript
const h1 = document.querySelector("h1");
const h1ps = h1.previousSibling;  // text
const h2ps = h1.nextSibling;      // text
```

## .nextElementSibling, .previousElementSibling

`nextElementSibling`, `previousElementSibling` - следующий \ предыдущий сиблинг-тег.

```javascript
const h1 = document.querySelector("h1");
const h1ps = h1.previousElementSibling;  // null
const h2ps = h1.nextElementSibling;      // p
```

# Родитель

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и <i>велел</i> его сварить.</p>
  <!-- А я отроду не знаю, как хороший чай варить -->
</body>
```

## .parentNode и .parentElement

`parentNode`, `parentElement` - родители тоже не избежали деления на обычного родителя и родитель-тег.

```javascript
const h1 = document.querySelector("h1");
const h1pn = h1.parentNode;     // body
const h1pe = h1.parentElement;  // body
```

```javascript
const html = document.documentElement;
const htmlpn = html.parentNode;     // document
const htmlpe = html.parentElement;  // null
console.log(htmlpn === document);   // true
```

Поскольку вкладываются друг в друга обычно теги, а например текст нельзя вложить непосредственно в другой текст, то в большинстве случаев parentNode и parentElement будут содержать одинаковый объект. Но например для html родителем является уже не тег, а сам объект документа, поэтому для html эти свойства отличаются. Это наверное единственное исключение, когда эти два свойства не равны.