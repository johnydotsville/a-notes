# Добавление обработчиков событий

Обработчик события - это функция, которую браузер выполняет при наступлении события. У этой функции единственный параметр - объект события. О том, какие у этого объекта возможности, рассказано в отдельном конспекте.

```javascript
function handler(event) {  // <-- Обработчик - это функция с единственным параметром.
  // Пишем обработчик события. Из объекта event получаем информацию о событии.
}
```

Добавить обработчики событий можно тремя способами:

* Воспользоваться методом `.addEventListener()`. Он есть у любого объекта, с которым могут происходить события (например объекты window, document, а также все объекты элементов).
* Добавить объекту свойство с именем в формате `on` + имя события. Например, для события `click` имя свойства будет `onclick`. Все слова пишутся в нижнем регистре, т.е. например onClick работать не будет.
* Добавить html-тегу атрибут, названный по такому же принципу, как и в предыдущем пункте.

Предпочтительным способом является способ через вызов метода `.addEventListener()`, остальные считаются устаревшими и неэффективными. Они позволяют повесить только один обработчик, а addEventListener() позволяет повесить столько обработчиков, сколько нужно.

Рассмотрим каждый из них, а в качестве основы возьмем такую разметку:

```html
<body id="body">
  <div id="container">
    <button id="knopka">Нажми на кнопку, получишь результат</button>
  </div>
</body>
```

## Обработчик через свойство объекта или атрибут тега

### Обработчик через свойство объекта

Мы находим нужный элемент с помощью api, добавляем ему свойство с именем события (с префиксом `on`) и кладем в него функцию-обработчик:

```javascript
const btn = document.querySelector("#knopka");
btn.onclick = function(event) {  // <-- Синтаксис Function expression
  console.log(`Сработал обработчик нажатия кнопки ${event.target.id}`);
};
```

```javascript
const btn = document.querySelector("#knopka");
btn.onclick = (event) => {  // <-- Синтаксис лямбд
  console.log(`Сработал обработчик нажатия кнопки ${event.target.id}`);
};
```

### Обработчик через атрибут тега

Просто добавляем тегу атрибут с именем события (с префиксом `on`) и пишем код, который надо выполнить:

```html
<button id="knopka" onclick="console.log('Привет, мир!')">Нажми на кнопку</button>
```

Особенность в том, что в обработчик надо писать именно код, который нужно выполнить. Т.е. если оформить код в отдельную функцию, например:

```javascript
function handleKnopkaClick() {
  console.log("Привет, мир! Как дела?");
}
```

То надо будет написать в обработчике *вызов* этой функции, а не просто указать ее имя:

```html
<button id="knopka" onclick="handleKnopkaClick()">Нажми на кнопку</button>  <!-- Ok -->
<button id="knopka" onclick="handleKnopkaClick">Нажми на кнопку</button>    <!-- Не ok -->
```

### Связь между этими способами

Добавление события через свойство объекта и через атрибут тега предполагают добавление только одного обработчика. Если задать сразу обоими способами, это приведет к перезаписи обработчика. Первым добавится обработчик из атрибута тега, согласно модели формирования документа. Соответственно, потом обработчик, задаваемый через свойство, перезапишет его:

```html
<body id="body">
  <div id="container">
    <button id="knopka" onclick="console.log('Меня перезапишут.')">Нажми на кнопку</button>
  </div>
</body>
```

```javascript
const btn = document.querySelector("#knopka");
btn.onclick = () => console.log("Я перезаписал обработчик из атрибута тега.");
// Вывод:
// Я перезаписал обработчик из атрибута тега.
```

## Обработчик через метод .addEventListener()

У любого объекта, с которым могут происходить события, есть метод `.addEventListener()`. [Документация](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). У него три аргумента:

* Имя события - указываем имя события, для которого предназначен обработчик. Например, click, mousemove и т.д. Здесь не нужен префикс on.
* Обработчик - функция, которую нужно выполнить для обработки события.
* Настройки - объект настроек, содержит три boolean-поля. О нем - дальше в отдельном разделе.

```javascript
btn.addEventListener("click", handleKnopkaClick);
```

Особенности этого способа:

* Можно навесить на объект столько обработчиков, сколько нужно.
* Обработчики выполняются в том порядке, в котором мы их навесили.
  * Соответственно, обработчик, заданный через атрибут тега, всегда будет самым первым, потому что он добавляется сразу как из тега создается объект.
* "add"-обработчики не перезапишут обработчики, заданные через атрибут или свойство.
* Если несколько раз добавить один и тот же обработчик, то повторные добавления игнорируются.

```javascript
function handleKnopkaClickFoo(event) {  // <-- Создадим пару обработчиков
  console.log(`Сработал foo-обработчик нажатия кнопки ${this.id}`);
}
const handleKnopkaClickBar = (event) => {
  console.log(`Сработал bar-обработчик нажатия кнопки ${event.target.id}`);
}

const btn = document.querySelector("#knopka");

btn.addEventListener("click", handleKnopkaClickFoo);  // <-- И навесим их на кнопку
btn.onclick = () => console.log("Меня не перезаписали, я тоже работаю!");
btn.addEventListener("click", handleKnopkaClickBar);
btn.addEventListener("click", handleKnopkaClickFoo);  // <-- "Повторка" проигнорируется.
// Вывод
// Сработал foo-обработчик нажатия кнопки knopka
// Меня не перезаписали, я тоже работаю!
// Сработал bar-обработчик нажатия кнопки knopka
```

### Третий параметр, настройки обработчика

[Документация](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options).

```yaml
{  # Звездочкой * показаны дефолтные значения
  capture: true | false*,
  once: true | false*,
  passive: true | false*,
  signal: ??? TODO
}
```

В третий параметр метода `.addEventListener()` мы можем передать:

* Объект с любыми из указанных настроек.
* boolean-значение - в этом случае это true | false будет относиться к параметру capture.

Назначение параметров:

* `capture` - если true, то обработчик будет срабатывать на фазе погружения события. Если false - на фазе всплытия. Про фазы есть отдельный конспект про механику распространения события.
* `once` - если true, то обработчик срабатывает один раз, а затем автоматически удаляется из объекта.
* `passive` - если передаем true, то это знак браузеру, что в обработчике не используется метод preventDefault(), а если даже его написать, то браузер все равно его (preventDefault) не выполнит. TODO: там есть какие-то сценарии, связанные с прокруткой, когда эта настройка важна. Когда реально понадобится, дописать.
* `signal` - ??? TODO

Пример на passive:

```html
<body>
  <form id="info">
    <input type="text">
    <button>Отправить</button>
  </form>
</body>
```

```javascript
const info = document.querySelector("#info");
const settings = { 
  passive: true 
};
info.addEventListener("submit", handleInfoSubmit, settings);

function handleInfoSubmit(event) {
  event.preventDefault();  // <-- Когда есть passive: true, то preventDefault игнорируется
  alert("Отправляем форму.");
}
```

# Анонимные и не-анонимные обработчики

Анонимные обработчики - это обработчики, которые добавлены через лямбду, анонимную функцию или named function expression (NFE):

```javascript
btn.addEventListener("click", () => {
  console.log("Вы меня теперь устанете удалять отсюда.");
});
```

```javascript
btn.addEventListener("click", function() {
  console.log("Я крепко тут обосновался.");
});
```

```javascript
btn.addEventListener("click", function nfe() {
  console.log("NFE вы тоже просто так не удалите.");
});
```

Не-анонимные обработчики - это обработчики, на которые есть ссылка. Например, объявленные как Function definition или функции, сохраненные в переменные:

```javascript
function handleClick(event) {
  console.log("Я не анонимный обработчик, со мной проблем нет.");
}
```

```javascript
const handleClick = (event) => {
  console.log("Я не анонимный обработчик, со мной проблем нет.");
}
```

Предпочтительно использовать именно не-анонимные обработчики, потому что их проще удалять при необходимости.

# Удаление обработчиков событий

## Добавленных через метод .addEventListener()

Если обработчик был добавлен через метод `.addEventListener()`, то удалить его можно методом `.removeEventListener()`. У него три аргумента:

* Имя события (без префикса on), с которого надо удалить обработчик.
* Объект обработчика, который надо удалить.
* `true | false*`  или `{ capture: true | false* }` - необязательный, false по дефолту. Поскольку capture-обработчик и bubble-обработчик (см. конспект про механику распространения событий) это по сути разные обработчики, то требуется указать, какой именно надо удалять. По умолчанию подразумевается удаление bubble-обработчика.

```javascript
btn.removeEventListener("click", handleKnopkaClickFoo);
```

Первые два параметра являются обязательными. Полностью очистить коллекцию обработчиков разом - нельзя, придется удалять по одному. Причем для этого нужен удаляемый объект, т.е. либо идентификатор функции, либо переменная с функцией:

```javascript
function handleKnopkaClickFoo(event) {
  console.log(`Сработал foo-обработчик нажатия кнопки ${this.id}`);
}
const handleKnopkaClickBar = (event) => {
  console.log(`Сработал bar-обработчик нажатия кнопки ${event.target.id}`);
}

const btn = document.querySelector("#knopka");
btn.addEventListener("click", handleKnopkaClickFoo);
btn.addEventListener("click", handleKnopkaClickBar);

// <-- Удаляем обработчики
btn.removeEventListener("click");  // Так не получится, нужен удаляемый объект
btn.removeEventListener("click", handleKnopkaClickFoo);  // <-- Ok
```

## Добавленных через свойство или атрибут

► Если обработчик был добавлен через атрибут тега, то удаляется он через удаление этого атрибута:

```html
<button id="knopka" onclick="handlerKnopkaClick()">Нажми на кнопку, получишь результат</button>
```

```javascript
const btn = document.querySelector("#knopka");
btn.removeAttribute("onclick");  // <-- Удаляем атрибут, и обработчика больше нет.
```

► Если обработчик был добавлен через свойство объекта, то его можно удалить через присвоение этому свойству null или undefined:

```javascript
const btn = document.querySelector("#knopka");
btn.onclick = () => console.log("Я обработчик, заданный через свойство объекта.");
btn.onclick = null;  // <-- Присвоили null, и обработчика больше нет.
```

## Удаление анонимных обработчиков

В случае с добавлением обработчиков через атрибут тега или свойство объекта нам не сильно важно, анонимный был обработчик или нет, потому что удаление делается простым удалением атрибута или записью null в свойство.

Но в случае добавления через .addEventListener(), удалить анонимные обработчики простыми средствами нельзя. Поэтому лучше не использовать анонимные обработчики.

TODO: если когда-нибудь реально будет нужно удалить анонимный обработчик, дописать сюда как это делается.
