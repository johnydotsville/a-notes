# Механика распространения события

## Фазы распространения

Разберем механику возникновения и распространения события на примере щелчка мышью по кнопке на форме, как наиболее наглядный.

Когда происходит щелчок, браузер проводит расчеты, чтобы понять, куда щелкнули. В итоге он понимает, что щелкнули по кнопке. Можно сказать, что кнопка является "конечной точкой", "целью" события. Если бы щелкнули непосредственно по форме, тогда целью бы являлась форма. Браузер создает объект события и в его свойство `target` кладет этот объект-"цель".

Теперь браузер должен доставить этот объект события до цели, что она могла это событие обработать. Это происходит по определенному принципу ("фазы распространения события"):

* Фаза погружения (capturing target phase) - браузер начинает обходить объекты, стартуя с самого верхнего (window) и спускаясь вниз до "цели". Т.е. путь на этой фазе выглядит как "window > document > html > body > ... > цель". Каждый очередной объект браузер кладет в свойство `currentTarget` объекта события (свойство перезаписывается, т.е. в нем всегда только один объект).

  Во время обхода браузер проверяет, нет ли обработчика для этого типа события у текущего объекта. Если есть - он вызывает этот обработчик и передает ему объект события. На этой фазе срабатывают только capture-обработчики, т.е. обработчики, которые были добавлены с флагом `capture: true` (дальше показано подробнее).

* Фаза достижения цели (target phase) - это фаза, когда браузер при обходе добирается непосредственно до элемента, который считается целью события. В нашем примере это кнопка, по которой щелкнули. Тут браузер сначала вызывает capture-, потом bubble-обработчики (если они есть).

* Фаза всплытия (bubbling phase) - браузер начинает обратный путь, вверх, т.е. от цели до window. Снова он кладет очередной объект в currentTarget и проверяет, нет ли у объекта bubble-обработчика для события. Если есть - вызывает его.

Такое поведение вызвано историческими причинами. Когда-то давно браузер Netscape работал по модели capturing. Т.е. браузер вызывал обработчики "сверху вниз". А в Internet Explorer была модель bubbling, когда браузер вызывал обработчики "снизу вверх".

При попытке как-то стандартизировать это поведение сошлись на комбинации того и другого, а для каждого обработчика сделали возможность настроить, на какой фазе он будет срабатывать. По умолчанию обработчики относятся к bubble-фазе. Настроить фазу для обработчика можно при добавлении обработчика через метод `.addEventListener()`, третьим параметром:

* `false` - дефолтное значение, передавать не обязательно. Обработчик срабатывает в bubble-фазе.
* `true` - обработчик срабатывает в capture-фазе.
* `{ capture: true | false }` - поскольку через третий параметр можно выполнять и другие настройки (см. конспект по добавлению обработчиков), то он может быть объектом, а настройка фазы срабатывания задается через поле `capture`.

## Пример

Сделаем кнопку внутри div, развесим оба типа обработчиков на каждый элемент по пути до кнопки и посмотрим, в какой последовательности браузер будет вызывать обработчики:

```html
<body>
  <div id="container" style="background-color: red;">
    <button id="btn">Поехали</button>
  </div>
</body>
```

```javascript
const btn = document.querySelector("#btn");
const container = document.querySelector("#container");

window.addEventListener("click", handleClickCapture, true);
window.addEventListener("click", handleClickBubble);

document.documentElement.addEventListener("click", handleClickCapture, true);
document.documentElement.addEventListener("click", handleClickBubble);

document.body.addEventListener("click", handleClickCapture, true);
document.body.addEventListener("click", handleClickBubble);

container.addEventListener("click", handleClickCapture, true);
container.addEventListener("click", handleClickBubble);

btn.addEventListener("click", handleClickCapture, true);
btn.addEventListener("click", handleClickBubble);

function handleClickBubble(event) {
  console.log(`Всплытие сработало на ${event.currentTarget}`);
}

function handleClickCapture(event) {
  console.log(`Погружение сработало на ${event.currentTarget}`);
}
```

После нажатия на кнопку увидим в консоли следующее:

```javascript
Погружение сработало на [object Window]
Погружение сработало на [object HTMLHtmlElement]
Погружение сработало на [object HTMLBodyElement]
Погружение сработало на [object HTMLDivElement]
Погружение сработало на [object HTMLButtonElement]
Всплытие сработало на [object HTMLButtonElement]
Всплытие сработало на [object HTMLDivElement]
Всплытие сработало на [object HTMLBodyElement]
Всплытие сработало на [object HTMLHtmlElement]
Всплытие сработало на [object Window]
```

А если нажать на сам div, границы которого видны красным, то следующее:

```javascript
Погружение сработало на [object Window]
Погружение сработало на [object HTMLHtmlElement]
Погружение сработало на [object HTMLBodyElement]
Погружение сработало на [object HTMLDivElement]
Всплытие сработало на [object HTMLDivElement]
Всплытие сработало на [object HTMLBodyElement]
Всплытие сработало на [object HTMLHtmlElement]
Всплытие сработало на [object Window]
```

В обоих случаях видно, что браузер начинает обход с самого верха, от window, и спускается до целевого элемента. Т.е. когда щелкаем непосредственно на кнопку, то событие доходит до кнопки. А когда щелкаем на div, то событие доходит только до div. По пути вниз браузер вызывает только capture-обработчики. Достигнув цели, он вызывает оба обработчика. Поднимаясь вверх, браузер вызывает только bubble-обработчики.

# Не всплывающие события

Про события, которые не всплывают, писать здесь как будто нет смысла. Лучше сказать, что какое-то событие не всплывает, непосредственно в конспекте, где показывается как с этим событием работать. Например, не всплывают `focus`, `blur`, `scroll`. Логичнее упомянуть этот факт в конспекте, где они разбираются.

# Делегирование обработки

Тот факт, что событие по пути до цели проходит и все родительские объекты тоже, позволяет нам сосредоточить в родителе логику обработки событий вложенных элементов. Например, у нас есть форма с разными полями ввода и мы хотим сделать валидацию этих полей при их изменении. Вместо того, чтобы вешать обработчик на каждое поле ввода, мы можем повесить его на саму форму и по target-свойству объекта события понимать, какое именно поле изменилось:

```html
<body>
  <form id="info">
    <input id="name"  type="text" placeholder="Введите имя"/>
    <input id="email" type="text" placeholder="Введите почту"/>
    <button type="button">Отправить</button>
  </form>
</body>
```

```javascript
const info = document.querySelector("#info");
info.addEventListener("change", handleChange);

function handleChange(event) {
  if (event.target.id === "name") {
    console.log("Делаем валидацию имени.");
  } else if (event.target.id === "email") {
    console.log("Делаем валидацию почты.");
  }
}
```

