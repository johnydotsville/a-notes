

# Установка и получение прототипа

## Свойства `[[Prototype]]` и `__proto__`:

У объектов есть служебное свойство `[[Prototype]]`, которое хранит ссылку на прототип объекта. При попытке прочитать свойство, которого нет у объекта, он пытается найти это свойство в своем прототипе. Если нет в прототипе, то в прототипе прототипа и т.д.

Свойство `__proto__` является геттером \ сеттером для `[[Prototype]]`:

```javascript
let vehicle = {
  moves: true,
  foobar() {
    console.log("Метод vehicle.foobar");
  }
};

let car = {
  wheels: true,
  __proto__: vehicle
};

console.log(car.moves);   // true
console.log(car.wheels);  // true
car.foobar();  // Метод vehicle.foobar
console.log(car.__proto__);  // Так можно обратиться.
console.log(car[[Prototype]]); // А так не получится.
```

## Специальные методы установки \ получения прототипа

```javascript
Object.setPrototypeOf(obj, prototype);
Object.getPrototypeOf(obj);
```

# Особенности прототипов

С прототипами есть некоторые особенности:

* Прототипы не могут образовывать циклическую ссылку, т.е. например A > B > C > A.

* В качестве прототипа можно задать null или объект, другие типы - нельзя.

* Прототип может быть установлен только один.

* Прототип используется только для *получения* свойств \ методов. Это значит, что если попытаться *прочитать* свойство \ обратиться к методу, которых нет у объекта, то будет поиск этого свойства \ метода в прототипе. А вот если попытаться *записать \ удалить* свойство или метод, которых нет у объекта, то прототип тут не затрагивается и запись \ удаление будут производиться на самом объекте.

  ```javascript
  let device = {
    type: "not set"
  };
  
  let mouse = {
    __proto__: device
  };
  
  console.log(device.type);  // not set
  // У мышки нет свойства type, поэтому при чтении оно берется из прототипа:
  console.log(mouse.type);   // not set
  
  // При попытке записи в отсутствующее у объекта свойство прототип не затрагивается:
  mouse.type = "wired";  // Мышке добавится собственное свойство type
  
  console.log(device.type);  // not set  // Прототип не изменился
  console.log(mouse.type);   // wired  // У мышки теперь есть свое свойство type, его и видим
  ```

# Прототипы и this

Прототипы не влияют на правила вычисления this. Это значит например, что если объект вызывает метод прототипа, в котором есть this, то этот this будет указывать не на прототип, а на вызывающий объект. Т.е. получается стандартное поведение - this в методе указывает на объект, который вызвал метод. Рассмотрим пример с геттером и сеттером, которые тоже являются методами:

```javascript
let device = {
  _connected: false,
  get connected() {
    return this._connected;
  },
  set connected(value) {
    this._connected = value;
  }
};

let mouse = {  // У мышки нет ни своих свойств, ни методов.
  __proto__: device
};

// Мышка берет значение свойства _connected из прототипа.
console.log(device._connected);  // false

// Хотя сеттер берется из прототипа, но this в нем указывает на коллера, т.е. на мышку
mouse.connected = true;  // Поэтому мышке добавится собственное свойство _connected

console.log(device._connected);  // false  // Свойство прототипа не затронулось.
console.log(mouse._connected);   // true  // А у мышки теперь свое свойство _connected.
```



