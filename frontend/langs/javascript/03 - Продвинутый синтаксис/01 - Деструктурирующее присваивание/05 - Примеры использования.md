В предыдущих конспектах было подробно рассказано про деструктуризацию с примерами для наглядности. А здесь я собрал примеры, которые наиболее часто используются в реальности, т.е. это не просто синтетика, а более приближенные к практике примеры.

# Свап переменных

Деструктурирующее присваивание позволяет поменять местами значение переменных:

```javascript
let apple = "Яблоко";
let pear = "Груша";
//    1              2
[apple, pear] = [pear, apple];

console.log(apple);  // Груша
console.log(pear);   // Яблоко
```

Конструкцией `2` мы создаем из исходных переменных массив, на первое место попадает груша, на второе - яблоко. А потом выполняем деструктурирующее присваивание, в результате чего в переменную apple попадает значение первого элемента массива (Груша), а в переменную pear - значение второго (Яблоко).

Такой обмен переменными работает примерно в два раза медленне, чем обмен через промежуточную переменную. Зато он компактнее. Поэтому в случаях, когда не нужна супероптимизация, можно свапать через деструктуризацию.

# Извлечение отдельных свойств объекта

Используется на каждом шагу в React, когда из пропсов извлекаются нужные свойства:

```react
const user = { name: 'Alice', age: 25, email: 'alice@example.com' };

function UserCard({ name, age }) {
  return <div>{name}, {age}</div>;
}
```

# Вложенная деструктуризация

Может пригодиться, когда от сервера приходит сложный объект со множеством полей, а нам нужны только некоторые из них:

```javascript
const response = {
  data: {
    user: {
      id: 1,
      profile: { firstName: 'John', lastName: 'Doe' }
    }
  },
  status: 200
};

// Извлекаем firstName и status:
const { 
  data: { 
    user: { 
      profile: { firstName } 
    } 
  }, 
  status 
} = response;

console.log(firstName, status); // John 200
```

# Извлечение нескольких значений из массива

Обычно это полезно не для обычных массивов, в которых лежат какие-то данные, а для массивов, где лежит что-то специфичное.

Например, хук useState в React возвращает массив из двух элементов. В первом элементе лежит сохраненное значение, а во втором - функция для его изменения:

```react
function Counter() {
  const [count, setCount] = React.useState(0);
	return (
    <div>Значение счетчика: {count}</div>
  )
}
```

Или например метод Object.entries(myObj) тоже возвращает поля объекта в виде массива, где первый элемент - это имя поля, а второй - это значение поля. Деструктуризация позволяет нам легко получить имена полей и значения при их обходе:

```javascript
const obj = { a: 1, b: 2 };

for (const [key, value] of Object.entries(obj)) {
  console.log(`key: ${key}, value: ${value}`);
}
```

# Указание значений по умолчанию

Можно использовать как замену проверкам на заполненность полей объекта:

```javascript
// Раньше:
function greet(user) {
  const name = user.name || 'Guest';
  const age = user.age || 30;
  console.log(`Hello, ${name}! You are ${age}.`);
}

// С деструктуризацией:
function greet({ name = 'Guest', age = 30 }) {
  console.log(`Hello, ${name}! You are ${age}.`);
}

greet({ name: 'Alice' }); // Hello, Alice! You are 30.
```

# Пропуск значений

Возможность пропускать значения может быть полезной, когда опять же, в массиве лежат не просто случайные данные, а данные с какой-то структурой. Например, дата, полученная разбиением строки:

```javascript
const someDate = "2025-04-28";

const [, month, day] = someDate.split("-");
console.log(month);  // 04
console.log(day);    // 28
```

