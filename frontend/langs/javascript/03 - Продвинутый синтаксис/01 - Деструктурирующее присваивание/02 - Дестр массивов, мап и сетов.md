# Деструктурирующее присваивание

Деструктурирующее присваивание - это инструмент для извлечения данных из массивов, объектов, строк и т.д. Несмотря на название, с оригинальным массивом или объектом ничего не происходит.

То, что находится слева, называется *шаблон деструктуризации*, а справа находится разбиваемый объект.

# Как запомнить синтаксис

Массив объявляется с помощью квадратных скобок `[ ]`. Мапу и сет тоже можно назвать условно "массивом значений". Поэтому:

* Массив, и мапа, и сет деструктурируются с помощью квадратных скобок `[ ]`. 
* Данные, для которых не хватило переменных, собираются в *массив* (при использовании оператора `...`)

# Базовый синтаксис

Через квадратные скобки `[]` объявляем несколько переменных, а справа указываем любой перебираемый объект, например, массив, мапа, сет, строка и т.д.

## Для массива

```javascript
let arr = ["Яблоко", "Груша"];
let [item1, item2] = arr;

console.log(item1);  // Яблоко
console.log(item2);  // Груша
```

```javascript
let [item1, item2] = "Яблоко и Груша".split(" и ");

console.log(item1);  // Яблоко
console.log(item2);  // Груша
```

# Пропуск элементов

С помощью запятых указываем "пропуски" среди переменных, в которые кладутся значения. Для массивов, мап и сетов работает одинаково:

```javascript
let arr = ["Яблоко", "Груша", "Апельсин"];

let [apple, , orange] = arr;

console.log(apple);   // Яблоко
console.log(orange);  // Апельсин
```

# Откуда куда

В качестве "откуда" может быть любой перебираемый объект, а в качестве "куда" - переменная или свойство объекта:

```javascript
let strings = new Set(["Johny", "Dotsville", "Javascript"]);

let user = {};
[user.name, user.surname] = strings;

console.log(user);  // {name: 'Johny', surname: 'Dotsville'}
```

Этот факт может, например, упростить перебор мапы или свойств объекта:

```javascript
let user = {
  name: "Tom",
  surname: "Sawyer",
  age: 14,
  state: "Missouri"
};

for (let [prop, value] of Object.entries(user)) {
  console.log(prop + ": " + value);
}
```

```javascript
let users = new Map([
  ["tom", 6000],
  ["huck", 6000],
  ["jim", 40]
]);

for (let [k, v] of users) {
  console.log(k + " " + v);
}
```

# Деструктуризация в заранее объявленные переменные

В деструктуризации можно использовать заранее объявленные переменные:

```javascript
let item1, item2;
let arr = ["Яблоко", "Груша"];
[item1, item2] = arr;

console.log(item1);  // Яблоко
console.log(item2);  // Груша
```

# Мапы и сеты

## Для мапы

Мапа - это "массив записей", поэтому деструктурируя этот "массив", можно получить отдельные записи:

```javascript
let users = new Map([
    ["tom", { name: "Tom", age: 14 }],
    ["huck", { name: "Huck", age: 15 }]
  ]);

let [tom, huck] = users;
console.log(tom);  // Array [ "tom", {…} ]
console.log(tom[0]);  // tom
console.log(tom[1].name);  // Tom
console.log(tom[1].age);   // 14
```

Можно делать вложенную деструктуризацию:

```javascript
let users = new Map([
    ["tom", { name: "Tom", age: 14 }],
    ["huck", { name: "Huck", age: 15 }]
  ]);

let [[key, {name, age}]] = users;
console.log(key);   // tom
console.log(name);  // Tom
console.log(age);   // 14
```

Здесь внешняя деструктуризация `[ ]` деструктурирует саму мапу, вложенная `[ [] ]` деструктурирует первую запись, а еще одна вложенная -  `{ }`  уже деструктурирует объект, который сохранен под ключом.

Сама по себе деструктуризация мапы вряд ли будет сильно полезна. Но деструктуризация может пригодиться при переборе записей мапы, когда надо получить ключ и значение:

```javascript
let users = new Map([
  ["tom", 6000],
  ["huck", 6000],
  ["jim", 40]
]);

for (let [k, v] of users) {
  console.log(k + " " + v);
}
```

## Для сета

```javascript
let users = new Set(["Tom Sawyer", "Huck Finn"]);

let [tom, huck] = users;
console.log(tom);   // Tom Sawyer
console.log(huck);  // Huck Finn
```
