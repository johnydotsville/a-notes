# Как запомнить синтаксис

Объект объявляется с помощью фигурных скобок `{ }`. Поэтому:

* Объекты деструктурируются с помощью фигурных скобок `{ }`
* Свойства, для которых не хватило переменных, собираются в *объект* (при использовании оператора `...`)

# Базовый синтаксис

Используются фигурные скобки:

```javascript
let { a, b, c } = obj;
```

# Сопоставление свойств и переменных

## Автоматическое

Если переменные называются так же, как и свойства объекта, то сопоставление произойдет автоматически:

```javascript
let user = {
  name: "Tom",
  age: 14,
  state: "Missouri"
};

let {state, age, name} = user;  // Порядок не важен, главное совпадение имен

console.log(name);   // Tom
console.log(age);    // 14
console.log(state);  // Missouri
```

## Явное сопоставление переменных и свойств

Можно явно указать, какие свойства в какие переменные надо положить. Формат `{ свойство: переменная }`, "откуда-куда". Можно также задавать значения по умолчанию для переменных, если вдруг указанного свойства в объекте нет:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {
  state: s,  // <-- Значение св-ва state положить в переменную s
  age: a,    // <-- Значение св-ва age положить в переменную a
  name,      // <-- Значение св-ва name положить в переменную name
  address: adr = "homeless"  // <-- Значение по умолчанию
} = user;

console.log(name);  // Huck
console.log(a);     // 15
console.log(s);     // Illinois
console.log(adr);   // homeless
```

# Пропуск свойств

Не обязательно брать значения всех свойств, можно взять только то, что нужно:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state} = user;  // <-- Берем только state, остальные св-ва игнорируем

console.log(state);  // Illinois
```

# Использование заранее объявленных переменных

Если при деструктуризации объекта используются переменные, которые объявлены заранее, то нужно их дополнительно обернуть в круглые скобки:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let name, age, state;  // <-- Переменные объявлены заранее

({name, age, state} = user);  // <-- Берем дополнительно в круглые скобки ()

console.log(name, age, state);
```

Дело в том, что когда движок видит самостоятельную конструкцию, начинающуюся к фигурной скобки `{`, он думает, что это объявляется блок видимости, а дальше, соответственно, с точки зрения синтаксиса идет какая-то чушь. Когда мы берем это в круглые скобки, он уже не расценивает выражение как блок видимости и все работает как надо.

При деструктуризации массивов, мап и сетов в заранее объявленные переменные дополнительные скобки не нужны:

```javascript
let arr = ["Яблоко", "Груша", "Апельсин"];

let apple, orange;
[apple, , orange] = arr;

console.log(apple);   // Яблоко
console.log(orange);  // Апельсин
```

# Свап значений свойств

```javascript
({ firstname: user.lastname, lastname: user.firstname } = user);
```

Круглые скобки нужны, чтобы движок не воспринимал фигурные скобки как блок кода. Дальше принцип как в ручном указании переменных. Только мы исходные свойства извлекаем не в переменные, а в свойства этого же объекта. За счет этого происходит обмен.

Работает за счет того, что при деструктуризации все свойства сначала читаются из объекта разом. Т.о., при перезаписи свойства firstname мы не рискуем потерять исходное значение, потому что оно уже считано и запомнено.

# Вложенная деструктуризация

Если исходный объект имеет сложную структуру, например со вложенными объектами и массивами, его все еще можно разбить на отдельные переменные:

```javascript
let settings = {  // <-- Сложный объект, который мы будем разбивать на переменные
  size: [1920, 1080],
  title: "Мост в Терабитию",
  info: {
    year: 2007,
    duration: 93,
    country: "США"
  }
};

let {  // <-- Начинаем деструктуризацию
  size: [x, y],  // <-- size указывает поле разбиваемого объекта, а x,y - куда класть значения
  title,   // <-- автоматическое сопоставление переменной с полем по имени
  info: {  // <-- info указывает поле разбиваемого объекта
    year: g,  // <-- Поле year из этого объекта положим в переменную g
    duration: d,
    country
  }
} = settings;

console.log(x);  // 1920, данные лежат в x, а не size.x
console.log(y);  // 1080
console.log(title);  // Мост в Терабитию
console.log(g);  // 2007
console.log(d);  // 93
console.log(country);  // США
```

Главное, о чем надо помнить, чтобы понять как это работает: при деструктурирующем присваивании мы должны добраться до "минимальных" частичек контейнера (в массиве это элементы, а в объекте - свойства). Пока до них добираемся, должны указывать путь. В примере выше, свойство title - уже минимальная частичка, поэтому она разобьется. А вот info - не минимальная, это составной объект. Поэтому для него снова применяем синтаксис деструктуризации. size - тоже не минимальная, поэтому и для нее снова применяем деструктуризацию.

