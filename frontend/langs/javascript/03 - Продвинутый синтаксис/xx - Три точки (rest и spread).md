# Оператор ...

Оператор "три точки" `...` это оператор, который движок может интерпретировать двумя способами, в зависимости от контекста, в котором оператор использован:

* `spread` - в местах, где надо *передать* значение. Например, создание массивов, объектов.
* `rest` - в местах, где надо *принять* значение. Например, параметры функций, деструктурирующее присваивание.

# ... как spread

Оператор `...` трактуется как spread в местах, где надо *передать* значение.

Например, при создании массива мы должны *передать* значения:

```javascript
const source = [5, 4, 7, 8, 3, 2];
const dest = [...source];  // <-- Тут ожидается "передача"

console.log(dest);  // [5, 4, 7, 8, 3, 2]
```

Или при создании объекта мы должны указать свойства:

```javascript
const source = {
  firstname: "Tom",
  lastname: "Sawyer"
}
const dest = { 
  ...source  // <-- Тут тоже ожидается "передача"
};

console.log(dest);  // { firstname: 'Tom', lastname: 'Sawyer' }
```

## Как запомнить

`spread` - это "распаковка", "разбиение", "раздербанивание". Как будто взять сумку с продуктами, вытащить из нее все вещи и положить их в холодильник. Причем предполагается что извлеченные вещи тут же кладутся куда-то еще, а не зависают в воздухе. Т.е. нельзя подвесить в воздухе конструкцию `...arr`, ее нужно указать в каком-то контексте, который ожидает набор значений.

# ... как rest

Оператор `...` трактуется как rest в местах, где надо *принять* значение.

Например, описывая параметры функции, мы *принимаем* значения:

```javascript
function hello(firstname, lastname, ...rest) {
  console.log("Имя: " + firstname + " " + lastname);
  console.log("Прозвища:");
  rest.forEach(v => console.log(v));
}
// firstname, lastname |      попадут в массив rest
hello("Джеки", "Чан",    "Громобой", "Азиатский ястреб", "Ковбой", "Тайфун");

// Имя: Джеки Чан
// Прозвища:
//    Громобой
//    Азиатский ястреб
//    Ковбой
//    Тайфун
```

Или при дестуктурирующем присваивании мы тоже ожидаем *принять* значение для переменной:

```javascript
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин"];
let [apple, pear, ...other] = fruits;

other.forEach(f => console.log(f));  // Апельсин, Мандарин
```

В обоих примерах один принцип - все значения, для которых не хватило параметров \ переменных собираются в `массив` (настоящий массив, а не псевдомассив).

## Как запомнить

`rest` - это "сбор остатков". Как будто вы пообещали своим детям по 5 конфет, купили большой пакет, раздали по 5 каждому, а оставшиеся конфеты высыпали в общую тарелку. Важно, что вы сделали это уже после того как всем детям достались конфеты, т.е. rest оператор всегда используется в конце списка параметров \ переменных.

# Типичные сценарии использования

## Произвольное количество параметров

Например, хотим сделать функцию сложения произвольного количества чисел:

```javascript
function sum(...numbers) {
  return numbers.reduce((acc, cur) => acc += cur, 0);
}

console.log(sum(1, 3));  // 4
console.log(sum(1, 3, 8, 14, 7, 5));  // 38
```

Или хотим принять сообщение и произвольное количество тегов для этого сообщения:

```javascript

```



## Обертки над функциями

Например, надо сделать обертку для функции и эта обертка должна суметь принять все те же аргументы, что и оригинальная функция:

```javascript
function foobar(foo, bar) {
  const message = foo + " " + bar;
  return message;
}

function wrap(fn) {
  return function(...args) {  // <-- rest
    console.log("Какая-то добавленная функциональность.");
    return fn.apply(this, args);
  }
}

console.log(foobar("Hello", "world"));
const wrapped = wrap(foobar);
console.log(wrapped("Hello", "world"));
```

Обертка, логирующая вызовы функции и ее аргументы:

```javascript
const withLogging = (fn) => (...args) => {
  console.log(`Вызвана ${fn.name} с аргументами:`, args);
  return fn(...args);
};
```

TODO: сделать остальные примеры