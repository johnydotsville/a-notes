# Деструктурирующее присваивание

Деструктурирующее присваивание - это синтаксис, который позволяет заполнить сразу несколько переменных значениями, взятыми из массива и объекта. Несмотря на название, с оригинальным массивом или объектом ничего не происходит.

То, что находится слева, называется *шаблон деструктуризации*, а справа находится разбиваемый объект.

Пара мнемотехник, чтобы легче запомнить синтаксис:

* Массив объявляется с помощью квадратных скобок. Мапу и сет тоже можно назвать условно "массивом значений". Поэтому и массив, и мапа, и сет деструктурируются с помощью `[ ]`, а данные, для которых не хватило переменных, собираются в *массив* (при использовании оператора `...`)
* Объект объявляется с помощью фигурных скобок. Поэтому объекты деструктурируются с помощью `{ }`, а свойства, для которых не хватило переменных, собираются в *объект* (при использовании оператора `...`)

# Синтаксис

## Для массивов, мап, сетов

### Базовый

Через квадратные скобки `[]` объявляем несколько переменных, а справа указываем любой перебираемый объект, например, массив, мапа, сет, строка и т.д.

► Для массива:

```javascript
let arr = ["Яблоко", "Груша"];
let [item1, item2] = arr;

console.log(item1);  // Яблоко
console.log(item2);  // Груша
```

```javascript
let [item1, item2] = "Яблоко и Груша".split(" и ");

console.log(item1);  // Яблоко
console.log(item2);  // Груша
```

► Для мапы:

```javascript
let users = new Map([
    ["tom", { name: "Tom", age: 14 }],
    ["huck", { name: "Huck", age: 15 }]
  ]);

let [tom, huck] = users;
console.log(tom);  // Array [ "tom", {…} ]
console.log(tom[0]);  // tom
console.log(tom[1].name);  // Tom
console.log(tom[1].age);   // 14
```

► Для сета:

```javascript
let users = new Set(["Tom Sawyer", "Huck Finn"]);

let [tom, huck] = users;
console.log(tom);   // Tom Sawyer
console.log(huck);  // Huck Finn
```

### Пропуск элементов

С помощью запятых указываем "пропуски" среди переменных, в которые кладутся значения:

```javascript
let arr = ["Яблоко", "Груша", "Апельсин"];

let [apple, , orange] = arr;

console.log(apple);   // Яблоко
console.log(orange);  // Апельсин
```

## Откуда куда

В качестве "откуда" может быть любой перебираемый объект, да и в качестве "куда" тоже:

```javascript
let strings = new Set(["Johny", "Dotsville", "Javascript"]);

let user = {};
[user.name, user.surname] = strings;

console.log(user);  // {name: 'Johny', surname: 'Dotsville'}
```

Этот факт может, например, упростить перебор мапы или свойств объекта:

```javascript
let user = {
  name: "Tom",
  surname: "Sawyer",
  age: 14,
  state: "Missouri"
};

for (let [prop, value] of Object.entries(user)) {
  console.log(prop + ": " + value);
}
```

```javascript
let users = new Map([
  ["tom", 6000],
  ["huck", 6000],
  ["jim", 40]
]);

for (let [k, v] of users) {
  console.log(k + " " + v);
}
```

## Для объекта

Используются фигурные скобки:

```javascript
let { a, b, c } = obj;
```

### Имена переменных и свойств одинаковые

Если переменные называются так же, как и свойства объекта, то сопоставление произойдет автоматически:

```javascript
let user = {
  name: "Tom",
  age: 14,
  state: "Missouri"
};

let {state, age, name} = user;  // Порядок не важен, главное совпадение имен

console.log(name);   // Tom
console.log(age);    // 14
console.log(state);  // Missouri
```

### Явное сопоставление переменных и свойств

Можно явно указать, какие свойства в какие переменные надо положить. Формат `{ свойство-откуда: переменная-куда }`. Можно также задавать значения по умолчанию для переменных, если вдруг указанного свойства в объекте нет:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state: s,  // <-- Значение св-ва state положить в переменную s
     age: a,    // <-- Значение св-ва age положить в переменную a
     name,      // <-- Значение св-ва name положить в переменную name
     address: adr = "homeless"  // <-- Значение по умолчанию
    } = user;

console.log(name);  // Huck
console.log(a);     // 15
console.log(s);     // Illinois
console.log(adr);   // homeless
```

### Пропуск свойств

Не обязательно брать значения всех свойств, можно взять только то, что нужно:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state} = user;  // <-- Берем только state, остальные св-ва игнорируем

console.log(state);  // Illinois
```

### Использование заранее объявленных переменных

Если при деструктуризации объекта используются переменные, которые объявлены заранее, то нужно их дополнительно обернуть в круглые скобки:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let name, age, state;  // <-- Переменные объявлены заранее

({name, age, state}) = user;  // <-- Берем дополнительно в круглые скобки ()
```

Дело в том, что когда движок видит самостоятельную конструкцию, начинающуюся к фигурной скобки `{`, он думает, что это объявляется блок видимости, а дальше, соответственно, с точки зрения синтаксиса идет какая-то чушь. Когда мы берем это в круглые скобки, он уже не расценивает выражение как блок видимости и все работает как надо.

# Вложенная деструктуризация

Если исходный объект имеет сложную структуру, например со вложенными объектами и массивами, его все еще можно разбить на отдельные переменные:

```javascript
let settings = {  // <-- Сложный объект, который мы будем разбивать на переменные
  size: [1920, 1080],
  title: "Мост в Терабитию",
  info: {
    year: 2007,
    duration: 93,
    country: "США"
  }
};

let {  // <-- Начинаем деструктуризацию
  size: [x, y],  // <-- size указывает поле разбиваемого объекта, а x,y - куда класть значения
  title,   // <-- автоматическое сопоставление переменной с полем по имени
  info: {  // <-- info указывает поле разбиваемого объекта
    year: g,  // <-- Поле year из этого объекта положим в переменную g
    duration: d,
    country
  }
} = settings;

console.log(x);  // 1920, данные лежат в x, а не size.x
console.log(y);  // 1080
console.log(title);  // Мост в Терабитию
console.log(g);  // 2007
console.log(d);  // 93
console.log(country);  // США
```

# Значения по умолчанию

## undefined

Когда в массиве не хватает значений, чтобы заполнить переменные, они становятся undefined:

```javascript
let fruits = [];
let [apple, pear] = fruits;

console.log(apple);  // undefined
console.log(pear);   // undefined
```

То же самое происходит, когда в объекте нет нужных свойств:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {address, education} = user;

console.log(address);    // undefined
console.log(education);  // undefined
```

Особенно неприятно становится, когда объект сложный и имеет вложенный объект, тогда скрипт падает с ошибкой, потому что при деструктуризации идет попытка получить значение свойства на undefined и такого движок уже стерпеть не может.

Чтобы избежать undefined, можно этим переменным задавать значения по умолчанию. Это могут быть не только литералы, но и любые выражения, вызовы функций и т.д.

## Для массива

Литералы:

```javascript
let fruits = [];
let [apple = "Яблоко", pear = "Груша"] = fruits;

console.log(apple);  // Яблоко
console.log(pear);   // Груша
```

Вызовы функции:

```javascript
let fruits = ["Яблоко"];
let [fruit1 = prompt("Какой первый фрукт?"), 
     fruit2 = prompt("Какой второй фрукт?")
    ] = fruits;

console.log(fruit1);  // Яблоко
console.log(fruit2);  // То, что введено в prompt
```

## Для объекта

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state: s,
     age: a,
     name = "empty",  // <-- Автоматическое сопоставление св-ва, +значение по умолчанию.
     address: addr = "Отсутствует" // <-- Явное сопоставление св-ва, +значение по умолчанию.
    } = user;

console.log(name);  // Huck
console.log(a);     // 15
console.log(addr);  // Отсутствует
console.log(s);     // Illinois
```

Как видно, значение по умолчанию можно комбинировать с синтаксисом явного сопоставления свойства с переменной, так и с автоматическим.

### Для сложного объекта

Под сложным здесь имеется ввиду объект, поля которого являются массивом или объектом:

```javascript
let settings = {  // <-- Сложный объект
  title: "Умные параметры",
  size: [400, 200],  // <-- У него поле является массивом
  info: {  // <-- И объектом
    year: 2007,
    duration: 93
  },
  items: ["Привет", "мир"]
};

foobar(settings);  // Все поля заполнены

foobar(); // Не будет ошибок


function foobar({title: tit = "Заголовок", 
                 size: [width = 300, height = 200] = [],  // = [] важно
                 info: {year = null, duration = null} = {},  // = {} важно
                 items = []} = {}) {
  console.log(tit);
  console.log(width + " " + height);
  console.log(year);
  console.log(duration);
  for (let i of items) {
    console.log(i);
  }
}
```

Здесь есть нюанс - если в настройках будет отсутствовать свойство info, то получим ошибку "Cannot read properties of undefined (reading 'year')", потому что при деструктуризации будет попытка обратиться к info.year, т.е. по сути к undefined.year. Аналогично, если не будет передано size. Поэтому мы защищаемся от этих ситуаций, указывая в шаблоне деструктуризации для size и info значения по умолчанию в виде `[]` и `{}` соответственно.

# Трюк со свапом переменных

Деструктурирующее присваивание позволяет поменять местами значение переменных:

```javascript
let apple = "Яблоко";
let pear = "Груша";
//    1              2
[apple, pear] = [pear, apple];

console.log(apple);  // Груша
console.log(pear);   // Яблоко
```

Конструкцией `2` мы создаем из исходных переменных массив, на первое место попадает груша, на второе - яблоко. А потом выполняем деструктурирующее присваивание, в результате чего в переменную apple попадает значение первого элемента массива (Груша), а в переменную pear - значение второго (Яблоко).

