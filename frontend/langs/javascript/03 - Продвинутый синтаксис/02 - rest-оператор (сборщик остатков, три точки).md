# rest-оператор

rest-оператор - это оператор, который выглядит как три точки `...`

Общими словами его можно описать как "сборщик остатков". Остатками могут быть:

* Элементы массива - при деструктуризации массива можно собрать в новый массив все значения, которые не извлеклись в переменные.
* Свойства объекта - при деструктуризации объекта можно собрать новый объект из свойств, которые не извлеклись в переменные.
* Параметры функции - все аргументы, для которых не хватило параметров, описанных в функции, собираются в массив.

Когда речь про параметры и элементы массива, то "остатки" собираются в настоящий *массив* (а не псевдомассив). "Остатки" объекта собираются в *объект*.

> Не надо путать rest-оператор со spread-оператором, который тоже выглядит как три точки. Разница в том, что rest-оператор нужен, чтобы *собрать* элементы в единый контейнер. А spread-оператор позволяет *разбить* единый контейнер на отдельные элементы.

# ... и деструктурирующее присваивание

## Остаток массива

Если переменных для присвоения всех значений не хватает, то эти значения отбрасываются. Например:

```javascript
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин"];
let [apple, pear] = fruits;  // Значения "Апельсин" и "Мандарин" никуда не присвоены
```

Используя остаточные параметры, можно собрать оставшиеся значения в одну переменную в виде массива:

```javascript
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин"];
let [apple, pear, ...other] = fruits;  // Теперь Апельсин и Мандарин лежат в массиве other

other.forEach(f => console.log(f));  // Апельсин, Мандарин
```

## Остаток объекта

Остаточные параметры позволяют собрать неприсвоенные свойства в один объект:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state, ...other} = user;  // name и age станут свойствами объекта other

console.log(state);  // Illinois
console.log(other.name);  // Huck
console.log(other.age);   // 15
```

# ... и параметры функции

## Обычные функции

С помощью остаточных параметров мы можем передать в функцию произвольное количество аргументов, независимо от того, сколько параметров в ней объявлено.

Все аргументы, которым не нашлось места в параметрах, собираются в массив (настоящий массив, а не псевдомассив). Остаточные параметры обязаны идти в конце списка параметров. Например:

```javascript
function hello(firstname, lastname, ...rest) {
  console.log("Имя: " + firstname + " " + lastname);
  console.log("Псевдонимы:");
  rest.forEach(v => console.log(v));
}
// firstname, lastname |      попадут в массив rest
hello("Джеки", "Чан",    "Громобой", "Азиатский ястреб", "Ковбой");

// Имя: Джеки Чан
// Псевдонимы:
//   Громобой
//   Азиатский ястреб
//   Ковбой
```

Можно вообще единственным параметром сделать остаточный:

```javascript
function sum(...nums) {
  return nums.reduce((prev, curr) => prev += curr, 0);
}

console.log(sum(5, 6, 4));  // 15
```

## Лямбды

У лямбд вообще нет arguments, поэтому остаточные параметры - это единственный способ создать лямбду с произвольным количеством параметров:

```javascript
const sum = (...nums) => nums.reduce((prev, curr) => prev += curr, 0);
console.log(sum(5, 6, 4));  // 15
```

# Пример из React

Пример на использование в одной функции и оператора "остаточные параметры" и "оператора разбиения":

```react
const MyButton = ({children, ...props}) => {
  return (
    <button {...props}>{children}</button>
  );
};
```

В компонент MyButton передается единый объект props, в котором среди прочих есть свойство children. С помощью деструктуризации мы извлекаем это свойство в отдельную переменную children, а все остальные свойства с помощью оператора "остаточные параметры" опять собираем в новый объект props. А вот в компоненте button дальше мы уже пользуемся "оператором разбиения", который разбивает объект rest на отдельные переменные и они уходят в компонент как отдельные атрибуты.

```react
import classes from './MyButton.module.css';

const MyButton = ({children, ...rest}) => {
  console.log(rest);
  return (
    <button {...rest}>{children}</button>
  );
};

export default MyButton;
```

Если в компонент MyButton приходит объект props `{children: ololo, disabled: true, visible: true}`, то запись `{children, ...rest}` выдерет children в отдельную переменную, а все остальное (в данном случае свойства disabled и visible) соберет в объект rest. Далее, `{...rest}` разобьет объект rest на отдельные переменные и они уйдут в button отдельными атрибутами, все равно что написать `<button disabled=true visible=true>{children}</button>`.

