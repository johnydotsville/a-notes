# Классы "старой школы"

До появления ключевого слова `class` тоже можно было создавать классы объектов. В JS вся "классовость" является синтаксическим сахаром над созданием объекта и установкой ему прототипа. Класс является скорее концепцией, вроде "набор объектов, у которых один и тот же прототип".

Поэтому, прежде чем переходить к сахару, посмотрим на то как можно создавать классы объектов "без классов".

## Фабричные функции

Суть в том, что:

* Объявляется "фабричная" функция, через которую будут создаваться объекты.
* К этой функции добавляется какое-нибудь свойство, в которую мы кладем прототип для производимых ею объектов. Просто для удобства, а технически конечно это не обязательно.
  * При создании объекта устанавливаем ему этот прототип.

```javascript
function person(firstname, lastname) {  // <-- "Фабричная функция" для производства людей
  const p = Object.create(person.basis);  // <-- Устанавливаем прототип новому человеку
  p.firstname = firstname;
  p.lastname = lastname;

  return p;
}

person.basis = {  // <-- "Прототип" для будущих "персон" сохраняем в фабричную функцию для удобства
  fullname() {
    return `${this.firstname} ${this.lastname}`;
  }
};

const huck = person("Huck", "Finn");  // <-- Прототипом Гека стал объект basis
console.log(huck.fullname());  // Huck Finn

const becky = person("Becky", "Thatcher");  // // <-- И у Бекки тоже
console.log(becky.fullname());  // Becky Thatcher
```

В итоге у нас получились объекты huck и becky, которые образуют "класс" объектов person. Реализация не пользуется никакими специальными конструкциями языка, но по сути создает объекты с общим прототипом.

## Функции-конструкторы и оператор new

Оператор new - это шаг вперед по сравнению с фабричными функциями. Если вызвать функцию через new, он автоматически создает новый объект, кладет его в this, а по окончанию функции возвращает этот объект. Кроме того, он автоматически устанавливает созданному объекту прототип.

Подробнее об этом написано в разделе про объекты, конспект про функцию-конструктор.