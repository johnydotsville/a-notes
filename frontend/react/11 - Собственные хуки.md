# Собственные хуки

Собственные (или кастомные хуки) - это хуки, которые мы пишем сами и которые используют стандартные реактовские хуки. В хуки можно выносить функциональность из компонента, чтобы сделать его более компактным.

> С виду выглядит так, будто это просто функция, вынесенная в отдельный файл. Можно было бы наверное просто в том же файле создать отдельную функцию ниже. Ну да ладно, пока напишу как есть, потом догуглю, в чем смысл собственных хуков.
>
> UPD. Не совсем. Если назвать функцию не use, а как-то еще, то реакт просто не позволит использовать внутри нее хук. Он воспримет ее как обычную функцию и скажет как раз, что вы не можете использовать хуки в обычных функциях.

## Файл хука

* Файл с хуком имеет расширение `.js`
* Экспорт хука делается через обычный `export`, без `default` (хотя это надо догуглить)

```react
import {useMemo} from 'react';

export const usePosts = (posts, filterParams) => {
  const filteredPosts = useMemo(() => {
    console.log("Применение фильтров к постам.");
    let result = [...posts];
    if (filterParams.sortBy) {
      result.sort(
        (a, b) => a[filterParams.sortBy].localeCompare(b[filterParams.sortBy])
      );
    }
    if (filterParams.searchBy) {
      result = result.filter(p => p.title.toLowerCase().includes(filterParams.searchBy.toLowerCase()));
    }
    return result;
  }, [filterParams, posts]);

  return filteredPosts;
};
```

Использование хука:

```react
import {usePosts} from './components/hooks/usePosts';

function App() {
...
  const filteredPosts = usePosts(posts, filterParams);
```



# Второй пример хука

```javascript
import {useState} from 'react';

export const useFetching = (work) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const fetching = async () => {
    try {
      setIsLoading(true);
      await work();
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  }

  return [fetching, isLoading, error];
};
```

Использование хука:

```react
const [fetchPosts, isPostLoading, postError] = useFetching(async () => {
  setPosts(await PostService.getAll());
});
```











Альтернативный пример своего хука:

```react
import {useState} from 'react';
import {useMemo} from 'react';
import {useRef} from 'react';

function getBookmarks() {
  return [
    {id: 0, title: 'О дружбе и вражде', content: 'Неверный друг опаснее врага.'},
    {id: 1, title: 'О родине', content: 'Глупа та птица, которой гнездо свое немило.'},
    {id: 2, title: 'О труде и работе', content: 'С мастерством люди не родятся, а добытым ремеслом гордятся.'},
    {id: 3, title: 'О времени', content: 'Иное время, иное бремя.'},
    {id: 4, title: 'О книгах и чтении', content: 'Книга - маленькое окошко, через него весь мир видно.'},
  ];
}

// <-- Компонент выбора поля сортировки
function Select({options, onSelect}) {
  return (
    <select defaultValue="" onChange={e => onSelect(e.target.value)}>
      <option disabled value="">Не выбрано</option>
      {options.map(o => <option key={o.field} value={o.field}>{o.displayName}</option>)}
    </select>
  );
}

// <-- Компонент обычного поиска
function Search({setNeedle}) {
  const needle = useRef();

  const resetNeedle = () => {
    setNeedle('');
    needle.current.value = '';
  }

  return (
    <div>
      <input ref={needle} />
      <button onClick={() => setNeedle(needle.current.value)}>Искать</button>
      <button onClick={resetNeedle}>Сбросить</button>
    </div>
  );
}

// <-- Компонент живого поиска
function LiveSearch({setNeedle}) {
  const needle = useRef();

  const resetNeedle = () => {
    setNeedle('');
    needle.current.value = '';
  }

  return (
    <div>
      <input ref={needle} onChange={e => setNeedle(e.target.value)} />
      <button onClick={resetNeedle}>Сбросить</button>
    </div>
  );
}

// <-- Компонент элемента
function Bookmark({title, children}) {
  return (
    <div style={{ border: '1px solid black', margin: '10px', padding: '5px' }}>
      <strong>{title}</strong>
      <div>{children}</div>
    </div>
  );
}

// <-- Вынесли логику в самостоятельный хук, чтобы сделать компонент компактнее
function useDisplayedBookmarks(bookmarks, sortBy, needle) {
  let result = bookmarks;
  
  result = useMemo(() => {
    if (needle) {
      console.log(`Сработала фильтрация. needle: '${needle}'`);
      return result.filter(b => b.content.includes(needle));
    }
    return result;
  }, [needle, result]);

  result = useMemo(() => {
    if (sortBy) {
      console.log(`Сработала сортировка. sortBy: '${sortBy}'`);
      return [...result].sort((a, b) => a[sortBy].localeCompare(b[sortBy]));
    }
    return result;
  }, [sortBy, result]);

  return result;
}

// <-- Компонент с данными и логикой отображения
export default function Mentions() {
  const [bookmarks, setBookmarks] = useState(getBookmarks());
  const [sortBy, setSortBy] = useState('');
  const [needle, setNeedle] = useState('');
  const [foobar, setFoobar] = useState('');

  const displayedBookmarks = useDisplayedBookmarks(bookmarks, sortBy, needle);

  return (
    <>
      <div>Нужен useMemo<input onChange={e => setFoobar(e.target.value)} /></div>
      Обычный поиск <Search setNeedle={setNeedle} />
      Мгновенный поиск <LiveSearch setNeedle={setNeedle} />
      <div>Сортировать по
        <Select 
          options={[
            {field: 'title', displayName: 'Заголовок'},
            {field: 'content', displayName: 'Содержимое'}
          ]} 
          onSelect={f => setSortBy(f)} />
      </div>
      <section>
        {displayedBookmarks.map(b => <Bookmark title={b.title}>{b.content}</Bookmark>)}
      </section>
    </>
  );
}
```

