TODO: вот отсюда https://habr.com/ru/articles/541320/ выписать понятные на данный момент требования, вроде "размещать вспомогательные функции вне компонента", "Называть компоненты с большой буквы" и т.д.

# Компонент

## Концепция компонента

Интерфейс строится из набора маленьких блоков - полей ввода, кнопок, картинок и т.д. *Компонент* - это одна из основных концепций реакта. Компонент может быть как совсем простым, например состоять из одной кнопки, так и более сложным, например, объединять множество полей ввода, кнопок в какую-нибудь анкету. Несколько компонентов могут комбинироваться друг с другом и формировать еще более сложные компоненты и т.д. Т.о. компонент - это переиспользуемый элемент пользовательского интерфейса.

## JSX

Любой компонент возвращает JSX-разметку. JSX - это синтаксическое расширение Javascript'а, которое содержит аналоги почти всех HTML-тегов и позволяет удобным образом писать HTML-подобную разметку прямо в компоненте, вместо того чтобы возиться с объектами. Потом реакт преобразует эту разметку в настоящий HTML. По JSX есть отдельный конспект.

## Функциональный компонент

Функциональный компонент - это функция, которая возвращает jsx. Особенности и требования:

* Функция может быть как обычной, так и лямбдой. Обычно используются лямбды или Function Declaration.
* Название компонента (функции, переменной) нужно обязательно писать с большой буквы, иначе работать не будет.
* Нельзя вкладывать *объявления* компонентов друг в друга. В JS мы можем объявлять одну функцию внутри другой, следовательно и компонент можем описать внутри другого компонента. Делать так не надо. Каждый компонент объявляется на верхнем уровне файла.
* Вспомогательные функции следует размещать вне компонента, на верхнем уровне, а требуемые данные передавать им в качестве параметров. Это позволяет минимизировать код компонента, делая его более наглядным и доступным для понимания.

Примеры объявления функционального компонента:

```react
const Hello = () => {  // <-- Лямбда
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
function Hello() {  // <-- Function Declaration
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
const Hello = function() {  // <-- Function Expression
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

## Классовый компонент

Описание компонентов через классы является устаревшим подходом и рекомендуется пользоваться функциональными компонентами. Особенности классовых компонентов:

* Класс должен наследоваться от класса `React.Component`.
* Конструктор должен принимать параметр props и передавать его в родительский конструктор.
* Класс должен иметь метод `render()`, который возвращает jsx.

```react
import React from 'react';

class Hello extends React.Component {

  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Привет, мир!</h1>
    );
  }

}

export default Hello;
```

## Особенности оформления

Несколько хороших практик и технических замечаний о компонентах:

* Обычно придерживаются правила "один файл - один компонент" и называют файл и компонент одинаково.
  * Расширение у файла может быть `.jsx`, `.js` TODO: и наверняка какое-нибудь связанное с typescript.
  * Технически, в одном файле можно расположить несколько компонентов. Подробнее о том, как это сделать и зачем, в конспекте про экспорт \ импорт компонентов.
* Возвращаемая из компонента JSX-разметка:
  * Должна быть завернута в единый блок, например `<div>` или `<Fragment>` и т.д. Это связано с тем, что JSX трансформируется в обычный JS-объект, а мы не можем возвращать из функции больше одного значения.
  * Для удобства можно брать разметку в круглые скобки `return ( разметка )`. Это позволяет оформлять разметку на нескольких строках и не бояться багов, связанных с автоматической расстановкой js-ом точек с запятой.

# Состояние компонента

## Функциональный компонент

### Хук useState

```react
import {useState} from 'react';
```

Состояние компонента - это некоторые данные, которые компонент использует. Например, состояние компонента "Калькулятор" - это первое число, второе число, выполняемая операция и результат.

Работа с состоянием компонента начинается с вызова функции-хука `useState(начальное_состояние)`. Мы передаем в нее значение \ объект, который хотим использовать в качестве начального состояния, а она нам возвращает переменную, содержащую это состояние, плюс функцию для его изменения.

```react
const [состояние, функцияДляИзмененияСостояния] = useState(5);
```

Теперь, чтобы изменить состояние компонента, мы вызываем полученную от хука функцию, передавая в нее новое значение состояния. Саму переменную состояния мы как правило не изменяем, потому что в этом нет смысла, ибо реакт эти изменения не увидит, а используем ее для чтения состояния и формирования нового состояния на основе текущего.

У компонента может быть много состояний, т.е. мы можем применять хук useState сколько угодно раз. Состояние не стоит воспринимать как монолитный объект, содержащий все-все-все данные, касающиеся компонента. Наоборот, данные компонента могут быть разбиты на небольшие кусочки, несколько "состояний", каждое из которых может меняться независимо.

Состояние меняется не мгновенно после вызова функции изменения состояния, а асинхронно. Реакт накапливает все изменения, а потом пачкой их применяет. Это позволяет оптимизировать изменения в DOM-дереве, но может приводить к некоторой задержке в отображении в некоторых случаях, об этом стоит помнить. TODO: когда разберусь детальнее, как это работает, вставить сюда ссылку.

Пример объявления состояния:

```react
import {useState} from 'react';

const Counter = () => {
  const [count, setCount] = useState(5);  // <-- Создали состояние и получили ф-ию для его измения

  function increment() {
    setCount(count + 1);  // <-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
  }

  function decrement() {
    setCount(count - 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

Вот пример для состояния, представленного объектом:

```react
import {useState} from 'react';

const Counter = () => {
  const [data, setData] = useState({x: 5, y: 10});

  function increment() {
    setData({
      x: data.x + 1,
      y: data.y + 1
    });
  }

  function decrement() {
    setData({
      x: data.x - 1,
      y: data.y - 1
    });
  }

  return (
    <div>
      <h1>x: {data.x}, y: {data.y}</h1>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

## Классовый компонент

* В классовом компоненте состояние объявляется в конструкторе.
* Под состояние существует свойство `state`.
  * Для изменения состояния - метод `setState`.
* Все методы класса необходимо биндить, потому что теряется контекст. TODO: можно кстати почитать, почему так происходит.

```react
import React from 'react';

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // <-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // <-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // <-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={this.increment}>Увеличить</button>
        <button onClick={this.decrement}>Уменьшить</button>
      </div>
    );
  }

}

export default Counter;
```

