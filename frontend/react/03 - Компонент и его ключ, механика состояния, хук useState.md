TODO: вот отсюда https://habr.com/ru/articles/541320/ выписать понятные на данный момент требования, вроде "размещать вспомогательные функции вне компонента", "Называть компоненты с большой буквы" и т.д.

# Компонент

## Концепция компонента

Интерфейс строится из набора маленьких блоков - полей ввода, кнопок, картинок и т.д. *Компонент* - это одна из основных концепций реакта. Компонент может быть как совсем простым, например состоять из одной кнопки, так и более сложным, например, объединять множество полей ввода, кнопок в какую-нибудь анкету. Несколько компонентов могут комбинироваться друг с другом и формировать еще более сложные компоненты и т.д. Т.о. компонент - это переиспользуемый элемент пользовательского интерфейса.

## JSX

Любой компонент возвращает JSX-разметку. JSX - это синтаксическое расширение Javascript'а, которое содержит аналоги почти всех HTML-тегов и позволяет удобным образом писать HTML-подобную разметку прямо в компоненте, вместо того чтобы возиться с объектами. Потом реакт преобразует эту разметку в настоящий HTML. По JSX есть отдельный конспект.

## Функциональный компонент

Функциональный компонент - это функция, которая возвращает jsx. Особенности и требования:

* Функция может быть как обычной, так и лямбдой. Обычно используются лямбды или Function Declaration.
* Название компонента (функции, переменной) нужно обязательно писать с большой буквы, иначе работать не будет.
* Нельзя вкладывать *объявления* компонентов друг в друга. В JS мы можем объявлять одну функцию внутри другой, следовательно и компонент можем описать внутри другого компонента. Делать так не надо. Каждый компонент объявляется на верхнем уровне файла.
* Вспомогательные функции следует размещать вне компонента, на верхнем уровне, а требуемые данные передавать им в качестве параметров. Это позволяет минимизировать код компонента, делая его более наглядным и доступным для понимания.

Примеры объявления функционального компонента:

```react
const Hello = () => {  // <-- Лямбда
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
function Hello() {  // <-- Function Declaration
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
const Hello = function() {  // <-- Function Expression
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

## Классовый компонент

Описание компонентов через классы является устаревшим подходом и рекомендуется пользоваться функциональными компонентами. Особенности классовых компонентов:

* Класс должен наследоваться от класса `React.Component`.
* Конструктор должен принимать параметр props и передавать его в родительский конструктор. Что такое пропсы - в отдельном конспекте.
* Класс должен иметь метод `render()`, который возвращает jsx.

```react
import React from 'react';

class Hello extends React.Component {

  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Привет, мир!</h1>
    );
  }

}

export default Hello;
```

## Особенности оформления

Несколько хороших практик и технических замечаний о компонентах:

* Обычно придерживаются правила "один файл - один компонент" и называют файл и компонент одинаково.
  * Расширение у файла может быть `.jsx`, `.js` TODO: и наверняка какое-нибудь связанное с typescript.
  * Технически, в одном файле можно расположить несколько компонентов. Подробнее о том, как это сделать и зачем, в конспекте про экспорт \ импорт компонентов.
* Возвращаемая из компонента JSX-разметка:
  * Должна быть завернута в единый блок, например `<div>` или `<Fragment>` (`<>`) и т.д. Это связано с тем, что JSX трансформируется в обычный JS-объект, а мы не можем возвращать из функции больше одного значения.
  * Для удобства можно брать разметку в круглые скобки `return ( разметка )`. Это позволяет оформлять разметку на нескольких строках и не бояться багов, связанных с автоматической расстановкой js-ом точек с запятой.

## Чистые компоненты

Компоненты в реакт строятся по принципу чистой функции (pure function).

# Состояние компонента

## Функциональный компонент

### Хук useState

```react
import {useState} from 'react';
```

Состояние компонента - это некоторые данные, которые компонент использует. Например, состоянием компонента  "Анкета" может быть имя человека, профессия, дата рождения.

Работа с состоянием компонента начинается с вызова функции-хука `useState(начальное_состояние)`. Мы передаем в нее значение \ объект, который хотим использовать в качестве начального состояния, а она нам возвращает переменную, содержащую это состояние, плюс функцию для его изменения.

```react
const [состояние, функцияДляИзмененияСостояния] = useState(5);
const [login, setLogin] = useState('neofit');
```

Теперь, чтобы изменить состояние компонента, мы вызываем полученную от хука функцию, передавая в нее новое значение состояния. Вручную переменную состояния мы не изменяем, потому что в этом нет смысла, ибо реакт эти изменения не увидит, а используем ее для чтения состояния и формирования нового состояния на основе текущего. Т.о., состояние мы всегда воспринимаем как иммутабельное значение, которое можно заменить, но не изменить. Имя для функции изменения состояния может быть произвольным, но лучше при именовании следовать соглашению `переменнаяСостояния`, `setПеременнаяСостояния`.

У компонента может быть много состояний, т.е. мы можем применять хук useState сколько угодно раз. Состояние не стоит воспринимать как монолитный объект, содержащий все-все-все данные, касающиеся компонента. Наоборот, данные компонента могут быть разбиты на небольшие кусочки, несколько "состояний", каждое из которых может меняться независимо.

```react
import {useState} from 'react';

const Counter = () => {
  const [count, setCount] = useState(5);  // <-- Создали состояние и получили ф-ию для его измения

  function increment() {
    setCount(count + 1);  // <-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
  }

  function decrement() {
    setCount(count - 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

## Классовый компонент

* В классовом компоненте состояние объявляется в конструкторе.
* Под состояние существует свойство `state`.
  * Для изменения состояния - метод `setState`.
* Все методы класса необходимо биндить, потому что теряется контекст. TODO: можно кстати почитать, почему так происходит.

```react
import React from 'react';

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // <-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // <-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // <-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={this.increment}>Увеличить</button>
        <button onClick={this.decrement}>Уменьшить</button>
      </div>
    );
  }

}

export default Counter;
```

# Виды состояний

## Состояние-примитив

Было рассмотрено при объяснении хука useState.

## Состояние-объект

Когда состояние представлено объектом, мы придерживаемся правила иммутабельности - сам объект не изменяем, а предоставляем сеттеру новый объект:

```react
import {useState} from 'react';

const Counter = () => {
  const [data, setData] = useState({x: 5, y: 10});

  function increment() {
    setData({
      x: data.x + 1,
      y: data.y + 1
    });
  }

  function decrement() {
    setData({
      x: data.x - 1,
      y: data.y - 1
    });
  }

  return (
    <div>
      <h1>x: {data.x}, y: {data.y}</h1>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

Когда объект большой, в нем много полей и если они к тому же вложены друг в друга, то переписывать целиком такой объект не удобно. В этих случаях нам поможет оператор расширения `...` (см. конспект по Javascript, если не понятно как он работает и как именно помогает в данном случае):

```react
const [info, setInfo] = useState({  // <-- Объект со множеством полей
  firstName: 'Alan',
  lastName: 'Wake',
  profession: 'writer'
});

const changeReality = () => {
  setInfo({
    ...info,
    profession: 'crazy man with a gun'
  });
}
```

```react
const [info, setInfo] = useState({  // <-- Объект со вложенными полями
  name: {
    firstName: 'Alan',
    lastName: 'Walker'
  },
  profession: 'writer'
});

const changeReality = () => {
  setInfo({
    ...info,
    name: {
      ...info.name,
      lastName: 'Wake'
    }
  });
}
```

В целом же стоит избегать глубоких вложений в состоянии и проектировать его так, чтобы оно было как можно более плоским.

## Состояние-массив

Когда состояние является массивом, мы должны сохранять иммутабельность: любая операция изменения состава массива (удаление, добавление) выполняется через создание нового массива, копирования в него элементов из старого, и установки нового массива в качестве состояния.

### Добавление в конец \ начало массива

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState('');

  const handleAddNameClick = () => {
    setWords([...words, {id: wordId, word: word}]);  // <-- Добавление в конец массива
    setWordId(wordId + 1);
  }

  return (
    <div>
      <input onChange={e => setWord(e.target.value)} />
      <button onClick={handleAddNameClick}>Добавить</button>
      <ul>
        {words.map(w => (<li key={w.id}>{w.word}</li>))}
      </ul>
    </div>
  )
}
```

Добавление в начало можно сделать так: `setWords([{id: wordId, word: word}, ...words])`

### Удаление из массива

Делается через фильтрацию методом `filter` массива:

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState('');

  const handleAddNameClick = () => {
    setWords([...words, {id: wordId, word: word}]);
    setWordId(wordId + 1);
  }

  const handleDeleteWordClick = (id) => {
    setWords(words.filter(w => w.id != id));  // <-- Возвращаем новый массив без удаляемого элемента
  }

  return (
    <div>
      <input onChange={e => setWord(e.target.value)} />
      <button onClick={handleAddNameClick}>Добавить</button>
      <ul>
        {words.map(w => (
          <li key={w.id}>
            {w.word}
            <button onClick={() => handleDeleteWordClick(w.id)}>Удалить</button>
          </li>))
        }
      </ul>
    </div>
  )
}
```

### Изменение всех элементов

Делается методом `.map()` массива:

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'},
    {id: 3, word: 'Весна'},
    {id: 4, word: 'Победа'}
  ]);

  const handleTransformClick = () => {
    setWords(words.map((w, i) => i > 1 ? {...w, word: w.word.toUpperCase()} : w));  // <--
  }

  return (
    <>
      <ul>
        {words.map(w => <li key={w.id}>{w.word}</li>)}
      </ul>
      <button onClick={handleTransformClick}>Преобразовать</button>
    </>
  )
}
```

### Замена конкретного элемента

Тоже делается методом `.map()` массива. Просто пишем условие так, чтобы заменился только один элемент:

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'},
    {id: 3, word: 'Весна'},
    {id: 4, word: 'Победа'}
  ]);
  const wordToSwap = 'Весна';
  const swapTo = 'Лето';

  const handleTransformClick = () => {
    setWords(words.map(w => !w.word.localeCompare(wordToSwap) ?  // <--
      {...w, word: swapTo} : w));
  }

  return (
    <>
      <ul>
        {words.map(w => <li key={w.id}>{w.word}</li>)}
      </ul>
      <button onClick={handleTransformClick}>Преобразовать</button>
    </>
  )
}
```



### Вставка элемента в середину массива

Делается комбинацией метода `.slice()` массива и оператора расширения. Методом slice возвращаем новый массив от начала до места вставки, расширяем полученный массив, потом ставим новый элемент, и опять методом slice возвращаем новый массив от места вставки до конца, расширяем его и все это вместе заворачиваем в новый массив:

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'},
    {id: 3, word: 'Весна'},
    {id: 4, word: 'Победа'}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState('');
  const middle = words.length / 2;  // <-- Вставлять будем в середину массива

  const handleAddNameClick = () => {
    setWords([
      ...words.slice(0, middle),  // <-- Выбираем подмассив до места вставки
      {id: wordId, word: word},   // <-- Вставляем новый элемент
      ...words.slice(middle)      // <-- Выбираем подмассив после места вставки
    ]);  // <-- И из всех этих кусочков собираем новый массив
    setWordId(wordId + 1);
  }

  return (
    <div>
      <input onChange={e => setWord(e.target.value)} />
      <button onClick={handleAddNameClick}>Добавить</button>
      <ul>
        {words.map(w => (<li key={w.id}>{w.word}</li>))}
      </ul>
    </div>
  )
}
```

### Сортировка, инверсия массива

Методы `.sort()` и `.reverse()` мутируют массив. Поэтому сначала делаем копию существующего массива, затем эту копию сортируем \ инвертируем и устанавливаем в качестве нового состояния. Стоит помнить, что копия *поверхностная*, т.е. хоть массив новый, но он содержит ссылки на исходные элементы, поэтому менять их нельзя, т.к. иначе получится что мы изменим и исходное состояние.

```react
import {useState} from 'react';

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: 'Мир'},
    {id: 1, word: 'Труд'},
    {id: 2, word: 'Май'},
    {id: 3, word: 'Весна'},
    {id: 4, word: 'Победа'}
  ]);

  const handleSortClick = () => {
    const copy = [...words];  // <-- Делаем копию
    copy.sort((a, b) => a.word.localeCompare(b.word));  // <-- Сортируем копию
    setWords(copy);  // <-- Устанавливаем копию как новое состояние
  };
  const handleReverseClick = () => {
    const copy = [...words];  // <-- Делаем копию
    copy.reverse();  // <-- Инвертируем копию
    setWords(copy);  // <-- Устанавливаем копию как новое состояние
  };

  return (
    <div>
      <ul>
        {words.map(w => (<li key={w.id}>{w.word}</li>))}
      </ul>
      <button onClick={handleSortClick}>Сортировать</button>
      <button onClick={handleReverseClick}>Инвертировать</button>
    </div>
  )
}
```

## Библиотека Immer

Чтобы сделать работу с иммутабельным состоянием удобнее и нагляднее, существует библиотека `Immer`. Если я о ней и напишу, то это будет отдельный конспект.

# Отрисовка компонентов

## Механика отрисовки компонентов

Отрисовка компонента включает в себя три шага:

* Рендер.
* Комит в DOM.

Активация рендера происходит в двух случаях:

* Начальный рендеринг - когда приложение запускается первый раз и интерфейс отрисовывается полностью с нуля.
* Изменение состояния компонента - когда мы вызываем функцию изменения состояния, то возникает необходимость перерисовать с обновленными данными ту часть интерфейса, за которую отвечает этот компонент. По умолчанию перерисовываются и те компоненты, которые вложены в изменившийся компонент.

Условно можно сказать, что **рендер** - это процесс, при котором реакт определяет, какие изменения произошли в *компонентах* и какие именно *компоненты* нужно перерисовать, а **комит в DOM** - это применение браузерных методов по модификации DOM-дерева, например, appendChild и прочих, после которых браузер перерисует *реальные элементы*.

## Хуки

Хуки доступны только на этапе рендеринга. Их можно вызывать исключительно на верхнем уровне компонента (нельзя вызвать хук, например, в обработчике события нажатия на кнопку).

# Механика изменения состояния

## Очередь изменений

Обычные локальные переменные не могут формировать состояние, потому что между рендерингами они не сохраняются. Не забываем, что компонент - это обычная функция, которая возвращает JSX, а каждый рендер - это новый вызов функции. Стало быть, все локальные переменные от прошлого вызова давно стерты из памяти. Состояние же не является локальной переменной компонента, можно сказать, что оно хранится "в самом реакте".

Изменение состояния вызывает повторный рендеринг компонента. Однако он происходит не мгновенно. Наглядный пример:

```react
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

При щелчке по кнопке счетчик увеличится на 1, а не на 3. Это происходит по нескольким причинам:

* Вызов сеттера не приводит к *моментальному* изменению состояния. Этот вызов можно воспринимать как заказ на изменение состояния при *следующем рендеринге*. Код обработчика onClick сначала выполнится полностью, прежде чем что-то изменится. Сделано это для того, чтобы не вызывать рендеринг слишком часто. Например, будь у нас несколько состояний, то в этом обработчике мы могли бы вызывать несколько сеттеров разных состояний. В таком случае было бы выгоднее сначала окончательно определиться со всеми значениями, а потом разом их отрисовать. Плюс это исключает проблему, что состояние могло бы быть отрисовано как-то частично.
* Исходя из первой причины, получается что в пределах одного рендера состояние всегда одинаковое. Так что каждая из строк `setNumber(number + 1)` по сути выглядит как `setNumber(0 + 1)`.

## Функция-апдейтер

Когда мы передаем в сеттер только значение, то сеттер работает по принципу замены текущего состояния на новое значение. Если же мы передадим в него функцию с единственным параметром, то сеттер нам через этот параметр передаст текущее значение состояния. Т.о. мы сможем переписать предыдущий пример, чтобы счетчик увеличивался на 3:

```react
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(n => n + 1);  {/* Почувствуй разницу с number + 1 */}
        setNumber(n => n + 1);
        setNumber(n => n + 1);
      }}>+3</button>
    </>
  )
}
```

Данный пример будет работать фактически так:

```
0 => 0 + 1;  // n = 1
1 => 1 + 1;  // n = 2
2 => 2 + 1;  // n = 3
```

Пара дополнительных примеров для тренировки, чему будет равно итоговое состояние в каждом случае (исходное значение 0)?

```react
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
    
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

Ответы: шесть и сорок два.

# Ключ компонента

> В примере ниже используются пропсы, JS-вставки, деструктуризация. Все эти темы описаны дальше, в других конспектах. Но не хотелось делать про ключ отдельный конспект. По ощущениям, ему место здесь. Поэтому если вдруг код не понятен, можно сначала перечитать следующие конспекты. Хотя даже при этом концепция ключа здесь должна быть понятна.

Типичная задача - отрисовать множество одинаковых компонентов, которые отличаются только данными. Например, есть массив сообщений, дел и т.д. и нужно все их отобразить. Поскольку в конце концов реакту придется построить из множества этих элементов реальные узлы DOM-дерева, а перестройка DOM операция тяжелая, то хорошо было бы, чтобы ему не приходилось перерисовывать все с нуля при изменении массива данных, например после добавления или удаления дел.

Для этого каждому компоненту из этого множества мы должны присвоить *ключ*. Это поможет реакту оптимизировать отрисовку.

Требования к ключам и особенности ключей:

* Ключ должен быть уникальным в пределах соседних элементов. Это значит, что если у нас два разных списка на одной странице, то ключ должен быть уникальным в пределах каждого списка, но может совпадать с ключом из другого списка.

* Ключ должен быть статичным, т.е. не изменяться в пределах жизни компонента. Как правило, это означает, что ключ нельзя генерировать при перерисовке компонента, потому что тогда каждый раз ключи будут разные и толку от них не будет.

  В идеале, ключ должен быть частью данных, например, id из базы данных. А вот например индекс массива является плохим ключом, потому что при добавлении или удалении элементов индекс конкретного элемента по сути меняется. Кто был третьим, станет вторым и т.д. Индекс массива в качестве ключа реакт использует, если мы не указали ключ явно.

* Ключ задается компоненту через атрибут `key`. Однако у компонента не появляется пропс key, т.е. key фактически является чисто инфраструктурным хинтом для самого реакта.

Пример:

```react
function Profile({info: {name, profession, birth, death, photo}}) {
  return (
    <>
      <div>{name}, {profession}</div>
      <div>Годы жизни: {birth} - {death}</div>
      <img src={photo} width={100}/>
    </>
  );
}

export default function Gallery() {
  const famousUssrPeople = getPeople()
    .map(p => <li key={p.id}><Profile info={p} /></li>);

  return (
    <section>
      <h1>Известные люди СССР</h1>
      <ul>{famousUssrPeople}</ul>
    </section>
  );
}

function getPeople() {
  return [
    {
      id: 1000,
      name: 'Гагарин Юрий Алексеевич',
      profession: 'Космонавт',
      birth: '9 марта 1934',
      death: '27 марта 1968',
      photo: 'https://upload.wikimedia.org/wikipedia/commons/e/e6/Yuri_Gagarin_with_awards.jpg'
    },
    {
      id: 2000,
      name: 'Курчатов Игорь Васильевич',
      profession: 'Физик',
      birth: '8 января 1903',
      death: '7 февраля 1960',
      photo: 'https://upload.wikimedia.org/wikipedia/commons/a/a3/Igor_Kurchatov_001.png'
    },
    {
      id: 3000,
      name: 'Яковлев Александр Сергеевич',
      profession: 'Авиаконструктор',
      birth: '19 марта 1906',
      death: '22 августа 1989',
      photo: 'https://upload.wikimedia.org/wikipedia/ru/7/7b/Yakovlev_AS-2GST.jpg'
    },
    {
      id: 4000,
      name: 'Маяковский Владимир Владимирович',
      profession: 'Поэт',
      birth: '19 июля 1893',
      death: '14 апреля 1930',
      photo: 'https://upload.wikimedia.org/wikipedia/commons/5/50/Majakovszkij.jpg'
    },
    {
      id: 5000,
      name: 'Папанов Анатолий Дмитриевич',
      profession: 'Актер',
      birth: '31 октября 1922',
      death: '5 августа 1987',
      photo: 'https://upload.wikimedia.org/wikipedia/commons/c/c8/Anatoli_Papanov_%281%29_cr.jpg'
    }
  ];
}
```

