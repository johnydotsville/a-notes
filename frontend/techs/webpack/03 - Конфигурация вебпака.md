# Файл конфига

## webpack.config.js

Файл `webpack.config.js` кладем в корневую папку проекта. Он представляет собой код на JS, с импортами \ экспортами в Node-стиле:

```javascript
// <-- В начале импортируем классы, функции, константы - все, что используется далее в коде
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {  // <-- Конфиг экспортируется в виде объекта, поля которого - настройки вебпака
  mode: "production",
  entry: path.resolve(__dirname, './src/index.ts'),
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname,"./src/templates/index.html")
    })
  ]
};
```

## Переменные окружения

Переменные окружения позволяют удобно передавать в конфиг динамические значения. Например, из команды запуска скрипта можно передать режим сборки - dev или prod. При использовании переменных окружения из конфига экспортируется не объект, а функция, возвращающая объект. У этой функции мы можем объявить параметры - через них и будут передаваться переменные окружения:

```javascript
module.exports = (env) => {  // <-- Через параметры можем передавать динамические значения
  return {
    mode: env.mode ?? "development"
  }
}
```

А вот описание скриптов из конфига нод-проекта package.json:

```yaml
{
  ...
  "scripts": {
    "build:dev": "webpack --env mode=development",
    "build:prod": "webpack --env mode=production"
  },
}
```

`--env` - объект, который попадет в одноименный параметр функции из конфига вебпака (env), а `mode` станет полем этого объекта.

```
npm run build:dev
```

Если нужно несколько переменных окружения, то синтаксис такой:

```yaml
"build:desktop": "webpack --env mode=production --env platform=desktop"
```

## Написание конфига на ts

Официальная [документация](https://webpack.js.org/configuration/configuration-languages/#typescript). TODO: поподробнее погуглить про шаги из оф доки.

### Установка нужных пакетов

Сам конфиг можно писать не только на JS, но и на TS. Для этого нужны дополнительные пакеты:

```
npm i -D typescript ts-loader ts-node @types/node @types/webpack
```

И еще пакет для типизации плагина `webpack-dev-server`:

```
npm i -D @types/webpack-dev-server
```

P.S. При установке этого пакета появилось сообщение, что ставить его отдельно не надо - он устанавливается вместе с самим дев-сервером. TODO: потом проверить, так ли это и удалить отсюда, если оно рили не надо.

### Дополнения к конфигу TS'а

К конфигу самого typescript'а `tsconfig.json` нужно добавить некоторые опции:

```yaml
{
  "compilerOptions": {
    "outDir": "./build/",
    "noImplicitAny": false,
    "module": "ESNext",  # <-- Изменить на ESNext
    "target": "es5",
    "jsx": "react",
    "allowJs": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,  # <-- Добавить это
    "esModuleInterop": true  # <-- Это
  },
  "ts-node": {  # <-- И это
    "compilerOptions": {
      "module": "CommonJS"
    }
  }
}
```

TODO: что они делают? Прочитать про систему модулей поподробнее, что за ESNext?

### Синтаксис конфига на ts

Переписанный на ts конфиг вебпака выглядит примерно так:

```typescript
import path from 'path';  // <-- Синтаксис импортов.
import HtmlWebpackPlugin from 'html-webpack-plugin';
import webpack from 'webpack';

type Mode = "development" | "production";  // <-- Создадим отдельный тип для возможных значений режима сборки.

interface EnvVariables {  // <-- Все доступные переменные окружения оформим через интерфейс.
  mode: Mode
}

export default (env: EnvVariables) => {  // <-- Эскпортируем функцию, возвращающую конфиг.
  const config: webpack.Configuration = {  // <-- Переменная с конфигом.
    mode: env.mode ?? "development",
    // Остальная часть конфига
  };

  return config;  // <-- Возвращаем конфиг.
};
```

## Вариативность настроек и значения по умолчанию

Можно сделать так, чтобы какие-то плагины \ настройки применялись по умолчанию или имели разные значения в зависимости от режима (прод \ дев). Делается это с помощью тернарного оператора и `??` (оператор нулевого слияния):

```typescript
export default (env: EnvVariables) => {
  const isDev = env.mode === "development";
    
  const config: webpack.Configuration = {
    mode: env.mode ?? "development",  // <-- Если режим не передан, по умолчанию будет development.
    plugins: [
      new HtmlWebpackPlugin({
        template: path.resolve(__dirname, "./public/index.html")
      }),
      isDev ? new webpack.ProgressPlugin() : undefined  // <-- Если режим prod, плагин не используется.
    ].filter(p => p !== undefined),  // <-- Убираем undefined'ы, оставляем только плагины.
    devServer: isDev ? {
      port: env.port ?? 3000,
      open: true
    } : undefined
    // Остальная часть конфига
  };

  return config;
};
```

Где-то значения undefined не допустимы и их надо в итоге отфильтровывать. Например, в массиве плагинов. А где-то значение undefined является нормальным. Например, в качестве значения для devServer. Так что надо в каждом конкретном случае смотреть, что допустимо, а что нет.

# Секции конфига

## Режим билда (mode)

Режим, определяющий, какие оптимизации и плагины будет использовать вебпак при билде. Какие оптимизации бывают - можно посмотреть [тут](https://webpack.js.org/configuration/optimization/).

```javascript
module.exports = {
  mode: "production"
}
```

Возможные значения mode:

* `production` - режим прода. Примеры применяемых оптимизаций:
  * Минификация.
* `development` - режим разработки. Примеры применяемых оптимизаций:
  * TODO
* `none` - вебпак не будет использовать никакие оптимизации при билде.

## Точка входа (entry)

Точка входа - главный файл, с которого начинается программа. Вебпак строит *граф зависимостей*, начиная с точки входа. Может быть несколько файлов-точек входа, но в большинстве случаев он только один. Задается параметром `entry`:

```javascript
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, './src/index.ts')  // <-- Главный файл программы, "точка входа".
}
```

`__dirname` - глобальная константа Node, указывает на директорию, в которой находится файл, где она используется. В данном случае она указывает на директорию, в которой лежит webpack.config.js

TODO: что такое граф зависимостей в данном случае?

## Таргет директория (output)

Секция для указания, куда складывать итоговые файлы, сгенерированные вебпаком. Задается параметром `output`:

```javascript
const path = require('path');

module.exports = {
  output: {  // <-- Секция для настроек таргет-директории
    path: path.resolve(__dirname, 'dist'),  // <-- Директория, в которую сложить итоговые файлы.
    filename: '[name].[contenthash].js',  // <-- Имя файла ("бандла"), в который все запакуется при сборке проекта.
    clean: true,  // <-- Очищать таргет-директорию перед каждым билдом.
  },
}
```

### Путь до целевой директории

* `path` - целевая директория, куда складывать сгенерированные файлы.

### Имя бандла

* `filename` - имя главного файла, получаемого после сборки. Этот файл называется *бандл*. Браузер кэширует его, поэтому может получиться так, что после очередной сборки он будет использовать старую версию. Поэтому обычно имя бандла делают не статическим, а динамическим. Для этого есть шаблоны (полный список - в [документации](https://webpack.js.org/configuration/output/#template-strings)):

  * `[name]` - имя файла, по умолчанию вебпак называет его main.
  * `[contenthash]` - берется хэш содержимого файла.

  Шаблоны можно комбинировать, например `[name].[contenthash].js`

### Очистка целевой директории

* `clean` - true \ false, надо ли очищать целевую директорию перед каждым билдом. Работает, начиная с 5 версии вебпака. До 5 версии надо использовать плагины, например clean-webpack-plugin.

## Плагины (plugins)

Расширяют возможности вебпака. В начале модуля импортируем классы плагинов, создаем экземпляры плагинов и помещаем эти экземпляры в массив plugins. Список наиболее часто используемых плагинов из официальной документации можно посмотреть [тут](https://webpack.js.org/plugins/). Работа с конкретными плагинами - в отдельных конспектах.

На примере плагина HtmlWebpackPlugin, который нужен, чтобы при сборке автоматически подключать бандл к html-файлу:

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  ...
  plugins: [
    new HtmlWebpackPlugin({  // <-- Создаем экземпляр прямо на месте.
      template: path.resolve(__dirname,"./src/templates/index.html")
    })
  ]
};
```

Или:

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

const htmlWebpackPlugin = new HtmlWebpackPlugin({  // <-- Создаем экземпляр заранее.
  template: path.resolve(__dirname,"./src/templates/index.html")
});

module.exports = {
  ...
  plugins: [
    htmlWebpackPlugin  // <-- Меньше места занимает, выглядит компактнее.
  ]
};
```

## Лоадеры

Лоадеры настраиваются в секциях конфига `module` и `resolve`. TODO: выяснить, как именно, в частности как формируется цепочка лоадеров? Улби говорил, важна последовательность.

```javascript
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.tsx?$/,  // <-- Регулярка, которая отбирает нужные файлы.
        use: 'ts-loader',  // <-- Каким лоадером обрабатывать файл.
        exclude: /node_modules/,  // <-- В каких директориях не надо искать файлы.
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],  // <-- Расширения файлов, которые нужно обрабатывать. ??? Мб это и есть цепочка?
  }
};
```

Полезное: сайт https://regex101.com/ для составления и тестирования регулярок.