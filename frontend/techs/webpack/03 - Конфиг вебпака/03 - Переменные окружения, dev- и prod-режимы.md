



# Переменные окружения

При запуске скриптов через консоль, мы можем передавать в конфиг вебпака параметры. Например, указать режим сборки и директорию, в которую складывать артефакты сборки:

* Произвольные параметры передаются через ключ `--env`, например  `--env параметр=значение`. 
* Параметры, известные вебпаку (например, mode) можно передать просто через `--имяПараметра=значение`.
* Передавать можно сколько угодно параметров.
* Если значение содержит пробелы, запятые, и т.д., нужно взять его в кавычки, например `--env message="Hello, webpack!"`.

Пример:

```
npm run build -- --mode=development --env targetDir="dist" someMessage="Hello, webpack!"
```

> Нюанс: предварительный `--` нужен только при использовании npm. Почему - см. дальше.

# Как настроить

## Описание параметров в скрипте, package.json

Параметры можно задать прямо в скриптах. Это позволяет сделать несколько скриптов с предварительными настройками для удобства сборки, например:

```yaml
# Файл package.json
{
  # Остальная часть конфига
  "scripts": {
    "build": "webpack",  # Сборка без параметров
    "build:dev":  "webpack --mode=development --env targetDir=dist",  # Сборка в dev-режиме
    "build:prod": "webpack --mode=production  --env targetDir=dist"   # Сборка в prod-режиме
  }
}

```

Теперь можно просто запускать скрипт `npm run build:dev` и он запустится с описанными значениями.

## Передача параметров при запуске скрипта

Параметры можно задать \ переопределить непосредственно при запуске скрипта:

```
npm run build:dev -- --mode=production --env targetDir=bld --port=3000
```

Здесь мы переопределили параметры mode и targetDir, и передали дополнительный параметр port.

> Нюанс: при использовании npm нужно использовать дополнительный `--`, потому что иначе npm подумает, что первый параметр предназначен именно ему, а не вебпаку, и будет ошибка.

## Получение значений параметров в webpack.config.js

Чтобы получить значения параметров в конфиге вебпака, мы должны экспортировать из него функцию с двумя параметрами. Функция возвращает объект конфига. Переданные при запуске скрипта значения параметров появляются в качестве полей параметров функции. env-параметры появляются в полях первого параметра, а отдельные параметры - в полях второго параметра.

Пример запуска скрипта с тремя параметрами:

```
npm run build -- --mode=production --env targetDir=bld --port=3000
```

Получаем в конфиге вебпака эти значения:

```javascript
// Файл webpack.config.js
const path = require('path');

module.exports = (settings, argv) => {  // <-- Экспортируем не объект, а функцию с двумя параметрами.
  console.log(settings.port);  // <-- Переданные через --env параметры становятся полями первого параметра функции.

  // <-- Можно анализировать полученные значения параметров и предпринимать разные дополнительные действия.
  if (argv.mode === "development") {
    console.log("Сборка запущена в режиме разработки.");
  } else if (argv.mode === "production") {
    console.log("Сборка запущена в режиме продакшена.");
  }

  return {  // <-- Функция возвращает объект конфига.
    mode: argv.mode,  // <-- "Не-env" параметры становятся полями второго параметра функции.
    entry: './src/index.js',
    output: {
      filename: 'main.js',
      path: path.resolve(__dirname, settings.targetDir),  // <-- targetDir=bld
      clean: true
    }
  }
}
```

# Значения по умолчанию

Если мы используем в конфиге какой-то параметр, при этом он не описан в скрипте и при запуске скрипта этот параметр не указали, то он получит значение undefined. На этот случай полезно добавлять таким параметрам значения по умолчанию.

```yaml
# Файл package.json
{
  "scripts": {
    "build": "webpack --mode=development"  # <-- Если для mode не передать значение, будет development.
  },
}
```

А вот если вдруг не передать для `targetDir`, то будет undefined:

```
npm run build --mode=development targetDir="dist"  // Представим, что пропустили параметр targetDir
```

На этот случай укажем для targetDir значение по умолчанию в конфиге вебпака с помощью оператора нулевого слияния `??`:

```javascript
const path = require('path');

module.exports = (settings, argv) => {
  return {
    mode: argv.mode,  // <-- У этого всегда будет значение, т.к. он описан в скрипте.
    entry: './src/index.js',
    output: {
      filename: 'main.js',
      path: path.resolve(
        __dirname, settings.targetDir ?? 'dist'  // <-- Если targetDir не указано, использовать "dist"
      ),
      clean: true
    },
  }
};
```

# Dev- и Prod-режимы

Режимы сборки отличаются не просто для красного словца. Большинство плагинов ориентируются на режим и в зависимости от него включают \ отключают разные оптимизации, параметры, удобства отладки и т.д. Правильное выставление корректного режима может значительно ускорить \ замедлить сборку и упростить \ усложнить отладку.

Как правильно установить режим:

* При запуске скрипта использовать параметр `--mode`, а не собственный кастомный:

  ```yaml
  "build": "webpack --mode=development"  # Правильно
  ```

  ```yaml
  "build": "webpack --env mode=development"  # НЕ правильно
  ```

  Дело в том, что при использовании `--mode` вебпак автоматически устанавливает значение режима в свойство `process.env.NODE_ENV`. Другие плагины и компоненты узнают режим именно по этому свойству.

  > Информация взята [здесь](https://webpack.js.org/guides/production/#specify-the-mode). Там сказано, что вебпак делает это через DefinePlugin. Самостоятельно плагин подключать не обязательно, работает и так. Не знаю, означает ли это что вебпак, например, подключает какие-то плагины автоматически или нет, но факт остается фактом - в webpack 5 версии при установке `--mode` заодно автоматически устанавливается и `process.env.NODE_ENV`. Можно в этом убедиться, если в программе (не в конфиге вебпака, а именно в программе, из которой собирается бандл), выполнить `console.log("process.env.NODE_ENV: " + process.env.NODE_ENV);`