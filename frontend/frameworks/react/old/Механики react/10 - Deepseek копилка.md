# Предисловие

Вся информация из этого файла составлена на основе разговоров с deepseek. В ней могут быть неточности и ошибки.

# React и реальный интерфейс

Как реакт связан с реальным интерфейсом, т.е. интерфейсом, который пользователь видит на экране своего монитора, телефона, планшета?

С помощью реакта мы описываем интерфейс. Можно назвать его `виртуальным интерфейсом`, который реакт потом переводит в реальный интерфейс. Концептуально, виртуальный интерфейс - это что-то вроде описания "тут поле ввода текста, тут картинка, а тут - кнопка". Технически это конечно все сложнее, виртуальный интерфейс - это сложная структура данных, которая содержит всю информацию, необходимую для построения реального интерфейса.

Если рассматривать реакт как систему, состоящую из разных частей, то некоторые части зависят от конкретной платформы (браузер, андроид), а некоторые - не зависят.

Независиящие от платформы части формируют `ядро реакта`. Ядро сформировано из функциональности, которая относится к виртуальному интерфейсу. Например, в основе абсолютно любого реакт приложения лежит концепция построения интерфейса из компонентов. А у компонентов есть пропсы, состояние и т.д. Вот подобные вещи, которые относятся как бы к реакту в целом, формируют ядро.

Платформо-зависимая часть формируется из функциональности, которая отвечает за создание реального интерфейса на основе виртуального. У каждой нативной платформы есть свои примитивы интерфейса. Например, в браузере это HTML-теги, а в андроиде - вьюхи, картинки, текст и т.д. ReactDOM - это библиотека, которая умеет создавать реальный интерфейс для браузера. React Native - это фреймворк, который умеет создавать реальный интерфейс для андроида. Т.е. ReactDOM и React Native являются платформо-зависимыми частями системы реакта. Они строят реальный интерфейс на основе виртуального.

# Компоненты, элементы, fiber-узлы

В реакте компонент является одним из базовых понятий. Есть примитивы интерфейса, вроде полей ввода, кнопок, меток, контейнеров (div например). Мы комбинируем эти примитивы в более осмысленные фрагменты интерфейса и вот эти фрагменты и называются компонентами.

`Компонент` - это функция, которая в качестве результата должна вернуть JSX-разметку. JSX - это синтаксическое расширение Javascript. Все, что за ним кроется - это вызов метода `React.createElement()`. Так что после транспиляции от JSX ничего не остается.

Соответственно, метод createElement возвращает т.н. `React Element` (или просто `элемент` далее). Это объект с некоторой служебной информацией, которая поможет реакту понять, как создать реальный элемент интерфейса.

Однако компоненты в реакте могут иметь различный "обвес", например, состояние, плюс с компонентом могут быть связаны дополнительные действия ("эффекты", например отправка запроса куда-нибудь на сервер для получения данных).

Поэтому реакт из элементов формирует т.н. fiber-узлы. `Fiber-узел` - это более сложный объект, чем элемент. Он содержит еще больше служебной информации. Например, ссылку на родительский компонент, ссылки на соседей, ссылки на дочерние компоненты, список состояний компонента и т.д. и т.п.

Т.о., описанный нами компонент в итоге превращается в fiber-узел, а из fiber-узлов формируется Fiber-дерево. Fiber-узел и компонент в целом можно считать синонимами. Просто "компонент" - это что-то более концептуальное, а "fiber-узел" - более техническое.

# Fiber-дерево

`Fiber-дерево` - это и есть тот самый "виртуальный DOM", структура данных, на основе которой реакт строит реальный интерфейс.

Fiber-дерево состоит из fiber-узлов.

Во время работы приложения существует два Fiber-дерева - `Current tree` ("текущее" дерево) и `Work-in-progress tree` (wip дерево или "новое"). После первого рендера реакт формирует первую версию дерева и она становится текущим деревом. Когда состояние какого-то компонента меняется, то происходит повторный рендер, в результате которого получается новая версия дерева. Далее реакт сравнивает новое дерево со старым, находит отличия, применяет изменения в реальный дом и новое дерево становится текущим, а старое выбрасывается.

# Рендер, реконсиляция

## Понятие рендера

`Рендер компонента` означает вызов функции компонента. Результатом рендера компонента является реакт элемент (React Element, результат вызова метода React Element).

`Рендер приложения` - это по сути тоже рендер компонента, а точнее - корневого компонента приложения. Поскольку SPA обычно состоит из корневого компонента App, в который вложены все остальные компоненты, то рендер приложения подразумевает рендер App, т.е. вызов функции App. Но поскольку в App вложены другие компоненты, то их рендер - это вызов их функций. Получается вложенный вызов функций - функция App сделает возврат только когда сделают возврат все функции, вызванные в ней. Тут важно помнить, что "вызов функции компонента" по сути заканчивается вызовом метода React.createElement(), в который вложены другие вызовы React.createElement().

В результате такого рекурсивного вызова получается дерево React Element'ов для всего приложения целиком. Т.е. можно сказать, что итог рендера приложения - это дерево React Element'ов для всего приложения целиком.

Из этого дерева элементов реакт потом создает Fiber-дерево.

## Первичный рендер

`Первичный рендер` предполагает рендер приложения целиком, т.е. рендер корневого компонента. В результате такого рекурсивного вызова получается дерево React Element'ов для всего приложения целиком. 

При первичном рендере реакт обходит это дерево элементов с корня и для каждого элемента строит fiber-узел. В результате получается первая версия Fiber-дерева для всего приложения и она становится текущей.

P.S. Технически, первый fiber-узел формируется не для корневого элемента, а для самого глубокого дочернего. Т.е. fiber-дерево строится от листьев к корню, из-за рекурсивного обхода дерева элементов. Реакт рекурсивно доходит до самого нижнего дочернего элемента, строит для него fiber-узел C1, далее по рекурсии подъем на вызов вверх, там строится fiber-узел для текущего элемента P1, они с C1 связываются и т.д.

## Повторные рендеры

Когда в каком-то компоненте происходит изменение состояния, это может означать, что требуется внести изменения в реальный DOM. Не обязательно, но может. Это реакту предстоит выяснить. Например, у игрока осталось мало здоровья и требуется покрасить фон в красный.

Когда изменяется состояние какого-то компонента, то это логичным образом означает, что изменения реального интерфейса будут находиться где-то в конкретном месте, за которое отвечает этот компонент. Значит, нет необходимости перерисовывать вообще весь интерфейс. Нужно вычислить только нужное место и локализованно провести изменения в нем.

Так вот, при изменении состояния компонента реакт помечает этот компонент как "грязный" (этот флаг находится в fiber-узле) и запускает `повторный рендер`.

Повторный рендер запускается так: реакт передает в `планировщик` (scheduler) родительский узел грязного узла (да, не сам грязный узел, а именно его родителя) и указывает приоритет этого рендера. Приоритет определяется на основании того, откуда была вызвана функция изменения состояния. Например, если из пользовательского события (клик, изменение поля ввода и т.д.), тогда приоритет высокий. Если, например, из setTimeout или промиса, тогда приоритет низкий.

Планировщик на основе приоритетов определяет, какой рендер более важный, и запускает рендер соответсвующего компонента. Если у нескольких рендеров приоритет одинаковый, то они обрабатываются по принципу FIFO.

~~Т.о. при повторном рендере реакт начинает обход текущего Fiber-дерева с родителя грязного элемента (а не с самого корня всего Fiber-дерева), с целью сформировать новую версию дерева (wip). Если текущий fiber-узел "чистый", тогда реакт просто помещает ссылку на него в новое дерево. Это позволяет как бы переиспользовать те узлы, в которых не было изменений. А если узел "грязный", тогда реакт повторно вызывает функцию компонента и из полученного элемента формирует новый fiber-узел и вставляет его в новое дерево. Реакт вызывает функцию грязного компонента сразу же, как его находит (т.е. нет такого, что он сначала ищет все грязные узлы, а потом только начинает выполнять функции - он вызывает их сразу).~~

Т.о. при повторном рендере реакт начинает обход текущего Fiber-дерева с родителя грязного элемента.

TODO...

Потом реакт обходит соседей родителя грязного элемента, потом родителя этого родителя и т.д. Т.е обходит оставшуюся часть Fiber-дерева, чтобы найти чистые узлы и скопировать их.

TODO: а может быть так, что он найдет в процессе этого обхода и другие грязные узлы, которые относятся к другому рендеру?

[, с целью сформировать новую версию дерева (wip). Если текущий fiber-узел "чистый", тогда реакт просто помещает ссылку на него в новое дерево. Это позволяет как бы переиспользовать те узлы, в которых не было изменений. А если узел "грязный", тогда реакт повторно вызывает функцию компонента и из полученного элемента формирует новый fiber-узел и вставляет его в новое дерево. Реакт вызывает функцию грязного компонента сразу же, как его находит (т.е. нет такого, что он сначала ищет все грязные узлы, а потом только начинает выполнять функции - он вызывает их сразу).]

P.S. Проверка на грязь осуществляется сверху вниз, т.е. первым на грязь проверится корень. А то из-за всех этих ситуаций с рекурсией можно было бы подумать, что и тут порядок инвертированный. Но нет, тут прямой, сверху вниз.

Если грязный узел имеет дочерние узлы, это автоматически подразумевает, что они тоже отрендерятся повторно, даже если они чистые. Все потому, что рендер - это просто вызов функции. Соответственно, если вызвать функцию компонента, у которого есть вложенные компоненты, то их функции тоже вызовутся. Однако надо помнить, что рендер - это получение элемента. А формирование fiber-узла - это отдельная операция. 

Так что после рендера грязного узла реакт получает новое поддерево элементов (именно элементов, а не fiber-узлов!). Далее он начинает сравнивать эти элементы с fiber-узлами из старого дерева. Он может сравнивать React Element с fiber-узлом, потому что оба этих объекта имеют некоторые общие поля, например type и key. Если реакт видит, что у элемента тип совпадает с типом узла, и узел чистый, то значит можно просто взять этот узел и встроить в новое дерево. Если же узел грязный или типы элемента и узла не совпадают, тогда реакт формирует новый fiber-узел из элемента и встраивает именно этот новый узел в новое дерево.

Этот процесс сравнения происходит рекурсивно, т.е. по сути сравнение нового дерева элементов с соответствующми fiber-узлами происходит от дочек к родителям, т.е. снизу вверх. TODO: тут есть хороший вопрос, как именно реакт понимает позиционку элементов в случае, когда новое поддерево элементов сильно отличается по форме от старого, но это уже надо разбираться в рекурсии и как работают деревья. Для понимания сути в данном случае это как будто не важно.

Т.о., в процессе повторного рендера задачей реакта является обойти все дерево с корня, найти грязные узлы и сделать их рендер повторно. В итоге получается новая версия дерева. Затем эту новую версию надо сравнить со старой, найти реальные отличия и если они есть, то отразить их в реальном интерфейсе. Поиск отличий называется реконсиляция.

## Реконсиляция

Когда в результате повторного рендера реакт сформировал новую версию дерева, ему предстоит найти отличия между новой и старой версией. Процесс поиска отличий называется `реконсиляция` (reconciliation). 

Реакт обходит оба дерева и сравнивает соответствующие fiber-узлы из старого и нового дерева. Если узел был чистый, то ссылка на него просто была скопирована в новое дерево. Соответственно, чистые узлы реакту сравнивать проще всего - если он видит, что ссылка одинаковая, значит нет нужды проводить глубокое сравнение - и так понятно, что узлы идентичны. Если же ссылки разные, значит узел был грязный и сформирован заново, поэтому надо подробно сравнить новую версию узла со старой версией. Подробное сравнение включает в себя, например, сравнение состояний и пропсов в старом узле и новом.

После подробного сравнения реакт может выяснить, что фактически ничего не изменилось. Например, в состоянии Age стояла цифра 30, и ее опять изменили на 30. Т.е. технически изменение состояния было, а фактически - нет. В этом случае реакт понимает, что реальный интерфейс менять не надо.

Если же фактические изменения все-таки есть, например, возраст поменяли на 35, тогда уже реакт думает, какие методы DOM API нужно вызвать, чтобы отобразить эти изменения состояния в реальном интерфейсе. Он подбирает минимальный набор команд и выполняет их, изменяя таким образом реальный интерфейс. Это называется `коммит в DOM`.


