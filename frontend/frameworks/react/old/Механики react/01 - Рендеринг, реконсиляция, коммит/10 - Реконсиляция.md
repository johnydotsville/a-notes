



- [ ] Как реакт обрабатывает изменение состояний компонентов.
  - [ ] Если мы используем в компоненте useState или прочие хуки, они при рендере компонента запоминают ссылку на созданный fiber-узел.
    - [ ] Поэтому когда меняется состояние компонента, реакт помечает узел флагом didUpdate и ставит обновление в очередь.
      - [ ] Каждый узел - это объект, в котором есть свойство под очередь обновлений. Когда меняется состояние компонента, то в эту очередь кладется объект обновления - там функция обновления и все остальное, что нужно. Т.о. у каждого узла своя очередь обновления.





- [ ] Fiber-дерево одно. Когда говорят "текущая" версия дерева и "новая", это все логическая метафора. Дерево одно.
  - [ ] Но каждый узел имеет в свойстве alternate ссылку на свою "альтернативную" версию.
    - [ ] Реакт обходит дерево с корня.
    - [ ] Если он встречает didUpdate-узел, то он создает новый узел и кладет его в alternate. А этому новому в alternate кладет didUpdate-узел. Получается они имеют ссылку друг на друга. didUpdate-узел можно называть current-узел, т.е. как бы "текущий" (или "старый"), а второй узел - это wip-узел, т.е. как бы "новый".
      - [ ] Если это не первый обход и в alternate уже есть узел, то новый не создается, а просто работа идет с уже созданным.
    - [ ] Реакт проверяет current-узел, чтобы понять что в нем изменилось, а что нет.
    - [ ] То, что не изменилось - копируется в wip-узел как есть. То, что изменилось - вычисляется по новой и эта новая версия кладется в wip-узел.
      - [ ] Допустим, у компонента два состояния - name и surname. name - не изменилось, а surname - изменилось.
        - [ ] Тогда ссылка на объект name-состояния попадает в wip-узел. Получается, что как бы переиспользовали уже имеющееся состояние.
        - [ ] surname изменилось, значит создается новый объект состояния и он попадает в wip-узел.
    - [ ] Далее wip-узел сравнивается с current-узлом для вычисления "реальных" изменений.
      - [ ] Например, технически surname изменилось (ввели новую фамилию), но фактически осталось старым (ввели то же самое). В этом случае никаких реальных изменений не требуется.
    - [ ] Если "реальное" изменение есть, то реакт ставит узлу флаг, символизирующий, какое именно изменение нужно (например, удаление, добавление, обновление) и ставит узел в список effectsList.
      - [ ] Этот список хранится в корне дерева. Поскольку он плоский, его легко будет обойти на этапе коммита, когда все эти изменения будут реально применяться.
    - [ ] На этапе коммита реакт обходит этот плоский список, анализирует флаги и трансформирует их в реальные DOM-команды.









