# Контекст

Контекст позволяет в родительском компоненте определить какое-нибудь значение и если это значение понадобится в любом из вложенных компонентов, то они смогут его взять из контекста. Уровень вложения не важен и нам не придется прокидывать это значение глубоко через пропсы.

> Контекст не заменяет Redux. Редакс это про управление состоянием, а контекст больше именно про общее пользование какими-то данными в пределах компонента.

# Объект контекста и провайдеры

Базовая работа с контекстом сводится к следующим шагам:

* С помощью функции `createContext()` мы создаем `объект контекста`. При создании можем передать дефолтное значение для контекста.
* Определяемся, какой компонент у нас будет устанавливать значение для контекста. Обычно это какой-то родительский компонент, которому хочется, чтобы это значение было доступно всем его потомкам на всех уровнях вложенности.
  * У объекта контекста есть свойство `Provider`.  В нем лежит компонент, который называется `провайдер`. С помощью его атрибута `value` мы задаем значение для контекста.
  * Вкладываем все свои компоненты, в которых хотим получить это значение, внутрь этого компонента.
* В компоненте, где надо получить значение из контекста, используем хук `useContext()`. Передаем ему объект контекста и он нам извлекает из него значение. Использованием этого хука мы не только извлекаем значение из контекста, но и подписываемся на его обновление. Когда значение изменится, реакт пере-рендерит все компоненты, которые этим значением пользуются.

Пример:

```react
import {createContext} from 'react';
import {useContext} from 'react';

const FoobarContext = createContext('Hello, context! This is default context value.');

export default function App() {
  return (
    <>
      <FoobarContext.Provider value={'Hello, world!'}>
        <Message />
      </FoobarContext.Provider>
      <Message />
      <FoobarContext.Provider value={'Goodbye, borderline!'}>
        <Message />
      </FoobarContext.Provider>
    </>
  );
}

function Message() {
  const value = useContext(FoobarContext);
  return (
    <p>{value}</p>
  );
}
```

В этом примере первый компонент Message, вложенный в компонент FoobarContext.Provider, выведет сообщение "Hello, world!". Второй компонент Message, который не вложен в контекст, а находится сам по себе, выведет сообщение "Hello, context! This is default context value.". Это происходит потому, что второй Message будет искать провайдера вверх по дереву и, не обнаружив его, получит дефолтное значение, которое мы указали при создании контекста. Третий компонент Message выведет сообщение "Goodbye, borderline!", потому что он завернут уже в другой провайдер. Т.о. мы можем на одном и том же контексте создавать несколько провайдеров, каждому из них ставить нужные значения, и получать к ним доступ из вложенных в провайдер компонентов.

Это две базовых механики контекста:

* При чтении контекста идет поиск вверх по дереву до *ближайшего* провайдера.
  * Этот факт позволяет нам в любом вложенном компоненте переопределить значение. Достаточно просто в этом компоненте снова использовать провайдер, указав ему другое значение. Это будет не перезапись значения, а просто новый экземпляр провайдера с новым значением. И поскольку он будет ближе к далее вложенным компонентам, то они возьмут значение из него.
* На одном объекте контекста мб несколько провайдеров и в каждом уникальное значение.

P.S. Объект контекста можно было бы создать в отдельном файле, а потом импортировать. Просто для краткости и наглядности сделал все в одном файле.

# Советы по контексту

Контекст несколько затрудняет восприятие и снижает читаемость. Поэтому есть несколько советов перед тем, как использовать контекст:

* Сначала попробовать передавать пропсы, даже если их много и они передаются сквозь много компонентов. Возможно, в итоге все будет выглядеть не так уж плохо.
* Внимательнее посмотреть, можно ли извлечь дополнительные компоненты. Бывает так, что компоненты сами не пользуются пропсами, а просто прокидывают их дальше. В этом случае можно просто передавать children или воспользоваться оператором расширения.

Когда контекст хорошо подходит:

* Темы. Если у приложения несколько визуальных тем, есть смысл положить текущую тему в контекст, а в компонентах получать значение темы и на основе этого корректировать их внешний вид.
* Текущий пользователь.
* Управление состоянием, которое требуется по всему приложению и находится почти у самого верха.