TODO: вот отсюда https://habr.com/ru/articles/541320/ выписать понятные на данный момент требования, вроде "размещать вспомогательные функции вне компонента", "Называть компоненты с большой буквы" и т.д.

# Компонент

## Концепция компонента

Интерфейс строится из набора маленьких блоков - полей ввода, кнопок, картинок и т.д. *Компонент* - это одна из основных концепций реакта. Компонент может быть как совсем простым, например состоять из одной кнопки, так и более сложным, например, объединять множество полей ввода, кнопок в какую-нибудь анкету. Несколько компонентов могут комбинироваться друг с другом и формировать еще более сложные компоненты и т.д. Т.о. компонент - это переиспользуемый элемент пользовательского интерфейса.

## JSX

Любой компонент возвращает JSX-разметку. JSX - это синтаксическое расширение Javascript'а, которое содержит аналоги почти всех HTML-тегов и позволяет удобным образом писать HTML-подобную разметку прямо в компоненте, вместо того чтобы возиться с объектами. Потом реакт преобразует эту разметку в настоящий HTML. По JSX есть отдельный конспект.

## Функциональный компонент

Функциональный компонент - это функция, которая возвращает jsx. Особенности и требования:

* Функция может быть как обычной, так и лямбдой. Обычно используются лямбды или Function Declaration.
* Название компонента (функции, переменной) нужно обязательно писать с большой буквы, иначе работать не будет.
* Нельзя вкладывать *объявления* компонентов друг в друга. В JS мы можем объявлять одну функцию внутри другой, следовательно и компонент можем описать внутри другого компонента. Делать так не надо. Каждый компонент объявляется на верхнем уровне файла.
* Вспомогательные функции следует размещать вне компонента, на верхнем уровне, а требуемые данные передавать им в качестве параметров. Это позволяет минимизировать код компонента, делая его более наглядным и доступным для понимания.

Примеры объявления функционального компонента:

```react
const Hello = () => {  // <-- Лямбда
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
function Hello() {  // <-- Function Declaration
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

```react
const Hello = function() {  // <-- Function Expression
  return (
    <h1>Привет, мир!</h1>
  );
};

export default Hello;
```

## Классовый компонент

Описание компонентов через классы является устаревшим подходом и рекомендуется пользоваться функциональными компонентами. Особенности классовых компонентов:

* Класс должен наследоваться от класса `React.Component`.
* Конструктор должен принимать параметр props и передавать его в родительский конструктор. Что такое пропсы - в отдельном конспекте.
* Класс должен иметь метод `render()`, который возвращает jsx.

```react
import React from 'react';

class Hello extends React.Component {

  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Привет, мир!</h1>
    );
  }

}

export default Hello;
```

## Особенности оформления

Несколько хороших практик и технических замечаний о компонентах:

* Обычно придерживаются правила "один файл - один компонент" и называют файл и компонент одинаково.
  * Расширение у файла может быть `.jsx`, `.js` TODO: и наверняка какое-нибудь связанное с typescript.
  * Технически, в одном файле можно расположить несколько компонентов. Подробнее о том, как это сделать и зачем, в конспекте про экспорт \ импорт компонентов.
* Возвращаемая из компонента JSX-разметка:
  * Должна быть завернута в единый блок, например `<div>` или `<Fragment>` (`<>`) и т.д. Это связано с тем, что каждый JSX-тег трансформируется в обычный JS-объект, а значит вернуть несколько тегов, не завернутых в единый тег, равносильно тому, что попробовать вернуть из функции несколько независимых значений.
  * Для удобства можно брать разметку в круглые скобки `return ( разметка )`. Это позволяет оформлять разметку на нескольких строках и не бояться багов, связанных с автоматической расстановкой js-ом точек с запятой.
* Компоненты всегда оформляются на верхнем уровне. Не надо оформлять их в виде вложенных функций. Это приводит к багам (подробнее - в конспекте по механикам изменения и сохранения состояния).

## Чистые компоненты

Компоненты в реакт строятся по принципу чистой функции (pure function).

Чистая функция это функция, которая:

* Выдает один и тот же результат, если получает одни и те же аргументы. Т.е. выход зависит исключительно от входа.
* Не имеет сайд-эффектов. Примеры сайд-эффектов: чтение \ запись в БД, отправка HTTP-запросов, работа с файловой системой. Т.е. каждый очередной вызов функции не должен сопровождаться какими-то действиями, которые могут привести к неочевидным последствиям. Чистая функция принимает аргументы, обрабатывает их и после ее работы все "вокруг" остается как было, как будто функцию вообще не вызывали. Благодаря этому чистые функции можно вызывать повторно сколько угодно раз, не боясь, что это повлияет на какие-то вещи, не касающиеся непосредственно вычислений.

# Состояние компонента

## Функциональный компонент

### Хук useState

```react
import {useState} from 'react';
```

Состояние компонента - это некоторые данные, которые компонент использует. Например, состоянием компонента  "Анкета" может быть имя человека, профессия, дата рождения.

Работа с состоянием компонента начинается с вызова функции-хука `useState(начальное_состояние)`. Мы передаем в нее значение \ объект, который хотим использовать в качестве начального состояния, а она нам возвращает переменную, содержащую это состояние, плюс функцию для его изменения.

```react
const [состояние, функцияДляИзмененияСостояния] = useState(5);
const [login, setLogin] = useState('neofit');
```

Теперь, чтобы изменить состояние компонента, мы вызываем полученную от хука функцию, передавая в нее новое значение состояния. Вручную переменную состояния мы не изменяем, потому что в этом нет смысла, ибо реакт эти изменения не увидит, а используем ее для чтения состояния и формирования нового состояния на основе текущего. Т.о., состояние мы всегда воспринимаем как иммутабельное значение, которое можно заменить, но не изменить. Имя для функции изменения состояния может быть произвольным, но лучше при именовании следовать соглашению `переменнаяСостояния`, `setПеременнаяСостояния`.

У компонента может быть много состояний, т.е. мы можем применять хук useState сколько угодно раз. Состояние не стоит воспринимать как монолитный объект, содержащий все-все-все данные, касающиеся компонента. Наоборот, данные компонента могут быть разбиты на небольшие кусочки, несколько "состояний", каждое из которых может меняться независимо.

```react
import {useState} from 'react';

const Counter = () => {
  const [count, setCount] = useState(5);  // <-- Создали состояние и получили ф-ию для его измения
  const [calls, setCalls] = useState(0);  // <-- Другое состояние, под общее число кликов по счетчику

  function increment() {
    setCount(count + 1);  // <-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
    setCalls(calls + 1);
  }

  function decrement() {
    setCount(count - 1);
    setCalls(calls + 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <h2>Общее число обращений к счетчику: {calls}</h2>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

## Классовый компонент

* В классовом компоненте состояние объявляется в конструкторе.
* Под состояние существует свойство `state`.
  * Для изменения состояния - метод `setState`.
* Все методы класса необходимо биндить, потому что теряется контекст. TODO: можно кстати почитать, почему так происходит.

```react
import React from 'react';

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // <-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // <-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // <-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={this.increment}>Увеличить</button>
        <button onClick={this.decrement}>Уменьшить</button>
      </div>
    );
  }

}

export default Counter;
```

# Советы по оформлению состояния

Несколько советов по оформлению состояния:

* Группируйте связанные состояния. Если вы обнаружили, что обычно изменяете две и более переменные состояния вместе и они логически тесто связаны, то лучше их объединить в единый объект.
* Избегайте противоречий в состоянии. Если у вас несколько состояний, значения которых могут конфликтовать, то эти состояния нужно отрефакторить, чтобы такого конфликта в принципе не могло произойти. Например, комбинация `isSending = true` и `isSent = true` является некорректной с точки зрения логики программы, потому что сообщение не может одновременно отправлять и быть уже отправленным. Пример рефакторинга - ввести состояние `status` с возможными значениями sending и sent.
* Избегайте избыточности в состоянии. Если какие-то значения можно вычислить на основе имеющихся средств (например пропсы или другие состояния), то не нужно для этих значений заводить отдельное состояние. Пример избыточного состояния: `firstname`, `lastname`, `fullname`. Здесь fullname можно вычислить на основе firstname и lastname, поэтому держать его как отдельное состояние не следует.
* Избегайте дублирования в состоянии. Не стоит использовать одни и те же данные как части разных состояний, потому что их придется держать их в согласованном виде, а это повышает вероятность ошибок. Например: список элементов и состояние `selectedItem`. Если сохранить в selectedItem непосредственно ссылку на элемент, то это плохая идея. Из-за иммутабельности, в случае изменений в выделенном элементе, нам придется заменять элемент и в selectedItem. Проще и правильнее будет сохранить в selectedItem id выбранного элемента.
* Избегайте сильной вложенности в состоянии. Старайтесь делать состояние как можно более плоским, потому что так его будет проще обновлять.

