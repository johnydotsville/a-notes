# Компонент

* Концепция компонента.
  * Компонент - это переиспользуемый элемент пользовательского интерфейса.
  * Компонент может быть
    * Простой (например, кнопка).
    * Более сложный (много полей, кнопок).
    * Еще более сложный, состоять из других компонентов разной сложности.
* Любой компонент возвращает JSX-разметку.
  * Она дб завернута в единый блок, например div или Fragment.
    * Это связано с тем, что каждый JSX-тег является объектом, а значит вернуть несколько тегов, не завернутых в единый тег, равносильно тому, что попробовать вернуть из функции несколько независимых значений.
  * Удобно обрамлять возвращаемую разметку в круглые скобки, чтобы избежать недоразумений с автоматической расстановкой точек с запятой и связанных с этим ошибок.
* Виды компонентов.
  * Функциональный.
    * Можно использовать как лямбды, так и обычные Function Declaration.
    * Нельзя вкладывать компоненты друг в друга. Каждый функциональный компонент - это функция, описанная на верхнем уровне самого модуля.
    * Вспомогательные функции-хелперы надо располагать вне компонентов, чтобы не захламлять их код.
  * Классовый.
    * Дб наследником `React.Component`
    * Конструктор должен принимать параметр `props` и передавать его родителю.
    * Должен иметь иметь метод `render()`, возвращающий JSX-разметку.
* Требования к компонентам и хорошие практики.
  * Компонент обязан называться с большой буквы, иначе работать не будет.
  * Функциональные компоненты предпочтительнее. Классовые считаются устаревшим стилем.
  * Придерживаемся правила - один файл - один компонент.
    * Технически внутри файла можно расположить несколько компонентов. Это бывает полезно, когда эти компоненты служат как хелперы для главного компонента файла. Т.о. снаружи файла они не видны.
  * Компоненты реализуются по принципу чистых функций.
* Ключ компонента.
  * Нужен, когда один и тот же компонент отрисовывается на странице много раз с разными данными.
  * Ключ дб уникальным среди соседних элементов.
  * Ключ дб статичным, т.е. его нельзя генерировать при перерисовке компонента и лучше всего, если он является частью отрисовываемых данных, например, id из БД.
  * Ключ задается компоненту через атрибут key,
    * key нет в пропсах компонента, это инфраструктурный хинт.

# Состояние компонента

## Хук useState

* Состояние компонента - это данные, которыми пользуется компонент и как правило эти данные привязаны непосредственно к нему.
* Для работы с состоянием используется хук `useState()`

  * Подключается он так `import {useState} from "react";`
* Работа с состоянием.

  * Передача в хук начального состояния.
  * Хук отдает массив.

    * В 0 индексе лежит переменная для чтения состояния.
    * В 1 индексе лежит функция для изменения состояния ("сеттер").
    * Обычно с помощью деструктуризации эти вещи кладут в две переменные.
      * По традиции им дают имена соответственно foobar и setFoobar.
  * Состояние рассматривается как иммутабельное.

    * Это значит, что изменить его нельзя. Можно только заменить целиком на другое.
    * Реакт воспринимает изменение состояния, только когда мы вызываем функцию изменения.
      * Поэтому пытаться изменять состояние через переменную бесполезно.
  * Хук useState можно применять несколько раз.

    * Состояние компонента не обязательно дб монолитным, оно может состоять из нескольких частей, изменяющихся независимо.
  * Использование состояния в классовом компоненте.

    * Т.к. считается легаси, то по мере необходимости обращаться к конспекту.

## Виды состояний, рекомендации

* Виды состояний.
  * Состояние-примитив.
  * Состояние-объект.
    * Изменять объект запрещено, только создать новый и заменить старый на него целиком.
      * Оператор разбиения ... помогает сделать это.
      * Если в поле объекта лежит другой объект, то его тоже надо разбивать.
  * Состояние-массив.
    * Добавление в конец \ начало.
      * ...
    * Удаление из массива.
      * filter
    * Изменение всех элементов.
      * map
    * Изменение одного элемента.
      * map
    * Вставка элемента в середину массива.
      * slice + ...
    * Сортировка, инверсия массива.
      * ...
  * Библиотека Immer.
* Рекомендации по оформлению состояния.
  * Группируйте связанные состояния. Если обнаруживается, что два независимых состояния приходится обновлять согласованно, и при этом они логически связаны, то это повод объединить их в один объект.
  * Избегать структуры состояния, которая провоцирует противоречия. Например, состояния isSending и isSent. Если они оба окажутся в true, получится невозможная чепуха. Такое надо рефакторить, например, ввести состояние state со значениями "sending" и "sent".
  * Избегать избыточности состояния. Если можно вычислить какие-то значения на основе имеющегося состояния, например fullname собрать из firstname и lastname, то не надо делать fullname как часть состояния.
  * Избегать сильной вложенности состояния. Держать его как можно более плоским, потому что так проще его обновлять.
  * Избегать дублирования информации в разных состояниях, потому что придется держать эту информацию в согласованном виде.

## Механика работы состояния

TODO

# Экспорт и импорт компонентов

* Экспорт.
  * Дефолтный и именованный экспорт.
    * Использование дефолтного и именованного экспорта вместе в одном файле.
    * При импорте указывать расширение не обязательно.
* Дефолтный экспорт и импорт.
  * Дефолтный экспорт через `export default`.
  * Дефолтный экспорт мб один на файл.
  * Дефолтный экспорт
    * При объявлении компонента.
    * Отдельной строкой.
  * Дефолтный экспорт компонента, объявленного через
    * Function Declaration.
    * Лямбду в переменной, default и const не дружат.
  * Импорт дефолтного компонента под любым именем.
  * Импорт дефолтного компонента синтаксисом именованного импорта `import {default as Foobar}`.
* Именованный экспорт и импорт.
  * Именованный экспорт через `export`.
  * Экспорт множества вещей через именованный экспорт.
  * Именованный экспорт
    * При объявлении компонента.
    * Именованный экспорт отдельной строкой через `{ }`
      * Экспорт компонента под другим именем `{ Foo as Bar }`.
  * Именованный импорт через `{ }`
    * Под тем же именем.
    * Под другим именем.
* Путь до компонентов
  * Относительный.
  * Абсолютный.
    * Craco.
* Правила хорошего тона
  * На экспорт только один компонент
  * Единый стиль экспорта во всех файлах
  * Компонент и файл, в котором он размещается, называем одинаково

