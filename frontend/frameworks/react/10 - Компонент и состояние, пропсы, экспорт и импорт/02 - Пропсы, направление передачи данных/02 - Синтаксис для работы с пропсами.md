# Полезный синтаксис для работы с пропсами

При работе с пропсами полезно знать возможности JS по деструктуризации объектов и как работает оператор разбиения (`...`). Эти темы разобраны в конспектах по JS, а тут просто демонстрация как они могут быть полезны в реакте.

# Деструктуризация пропсов

Пусть props имеет такую структуру:

```
{
  header,
  article: {
    title,
    author,
    content
  }
}
```

Мы вызываем компонент `Info` и передаем ему атрибуты, которые собираются в объект props:

```react
<Info header={"Важная информация"} 
      article={{title: "О наркотиках", 
                author: "Мистер Маки", 
                content: "Наркотики - эт плохо, пнятненько?"
               }}
    />
```

Внутри компонента мы можем воспользоваться деструктуризацией, чтобы не писать каждый раз `props.`:

```react
const Info = ({header, article}) => {  // <-- Деструктуризируем пропсы
  return (
    <div>
      <h1>{header}</h1>  <!-- Теперь нет нужды писать каждый раз props. -->
      <div>{article.title}</div>
      <div>{article.author}</div>
      <div>{article.content}</div>
    </div>
  );
};
```

# Проброс пропсов дальше

Иногда компоненту нужно просто "прокинуть" полученные пропсы дальше, причем получает он их единым объектом, а прокинуть нужно по-отдельности. В этом случае помогает оператор разложения.

Например, у нас есть кастомный input, который под капотом использует стандартный реактовский инпут и вся кастомизация заключается, по сути, в добавлении класса для стилизации, а остальные пропсы надо передать как есть:

```react
function CInput(props) {  // <-- Кастомный input задает класс, чтобы применились стили
  return (
    <input className="niceCustomInput" {...props} />
  );
}

export default function App() {
  return (
    <div>
      <Gallery />
      {/* Используем кастомный input, передавая ему настройки для стандартного input'а */}
      <CInput type="text" defaultValue="carter" name="login" required />
    </div>
  );
}
```

Внутри реактовский input ожидает пропсы в виде отдельных атрибутов type, defaultValue, name и required и т.д. Но CInput получает их пачкой, в props. Значит нам пришлось бы написать что-то вроде этого:

```react
function CInput(props) {
  return (
    <input className="customInput" 
           type={props.type} defaultValue={props.defaultValue}
           name={props.name} required={props.required} />
           // Либо деструктурировать props и все равно писать передачу вручную
  );
}
```

Однако в конструкции `<input className="niceCustomInput" {...props} />` с помощью оператора разложения `{...props}` мы превращаем ее по сути в такую:

```react
<input className="niceCustomInput" type="text" defaultValue="carter" name="login" required />
```

# Сбор разбитых пропсов вместе

Оператор разложения удобно использовать в комбинации с деструктуризацией. Мы можем выдрать из пропсов отдельные поля, а остальные собрать обратно в объект с помощью оператора разложения. Например:

```react
function CInput({className='niceCustomInput', ...rest}) {  // <-- Выдираем className из пропсов, а остальное собираем в rest
  return (
    <input className={className} {...rest}  />
  );
}

export default function App() {
  return (
    <div>
      <Gallery />
      <CInput type="text" defaultValue="carter" name="login" required />
    </div>
  );
}
```

Допустим, мы хотим проверить, задан ли для компонента класс и если не задан, то поставить значение по умолчанию. Для этого нам нужно извлечь из пропсов className и проверить его, однако если при деструктуризации мы укажем только className, то остальные пропсы потеряются. При этом мы достоверно не знаем, какие остальные атрибуты задаст пользователь компонента. Т.е. задача такая "проверить className, а остальное передать дальше как есть".

В этом нам опять поможет оператор разложения. Конструкция `function CInput({className='niceCustomInput', ...rest})` приведет к тому, что className извлечется из пропсов в отдельный параметр, а все остальные атрибуты (в данном примере это type, defaultValue, name, required) соберутся в параметр rest. И если окажется, что className не передали, то параметр className получит значение по умолчанию "niceCustomInput". Оставшиеся параметры мы передаем в input как есть, деструктурируя rest.