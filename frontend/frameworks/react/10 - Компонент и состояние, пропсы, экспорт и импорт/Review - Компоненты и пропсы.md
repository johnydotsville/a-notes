# Компонент

* Концепция компонента.
  * Компонент - это переиспользуемый элемент пользовательского интерфейса.
  * Компонент может быть
    * Простой (например, кнопка).
    * Более сложный (много полей, кнопок).
    * Еще более сложный, состоять из других компонентов разной сложности.
* Любой компонент возвращает JSX-разметку.
  * Она дб завернута в единый блок, например div или Fragment.
    * Это связано с тем, что каждый JSX-тег является объектом, а значит вернуть несколько тегов, не завернутых в единый тег, равносильно тому, что попробовать вернуть из функции несколько независимых значений.
  * Удобно обрамлять возвращаемую разметку в круглые скобки, чтобы избежать недоразумений с автоматической расстановкой точек с запятой и связанных с этим ошибок.
* Виды компонентов.
  * Функциональный.
    * Можно использовать как лямбды, так и обычные Function Declaration.
    * Нельзя вкладывать компоненты друг в друга. Каждый функциональный компонент - это функция, описанная на верхнем уровне самого модуля.
    * Вспомогательные функции-хелперы надо располагать вне компонентов, чтобы не захламлять их код.
  * Классовый.
    * Дб наследником `React.Component`
    * Конструктор должен принимать параметр `props` и передавать его родителю.
    * Должен иметь иметь метод `render()`, возвращающий JSX-разметку.
* Требования к компонентам и хорошие практики.
  * Компонент обязан называться с большой буквы, иначе работать не будет.
  * Функциональные компоненты предпочтительнее. Классовые считаются устаревшим стилем.
  * Придерживаемся правила - один файл - один компонент.
    * Технически внутри файла можно расположить несколько компонентов. Это бывает полезно, когда эти компоненты служат как хелперы для главного компонента файла. Т.о. снаружи файла они не видны.
  * Компоненты реализуются по принципу чистых функций.

# Состояние компонента

* Состояние компонента - это данные, которыми пользуется компонент и как правило эти данные привязаны непосредственно к нему.

* Для работы с состоянием используется хук `useState()`

  * Подключается он так `import {useState} from "react";`

* Работа с состоянием.

  * Передача в хук начального состояния.
  * Хук отдает массив.

    * В 0 индексе лежит переменная для чтения состояния.
    * В 1 индексе лежит функция для изменения состояния.
    * Обычно с помощью деструктуризации эти вещи кладут в две переменные.
      * По традиции им дают имена соответственно foobar и setFoobar.
  * Состояние рассматривается как иммутабельное.

    * Это значит, что изменить его нельзя. Можно только заменить целиком на другое.
    * Реакт воспринимает изменение состояния, только когда мы вызываем функцию изменения.
      * Поэтому пытаться изменять состояние через переменную бесполезно.
  * Хук useState можно применять несколько раз.

    * Состояние компонента не обязательно дб монолитным, оно может состоять из нескольких частей, изменяющихся независимо.
  * Использование состояния в классовом компоненте.

    * Т.к. считается легаси, то по мере необходимости обращаться к конспекту.
  * Рекомендации по оформлению состояния.
    * Группируйте связанные состояния. Если обнаруживается, что два независимых состояния приходится обновлять согласованно, и при этом они логически связаны, то это повод объединить их в один объект.
    * Избегать структуры состояния, которая провоцирует противоречия. Например, состояния isSending и isSent. Если они оба окажутся в true, получится невозможная чепуха. Такое надо рефакторить, например, ввести состояние state со значениями "sending" и "sent".
    * Избегать избыточности состояния. Если можно вычислить какие-то значения на основе имеющегося состояния, например fullname собрать из firstname и lastname, то не надо делать fullname как часть состояния.
    * Избегать сильной вложенности состояния. Держать его как можно более плоским, потому что так проще его обновлять.
    * Избегать дублирования информации в разных состояниях, потому что придется держать эту информацию в согласованном виде.

# Экспорт и импорт компонентов

* Экспорт.
  * Два вида
    * Дефолтный.
      * Можно писать сразу при объявлении компонента.
      * Можно писать отдельной строкой.
    * Именованный.
      * Можно писать только на одной строке с объявлением компонента.
  * В одном файле можно использовать одновременно оба вида экспорта.
* Импорт.
  * Синтаксис импорта зависит от того, как компонент был экспортирован, каким видом.
    * Импорт дефолтного компонента.
      * Возможен под любым именем.
    * Импорт именованного компонента.
      * 
  * При импорте можно не указывать расширение файла, это по желанию.