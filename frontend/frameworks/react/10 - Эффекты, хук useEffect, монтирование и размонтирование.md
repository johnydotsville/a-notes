# Жизненный цикл компонента

У каждого компонента свой жизненный цикл. Он состоит из трех этапов:

* Монтирование (mount) - момент появления компонента в реальном интерфейсе.
* Обновление (update) - когда изменяется состояние компонента, он перерисовывается.
* Размонтирование (umount) - момент исчезновения компонента из реального интерфейса. Например, скрытие компонента или переход на другую страницу.

# Эффекты

В компоненте есть два вида логики:

* Код рендеринга. Это код, который формирует тело функции компонента. Он должен быть чистым, т.е. не содержать сайд эффектов. Его назначение - рассчитать как должен выглядеть компонент и вернуть соответствующий JSX. Он зависит только от пропсов и текущего состояния компонента.
* Код обработчиков событий. Это функции, которые мы навешиваем на события элементов. Они меняют состояние компонента, т.е. содержат сайд-эффекты. Их особенность в том, что они вызываются исключительно при возникновении события, например, щелчок по кнопке, изменение значения в текстовом поле и т.д.

Но часто бывает необходимость, чтобы функция с сайд-эффектом выполнилась не только по щелчку кнопки или другому событию, вызванному взаимодействием пользователя с интерфейсом, а выполнилась в связи с самим фактом отрисовки компонента. Например, нужно загрузить исходные данные с сервера и отобразить в компоненте. Для этого существует третий вид логики - **эффекты**.

Эффекты выполняются после коммита компонента в дерево. Т.о., на примере загрузки исходных данных это выглядит примерно так:

* В коде рендеринга компонента мы регистрируем эффект с загрузкой данных.
* Компонент отрисовывается без данных.
* Срабатывает эффект по загрузке данных, + где-то здесь же мы устанавливаем эти данные в состояние компонента.
* Поскольку состояние изменилось, компонент перерисовывается и данные отображаются.

Эффекты следует использовать только когда нужны какие-то действия, *внешние по отношению к реакту*. Например, загрузка данных, отправка статистики и т.д. Если все, что происходит в эффекте - это коррекция состояния на основе каких-то локальных значений, то в таком случае не нужно использовать эффекты.

Можно сказать, что единственно правильное использование эффектов - это синхронизация с внешними системами.

# Хук useEffect

В зависимости от синтаксиса, эффект будет срабатывать в разные моменты.

## Каждую реальную перерисовку

Если нужно, чтобы эффект срабатывал при каждой отрисовке компонента, передаем в хук только колбэк:

```react
useEffect(() => {
  console.log('Эффект работает на каждую реальную перерисовку компонента.');
});  // <-- Потому что вообще не передали массив зависимостей
```

Пример: хук будет срабатывать:

* Когда мы показываем \ скрываем компонент. Скрытие приводит к размонтированию, показ - к монтированию, а при монтировании срабатывает первичная отрисовка.

* Когда мы изменяем значение в поле ввода и применяем его. Потому что при этом изменяется состояние компонента и стало быть реакт должен его перерисовать.

  Важное замечание: похоже, срабатывает только при реальной необходимости перерисовки. Если ввести что-то в поле ввода, и несколько раз нажать на кнопку "Задать", то хук не сработает повторно. Реакт видит, что реальных изменений вносить в DOM не надо и не перерисовывает.

```react
import { useEffect } from 'react';
import { useState } from 'react';
import { useRef } from 'react';

export default function EffectsDemo() {
  const [showA, setShowA] = useState(true);
  
  return (
    <>
      <button onClick={() => setShowA(!showA)}>Скрыть \ показать</button>
      { showA && <A /> }
    </>
  );
}

// <-- Компонент А
function A() {
  const [message, setMessage] = useState(null);
  const msg = useRef();

  useEffect(() => {  // <-- Эффект
    console.log('Эффект сработал на Рендеринг A.');
  });

  return (
    <div style={{ border: '2px solid red' }}>
      <div>{message ?? 'Сообщение не задано.'}</div>
      <input ref={msg} />
      <button onClick={() => setMessage(msg.current.value)}>Задать</button>
    </div>
  );
}
```

## Монтирование

Чтобы хук сработал на этапе монтирования, мы передаем в него колбэк и *пустой* массив зависимостей:

```react
useEffect(() => {
  console.log('Эффект работает только при монтировании компонента.');
}, []);  // <-- Потому что массив зависимостей пуст
```

Пример: эффект сработает только при показе компонента. Скрытие приводит к размонтированию, показ - к монтированию. При изменении значения в поле ввода эффект работать не будет.

```react
import { useEffect } from 'react';
import { useState } from 'react';
import { useRef } from 'react';

export default function EffectsDemo() {
  const [showA, setShowA] = useState(true);
  
  return (
    <>
      <button onClick={() => setShowA(!showA)}>Показать \ скрыть</button>
      { showA && <A /> }
    </>
  );
}

// <-- Компонент А
function A() {
  const [message, setMessage] = useState(null);
  const msg = useRef();

  useEffect(() => {  // <-- Эффект
    console.log('Эффект сработал на Монтирование A.');
  }, []);

  return (
    <div style={{ border: '2px solid red' }}>
      <div>{message ?? 'Сообщение не задано.'}</div>
      <input ref={msg} />
      <button onClick={() => setMessage(msg.current.value)}>Задать</button>
    </div>
  );
}
```

## Размонтирование и функция очистки

Если нужно "почистить" за компонентом (например, закрыть сетевые соединения, сбросить анимации и т.д.), тогда мы возвращаем из эффекта функцию, в которой и пишем требуемые для очистки действия. Она выполнится в следующих случаях:

* При размонтировании компонента.
* Каждый раз перед *повторным* выполнением хука.

```react
useEffect(() => {
  console.log('Эффект работает только при монтировании компонента.');
  return () => {  // <-- Эта функция выполнится при размонтировании компонента
    // <-- или перед повторным выполнением хука
    console.log('Сработала функция очистки.');
  }
}, []);
```

Пример: при, что срабатывают функции очистки, которые мы вернули из эффектов, потому что происходит размонтирование текущего компонента:

```react
import { useEffect } from 'react';
import { useState } from 'react';
import { useRef } from 'react';

export default function EffectsDemo() {
  const [showA, setShowA] = useState(true);
  
  return (
    <>
      <button onClick={() => setShowA(!showA)}>Показать \ скрыть</button>
      { showA && <A /> }
    </>
  );
}

// <-- Компонент А
function A() {
  const [message, setMessage] = useState(null);
  const msg = useRef();

  useEffect(() => {  // <-- Эффект
    console.log('Эффект сработал на Монтирование A.');
    return () => {
      console.log('Сработала функция очистки A.');
    }
  }, []);

  return (
    <div style={{ border: '2px solid red' }}>
      <div>{message ?? 'Сообщение не задано.'}</div>
      <input ref={msg} />
      <button onClick={() => setMessage(msg.current.value)}>Задать</button>
    </div>
  );
}
```

## Зависимости

Если передать зависимости, то хук будет работать при изменении *любой* из них. Обычно в зависимостях эффектов указываются те вещи, на которые опирается работа кода эффекта.

```react
useEffect({() => {
  console.log('Эффект срабатывает при монтировании и изменении любой из зависимостей');
}, [dep1, dep2]);  // <-- Массив зависимостей
```

Пример: эффект будет срабатывать при монтировании и при изменении зависимости:

```react
import { useEffect } from 'react';
import { useState } from 'react';
import { useRef } from 'react';

export default function EffectsDemo() {
  const [showA, setShowA] = useState(true);
  
  return (
    <>
      <button onClick={() => setShowA(!showA)}>Показать \ скрыть</button>
      { showA && <A /> }
    </>
  );
}

// <-- Компонент А
function A() {
  const [message, setMessage] = useState(null);
  const [flag, setFlag] = useState(true);
  const msg = useRef();

  useEffect(() => {  // <-- Эффект
    console.log(`Эффект срабатывает при монтировании и изменении зависимости flag: ${flag}.`);
  }, [flag]);

  return (
    <div style={{ border: '2px solid red' }}>
      <div>{message ?? 'Сообщение не задано.'}</div>
      <input ref={msg} />
      <button onClick={() => setMessage(msg.current.value)}>Задать</button>
      <button onClick={() => setFlag(!flag)}>Флаг</button>
    </div>
  );
}
```

# Особенности работы эффектов

## Двойной эффект в development-среде

В development-режиме реакт выполняет эффект дважды. Это сделано намеренно, чтобы обратить внимание разработчика на потенциальное место багов. Если эффект выполняет какие-то вещи, которые требуют очистки (например, соединение с БД требуется закрыть в конце), то мы должны писать функцию очистки. Тогда при двойном вызове эффекта будет паттерн "эффект - очистки - паттерн" и если при этом не появляется багов, значит эффект написан правильно. Если появляются баги, исключения, то это значит, что мы не реализовали функцию очистки или реализовали ее неправильно. В проде реакт не вызывает эффект дважды и в development эту особенность не надо пытаться обойти.

## Эффекты, требующие функции очистки

Несколько характерных примеров.

### Показ диалоговых окон

В функции очистки надо закрывать такие окна.

```react
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

### Подписка на события

Нужно отписываться от событий.

```react
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

### Анимации

Параметры, которые трансформирует анимация, нужно сбрасывать до начальных значений.

```react
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

### Выбор данных (fetch)

В функции очистки [прерываем выборку](https://react.dev/learn/synchronizing-with-effects#fetching-data) или ставим флаг игнорирования выбранных данных.

```react
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

## Выбор данных в эффектах

Выбор данных в эффектах имеет недостатки, например:

* Изначально страница загружается без данных. Получается, что страница сначала должна полностью загрузиться только для того, чтобы понять, что ей еще нужно загрузить данные.
* "Водопад загрузок". Если родительский компонент загружает какие-то данные, а потом еще и его дочерние компоненты тоже что-то загружают, получается своеобразный водопад, который будет работать медленно при слабом интернете.
* Загрузка в эффектах приводит к тому, что данные приходится загружать снова при повторном монтировании компонента.

Как обойти эти проблемы?

* Современные фреймворки, использующие реакт, имеют встроенные механизмы загрузки данных, пользуйтесь ими.
* Можно сделать client-side кэш. Технологии: [React Query](https://tanstack.com/query/latest), [useSWR](https://swr.vercel.app/), и [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview).

## Не эффекты

Есть вещи, которые не надо делать с помощью эффектов.

### Инициализация приложения.

```react
if (typeof window !== 'undefined') { // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

Вещи, относящиеся к базовой инициализации приложения нужно сделать еще до того, как приложение начинает отрисовываться.

### "Покупка продукта"

Собирательный образ операций, которые должны происходить в обработчиках событий, вроде нажатия кнопки, а не в эффектах. Здесь уже надо логически соображать, что некоторые операции не связаны непосредственно с отрисовкой и поэтому не должны выполняться в эффектах.

```react
// Неправильно - размещать такие вещи в эффектах
useEffect(() => {
  fetch('/api/buy', { method: 'POST' });
}, []);

// Правильно - размещать такие вещи в обработчиках
function handleClick() {
  fetch('/api/buy', { method: 'POST' });
}
```

