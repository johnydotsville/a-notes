# Двойной эффект в development-среде

В development-режиме реакт выполняет эффект дважды. Это сделано намеренно, чтобы обратить внимание разработчика на потенциальное место багов. Если эффект выполняет какие-то вещи, которые требуют очистки (например, соединение с БД требуется закрыть в конце), то мы должны писать функцию очистки. Тогда при двойном вызове эффекта будет паттерн "эффект - очистка" и если при этом не появляется багов, значит эффект написан правильно. Если появляются баги, исключения, то это значит, что мы не реализовали функцию очистки или реализовали ее неправильно. В проде реакт не вызывает эффект дважды и в development эту особенность не надо пытаться обойти.

# О выборе данных в эффектах

Выбор данных в эффектах имеет недостатки, например:

* Изначально страница загружается без данных. Получается, что страница сначала должна полностью загрузиться только для того, чтобы понять, что ей еще нужно загрузить данные.
* "Водопад загрузок". Если родительский компонент загружает какие-то данные, а потом еще и его дочерние компоненты тоже что-то загружают, получается своеобразный водопад, который будет работать медленно при слабом интернете.
* Загрузка в эффектах приводит к тому, что данные приходится загружать снова при повторном монтировании компонента.

Как обойти эти проблемы?

* Современные фреймворки, использующие реакт, имеют встроенные механизмы загрузки данных, пользуйтесь ими.
* Можно сделать client-side кэш. Технологии: [React Query](https://tanstack.com/query/latest), [useSWR](https://swr.vercel.app/), и [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview).

# Эффекты, требующие функции очистки

Несколько характерных примеров.

## Показ диалоговых окон

В функции очистки надо закрывать такие окна.

```react
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

## Подписка на события

Нужно отписываться от событий.

```react
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

## Анимации

Параметры, которые трансформирует анимация, нужно сбрасывать до начальных значений.

```react
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

## Выбор данных (fetch)

В функции очистки [прерываем выборку](https://react.dev/learn/synchronizing-with-effects#fetching-data) или ставим флаг игнорирования выбранных данных.

```react
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

# Не эффекты

Есть вещи, которые не надо делать с помощью эффектов.

## Инициализация приложения.

```react
if (typeof window !== 'undefined') { // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

Вещи, относящиеся к базовой инициализации приложения нужно сделать еще до того, как приложение начинает отрисовываться.

## "Покупка продукта"

Собирательный образ операций, которые должны происходить в обработчиках событий, вроде нажатия кнопки, а не в эффектах. Здесь уже надо логически соображать, что некоторые операции не связаны непосредственно с отрисовкой и поэтому не должны выполняться в эффектах.

```react
// Неправильно - размещать такие вещи в эффектах
useEffect(() => {
  fetch('/api/buy', { method: 'POST' });
}, []);

// Правильно - размещать такие вещи в обработчиках
function handleClick() {
  fetch('/api/buy', { method: 'POST' });
}
```

