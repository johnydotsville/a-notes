# Эффекты и async await

Использовать асинхронную функцию непосредственно в эффекте нельзя, будет ошибка "destroy is not a function":

```javascript
useEffect(async () => {
  setMatches(await foobar());
  return () => {  // <-- Кажется, что возвращаем функцию, а на самом деле нет.
    console.log('clean-up function'); 
  }
}, []);
```

Если эффект что-то возвращает, то это обязательно должна быть функция. С виду в примере выше вроде бы возвращается функция. Однако это не так. Все потому, что async-функция возвращает *промис*. Т.е. все, что до await становится телом промиса, все что после - помещается в его then, и этот промис возвращается и попадает в useEffect, отсюда и ошибка.

Исправить это можно, оформив асинхронную функцию отдельно и вызвав ее внутри *обычного* колбека в useEffect:

```javascript
const getAllMatches = async () => {  // <-- Оформляем отдельную асинхронную функцию
  setMatches(await lms.getAllMatches());
  // <-- Тогда все что тут попадает в .then
};

useEffect(() => {  // <-- В эффекте будет обычная лямбда
  getAllMatches();  // <-- Вызываем асинхронку
  return () => {  // <-- И этот return уже к асинхронке не имеет отношения
    console.log('clean-up function'); 
  }
}, []);
```

Если из асинхронной функции не нужно получать результат, ее можно вызвать как обычную функцию. Этим мы и пользуемся.

