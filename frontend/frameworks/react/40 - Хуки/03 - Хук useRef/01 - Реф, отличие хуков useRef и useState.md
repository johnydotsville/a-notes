# useRef хук

```javascript
import {useRef} from 'react';
```

## Сохранение и получение значения

Хук `useRef()` позволяет нам создать объект, который будет существовать на протяжении всей жизни компонента и не будет исчезать между рендерами, в отличие от обычных переменных. В этот объект мы можем сохранить какое-нибудь значение и пользоваться им - читать, изменять. Этот факт можно использовать в различных сценариях (рассмотрены отдельно). Объект будет уникальный для каждого экземпляра компонента, т.е. если создается несколько одинаковых компонентов, то useRef для каждого из них создаст персональный объект.

> Объект, который возвращает хук useRef, я решил назвать термином "реф".

Хук useRef создает реф и возвращает нам ссылку на него. У рефа единственное свойство  - `current`. Оно хранит значение, которое мы передали в хук:

```javascript
const count = useRef(0);
```

```yaml
# Теперь в переменной count лежит реф такого вида:
{
  current: 0;  # Примитив
}
```

Если передать в хук не примитив, а объект:

```javascript
const count = useRef({ clickedTimes: 0 });
```

```yaml
# Тогда в переменной count будет лежать такой реф:
{
  current: {  # В current теперь не примитив, а объект
    clickedTimes: 0
  }
}
```

В общем, что бы мы не передали в useRef, он нам вернет объект ("реф"), в свойстве current которого будет лежать переданная вещь. Если не передать ничего, то в current будет undefined.

Прочитать \ изменить сохраненное в реф значение можно напрямую через свойство `current`:

```javascript
const count = useRef(0);
console.log(count.current);  // 0
count.current++;
```

```javascript
const count = useRef({ clickedTimes: 0 });
console.log(count.current.clickedTimes);  // 0
count.current++;
```

## Базовый пример

```react
import {useRef} from 'react';

const Counter = () => {
  const count = useRef(0);  // <-- Создаем объект с начальным значением 0
  console.log(`Рендер: на кнопку нажали ${count.current} раз.`);  // <-- Читаем значение

  function handleClick() {
    count.current += 1;  // <-- Изменяем значение в объекта
    console.log(`handleClick: на кнопку нажали ${count.current} раз.`);  // <-- Читаем значение
  }

  return (
    <button onClick={handleClick}>Click me!</button>
  );
};

export default Counter;
```

# Отличие от useState

## useRef не провоцирует рендер

Важной особенностью использования useRef является факт, что изменение сохраненного значения не провоцирует повторный рендер. Если взять пример из начала конспекта, то мы увидим надпись `Рендер: на кнопку нажали 0 раз.` только единожды, при самом первом рендере компонента. Щелчки по кнопке будут увеличивать счетчик и выводить уже другую надпись `handleClick: на кнопку нажали 2 раз.`, что наглядно показывает, что повторный рендер не происходит.

Поэтому useRef как правило используется для хранения информации, которую не планируется отображать на экране.

# Механика сохранения

Хук сохраняет значение, которое мы ему передаем, только один раз. Когда происходит повторный рендер, хук выполняется снова, но переданное значение он на этот раз игнорирует. При этом, если значение, например, создается через конструктор, то этот конструктор выполняется. Т.е. получается ситуация, что на создание экземпляра тратится время, а потом хук все равно его игнорирует. Пример:

```react
import {useRef} from 'react';
import {useState} from 'react';

export default function RefDemo() {
  const [message, setMessage] = useState("Hello, world!");
  const refm = useRef(new Message(message));  // <-- Хук сохранит исходный "Hello, world!"
  
  function handleClick() {
    console.log(refm.current);  // <-- Выводим текущее значение ref
  }

  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleClick}>Вывести в консоль ref</button>
    </>
  );
}

function Message(message) {
  console.log("Работает конструктор Message.");
  console.log("В конструктор передано значение: " + message);
  this.message = message;
}
```

В этом примере, когда мы печатаем что-то в поле ввода, то постоянно изменяется состояние и происходит ре-рендер. Однако каждый раз при нажатии кнопки мы видим, что в ref хранится самое первое значение состояния - строка "Hello, world!". А еще при ре-рендере мы видим, что каждый раз выполняется конструктор Message. Если он был бы тяжелым, то на это бесполезное создание могло бы уходить много времени.

Для решения подобных ситуаций есть определенный паттерн (подробнее на сайте [реакта](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents)):

```react
import {useRef} from 'react';
import {useState} from 'react';

export default function RefDemo() {
  const [message, setMessage] = useState("Hello, world!");

  const refm = useRef(null);  // <-- Сперва сохраняем null.
  if (refm.current === null) {  // <-- Потом делаем проверку и создаем экземпляр, если надо.
    refm.current = new Message(message);
  }
  
  function handleClick() {
    console.log(refm.current);
  }

  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleClick}>Вывести в консоль ref</button>
    </>
  );
}

function Message(message) {
  console.log("Работает конструктор Message.");
  console.log("В конструктор передано значение: " + message);
  this.message = message;
}
```

Хотя обычно не рекомендуется читать \ писать ref во время рендеринга (см. раздел про правила использования), но в данном случае это допустимо, поскольку не нарушается принцип чистоты функции компонента.

# Правила использования

## Не трогать объект в процессе рендеринга

Лучше не менять и не читать значение объекта в процессе рендеринга, т.е. не делать этого непосредственно в функции компонента:

```react
import {useRef} from 'react';

const Counter = () => {
  const count = useRef(0);
  count.current++; // <-- Лучше не писать ничего в объект в процессе рендеринга.
  console.log(count.current);  // <-- И читать тоже не надо.

  return (
    <h1>Изучаем хук useRef</h1>
  );
};

export default Counter;
```

Это нарушает концепцию компонента как чистой функции, потому что каждая перерисовка счетчика изменяет переменную, т.е. получается сайд-эффект. Вызов выглядит одинаково, а на деле под капотом приводит к неочевидным изменениям. Читать и писать объект следует исключительно в обработчиках событий, в эффектах, и т.д.

