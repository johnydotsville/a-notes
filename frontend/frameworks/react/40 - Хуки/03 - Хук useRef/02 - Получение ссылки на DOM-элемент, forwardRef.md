# Ссылка на DOM-элемент

Одним из сценариев использования хука useRef является получение прямой ссылки на DOM-элемент. Про это в разделе "Односторонее связывание". Также сюда напишу и про двусторонее. Оно к этому хуку отношения не имеет, но просто для полноты картины.

# Двустороннее связывание

Двустороннее связывание - это когда изменение значения элемента приводит к изменению состояния компонента, а изменение состояния компонента ведет к изменению значения элемента.

## Простой

Пример компонента, состояние которого связано с элементом ввода:

```react
import {useState} from 'react';

const Message = () => {
  const [message, setMessage] = useState("Привер, мир!");
  console.log("Происходит рендер компонента Message.");

  return (
    <div>
      <h1>{message}</h1>
      <input type="text" value={message} onChange={event => setMessage(event.target.value)} />
    </div>
  );
};

export default Message;
```

* Объявляем состояние в виде простой строки.
* Привязываем это состояние к значению элемента (в данном случае input, используя пропс value).
* В событии изменения элемента вызываем функцию изменения состояния.
* Теперь при изменении элемента меняется состояние, а при изменении состояния меняется значение в элементе. Вот и получилось двустороннее связывание.

## Вложенный элемент

Теперь пример посложнее - элемент будет вложен в отдельный компонент и нужно прокинуть атрибуты из компонента MyInput до внутреннего элемента input:

```react
import {useState} from 'react';

const Message = () => {
  const [message, setMessage] = useState("Привер, мир!");

  return (
    <div>
      <h1>{message}</h1>
      <MyInput type="text" value={message} onChange={event => setMessage(event.target.value)} />
    </div>
  );
};

export default Message;
```

Все эти атрибуты нужно прокинуть до элемента, лежащего внутри компонента MyInput. Это можно сделать с помощью оператора разбиения `...`, разбив объект пропсов на отдельные свойства. Таким образом все атрибуты, которые мы указали для MyInput, окажутся и в обычном input:

```react
const MyInput = (props) => {
  return (
    <input {...props} />
  );
};

export default MyInput;
```

# Одностороннее связывание

При одностороннем связывании мы не привязываем значение элемента к состоянию, а просто получаем значение непосредственно из элемента. Ссылка на примеры с сайта [реакта](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref).

У каждого компонента есть атрибут `ref`. Если положить туда объект, то после формирования реального дома реакт положит в этот объект ссылку на узел и мы сможем к этому узлу обращаться.

## Получение доступа в этом же компоненте

Особенностью этого примера является то, что мы связываем реф с узлом и пользуемся этим рефом в том же компоненте, где создали реф. Под рефом я имею ввиду объект, который возвращает функция useRef.

```react
import {useRef} from 'react';

const Message = () => {
  const messageRef = useRef(null);  // <-- 1. С помощью хука создаем объект

  const log = () => {
    console.log(messageRef.current.value);  // <-- 3. Получаем значение элемента
  }

  return (
    <div>
      <input type="text" ref={messageRef} />  {/* <-- 2. Связываем этот объект с элементом */}
      <button onClick={log}>Вывести в консоль</button>
    </div>
  );
};

export default Message;
```

* хук useRef возвращает нам реф (объект со свойством `current`).
* Передаем этот реф в атрибут `ref` элемента ввода и таким образом в рефе оказывается ссылка на этот DOM-элемент.
* Используя эту ссылку, мы получаем значение из поля ввода и выводим в консоль.

## Самописный компонент

Ссылка на эту тему на сайте [реакта](https://react.dev/reference/react/useRef#i-cant-get-a-ref-to-a-custom-component). Чтобы заработало, обычно требуется перезагрузка страницы с программой.

Особенностью этого примера является то, что мы создаем реф в родительском компоненте, а связать этот реф с конкретным элементом хотим в дочернем компоненте. Атрибут ref, как и key, - это самостоятельное свойство компонента, поэтому мы не можем получить к нему доступ через пропсы в дочернем компоненте:

```react
import {useRef} from 'react';
import InputCustom from './InputCustom';

const Message = () => {
  const messageRef = useRef(null);

  const log = () => {
    console.log(messageRef.current.value);
  }

  return (
    <div>
      <InputCustom type="text" ref={messageRef} />  <!-- ref не попадает в пропсы -->
      <button onClick={log}>Вывести в консоль</button>
    </div>
  );
};

export default Message;
```

Поскольку по умолчанию в дочернем компоненте у нас есть доступ только к пропсам, а в них, как уже было сказано, ref нет, значит мы не можем получить реф-объект, который передали из родительского. Поэтому, чтобы все-таки получить реф из ref, существует специальная функция `React.forwardRef()`. Мы передаем в нее колбэк с двумя параметрами: props и ref, а в теле колбэка оформляем компонент:

```react
import React from 'react';

const InputCustom = React.forwardRef((props, ref) => {
  return (
    <input ref={ref} {...props} />
  );
});

export default InputCustom;
```

