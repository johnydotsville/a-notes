# Собственные хуки

* Собственный (кастомный) хук - это обычная функция, которая внутри себя использует реактовский хук.
  * Обычно кастомные хуки пишутся, чтобы разгрузить компонент от большого текста.
* Кастомный хук можно сохранить в отдельный файл или просто объявить в том же файле, где он нужен.
* Имя кастомного хука обязано начинаться с префикса `use`.

# useRef хук

* Подключение `import { useRef } from 'react';`
* Хук создает и возвращает нам объект ("реф").
  * Если передать в хук значение, он положит это значение в реф.
* У рефа единственное свойство `current`, которое и содержит значение рефа.
  * Читать \ изменять значение рефа можно напрямую через это свойство.
* Реф живет столько же, пока существует компонент.
  * У разных экземпляров одного и того же компонента собственный реф.
* Изменение значения рефа не провоцирует рендер.
  * Поэтому обычно реф не используют для хранения информации, которую требуется отображать.
* Механика сохранения значения.
  * Хук вызывается при каждом рендере, но сохраняет переданное значение лишь единожды.
  * Если значение, например, это объект создающийся через конструктор, он все равно создастся, но будет проигнорирован.
  * Паттерн для избежания лишних созданий таких объектов.
* Правила использования рефа.
  * Не читать \ не писать в реф во время рендеринга (т.е. непосредственно в теле функции компонента)
  * Читать \ писать только в обработчиках событий и в эффектах.
* Сценарии использования рефа.
  * Получение ссылки на дом-элемент.
    * В том же компоненте, где создавался реф.
    * В дочернем компоненте.
      * Проброс ref-атрибута методом `React.forwardRef((props, ref) => { тело компонента })`

# useMemo хук

* Подключение `import { useMemo } from 'react'`
* У хука два параметра.
  * Колбэк ("работа").
    * Должен возвращать результат.
    * Должен быть чистой функцией.
  * Массив зависимостей.
    * Зависимостью мб состояние компонента или любое значение, которое вычисляется в процессе выполнения функции компонента.
    * Массив зависимостей надо передавать всегда, даже если он пустой.
      * Если он пустой, работа выполнится единожды.
    * Если массив не передать вообще, работа будет выполняться при каждом вызове хука.
* При первом выполнении хука выполняется колбэк и его результат запоминается.
  * Также запоминаются значения зависимостей.
* Если при очередном выполнении хука зависимость меняется, колбэк выполняется заново и закэшированный результат заменяется на новый.
* useMemo можно организовывать в цепочки.
  * Это когда возврат первого useMemo является зависимостью следующего useMemo.



# useEffect хук

* Подключение `import { useEffect } from 'react'`
* Жизненный цикл компонента
  * Монтирование (mount), обновление (update), размонтирование (unmount).
    * Когда они случаются.
* Три вида логики в компоненте.
  * Логика рендера.
  * Логика обработчиков событий.
  * Эффекты.
* Эффекты выполняются после коммита компонента в дерево.
  * Компонент отрисовывается -> срабатывает эффект.
* Эффекты используются для реализации вещей, внешних по отношеию к реакту: загрузка данных, отправка статистики, интеграция со сторонними библиотеками.
* Параметры хука useEffect
  * Колбэк.
  * Массив зависимостей.
* Настройка момента срабатывания колбэка.
  * Каждую реальную перерисовку - не передаем массив вообще.
  * Только при монтировании - передаем пустой массив.
  * При монтировании и изменении зависимости - передаем массив с зависимостями.
* Функция очистки.
  * Делаем в колбэке return с функцией.
  * Функция очистки срабатывает
    * При размонтировании компонента.
    * Перед каждым повторным выполнением колбэка.
* Асинхронность эффекте.
  * Передать колбэку async-эффект нельзя, т.к. он возвратит промис, а так нельзя. Если и возвращать что-то, то это дб функция.
  * async-функции оформляем отдельно и вызываем внутри колбэка.
* Особенности работы эффектов.
  * Двойной вызов эффекта в development-среде.
    * Паттерн "эффект-очистка".
  * Выбор данных в эффектах.
    * "Водопад загрузок"
    * Эффекты выполняются только после отрисовки компонентов.
    * Необходимость повторно загружать данные при повторном монтировании.

# useReducer хук

* Подключение `import { useReducer } from 'react'`
* Редюсеры - это альтернативный способ управления состоянием.
* Редюсер - это функция, которая аккумулирует все возможные действия над состоянием (или его частью).
* Параметры редюсера.
  * Два параметра
    * Состояние.
    * Действие.
  * Параметры редюсеру передает реакт.
* Механика работы с состоянием через редюсер.
  * Хук useReducer принимает редюсер и начальное состояние.
    * Хук возвращает
      * Переменную для чтения состояния.
      * Функцию-диспетчер для регистрации событий.
  * Когда нам надо изменить состояние
    * Формируем объект действия с полями `{ type, payload }`
      * type - это строка с именем действия.
      * payload - данные, которые связаны с действием. Называется "нагрузка".
    * Передаем его в диспетчер.
    * Реакт вызывает нужный редюсер и передает ему состояние, за которое этот редюсер отвечает, и объект действия, которое мы отдали диспетчеру.
    * Редюсер по полю type понимает, что нужно сделать и на основе текущего состояния и полученной нагрузки формирует новое состояние и возвращает его реакту.
* Редюсеры позволяют вынести объемную логику изменения состояния в отдельное место, разгрузив код компонента.
* Редюсеры выполняются во время рендера, поэтому дб чистыми функциями.



# useContext хук

* Подключение `import {createContext, useContext} from 'react'`
* Контекст - это способ определить в родительском компоенте значение и получить это значение в дочернем компоненте, независимо глубины вложения.
* Принцип работы с контекстом.
  * Через `createContext()` создаем контекст.
    * Параметр - дефолтное значение для контекста, мб примитив или объект.
    * Выход - объект контекста ("контекст").
  * Компонент-"провайдер" из свойства `контекст.Provider`
    * Вкладываем компоненты, которым нужно какое-то значение, в этот компонент-провайдер.
    * Через свойство `value` провайдера задаем значение контекста.
  * В компоненте-пользователе вызываем хук `useContext()` и передаем ему объект контекста, из которого надо извлечь значение.
    * Компонент, использующий этот хук, не только извлекает значение, но и подписывается на изменения контекста.
  * Если требуется несколько контекстов, то провайдеры просто вкладываются друг в друга.
    * Можно извлекать такие "пирамиды" провайдеров в отдельный компонент.
  * Чтобы сделать значение контекста изменяемым, кооперируем контекст с `useState()`
    * Ставим провайдеру в значение переменную состояния.
* Механики контекста.
  * На одном объекте контекста можно использовать много провайдеров.
    * У каждого из них будет собственное значение контекста.
  * Поиск значения ведется вверх по дереву компонентов до первого подходящего провайдера.
    * Это позволяет переопределять значения контекста во вложенных компонентах.
    * Если подходящий провайдер не найден, берется дефолтное значение контекста, которое было задано при его создании.