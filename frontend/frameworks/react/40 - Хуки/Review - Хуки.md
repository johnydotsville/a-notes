# useRef хук

* Подключение `import { useRef } from 'react';`
* Хук создает и возвращает нам объект ("реф").
  * Если передать в хук значение, он положит это значение в реф.
* У рефа единственное свойство `current`, которое и содержит значение рефа.
  * Читать \ изменять значение рефа можно напрямую через это свойство.
* Реф живет столько же, пока существует компонент.
  * У разных экземпляров одного и того же компонента собственный реф.
* Изменение значения рефа не провоцирует рендер.
  * Поэтому обычно реф не используют для хранения информации, которую требуется отображать.
* Механика сохранения значения.
  * Хук вызывается при каждом рендере, но сохраняет переданное значение лишь единожды.
  * Если значение, например, это объект создающийся через конструктор, он все равно создастся, но будет проигнорирован.
  * Паттерн для избежания лишних созданий таких объектов.
* Правила использования рефа.
  * Не читать \ не писать в реф во время рендеринга (т.е. непосредственно в теле функции компонента)
  * Читать \ писать только в обработчиках событий и в эффектах.
* Сценарии использования рефа.
  * Получение ссылки на дом-элемент.
    * В том же компоненте, где создавался реф.
    * В дочернем компоненте.
      * Проброс ref-атрибута методом `React.forwardRef((props, ref) => { тело компонента })`

# useMemo хук

* Подключение `import { useMemo } from 'react'`
* У хука два параметра.
  * Колбэк ("работа").
    * Должен возвращать результат.
    * Должен быть чистой функцией.
  * Массив зависимостей.
    * Зависимостью мб состояние компонента или любое значение, которое вычисляется в процессе выполнения функции компонента.
    * Массив зависимостей надо передавать всегда, даже если он пустой.
      * Если он пустой, работа выполнится единожды.
    * Если массив не передать вообще, работа будет выполняться при каждом вызове хука.
* При первом выполнении хука выполняется колбэк и его результат запоминается.
  * Также запоминаются значения зависимостей.
* Если при очередном выполнении хука зависимость меняется, колбэк выполняется заново и закэшированный результат заменяется на новый.
* useMemo можно организовывать в цепочки.
  * Это когда возврат первого useMemo является зависимостью следующего useMemo.



# useEffect хук

* Жизненный цикл компонента
  * Монтирование (mount), обновление (update), размонтирование (unmount).
    * Когда они случаются.
* Три вида логики в компоненте.
  * Логика рендера.
  * Логика обработчиков событий.
  * Эффекты.
* Эффекты выполняются после коммита компонента в дерево.
  * Компонент отрисовывается -> срабатывает эффект.
* Эффекты используются для реализации вещей, внешних по отношеию к реакту: загрузка данных, отправка статистики, интеграция со сторонними библиотеками.
* Параметры хука useEffect
  * Колбэк.
  * Массив зависимостей.
* Настройка момента срабатывания колбэка.
  * Каждую реальную перерисовку - не передаем массив вообще.
  * Только при монтировании - передаем пустой массив.
  * При монтировании и изменении зависимости - передаем массив с зависимостями.
* Функция очистки.
  * Делаем в колбэке return с функцией.
  * Функция очистки срабатывает
    * При размонтировании компонента.
    * Перед каждым повторным выполнением колбэка.
* Асинхронность эффекте.
  * Передать колбэку async-эффект нельзя, т.к. он возвратит промис, а так нельзя. Если и возвращать что-то, то это дб функция.
  * async-функции оформляем отдельно и вызываем внутри колбэка.
* Особенности работы эффектов.
  * Двойной вызов эффекта в development-среде.
    * Паттерн "эффект-очистка".
  * Выбор данных в эффектах.
    * "Водопад загрузок"
    * Эффекты выполняются только после отрисовки компонентов.
    * Необходимость повторно загружать данные при повторном монтировании.