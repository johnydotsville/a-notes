# Ссылка на DOM-элемент

Одним из сценариев использования хука useRef является получение прямой ссылки на DOM-элемент. Про это в разделе "Односторонее связывание". Также сюда напишу и про двусторонее. Оно к этому хуку отношения не имеет, но просто для полноты картины.

# Двустороннее связывание

Двустороннее связывание - это когда изменение значения элемента приводит к изменению состояния компонента, а изменение состояния компонента ведет к изменению значения элемента.

## Простой

Пример компонента, состояние которого связано с элементом ввода:

```react
import {useState} from 'react';

const Message = () => {
  const [message, setMessage] = useState("Привер, мир!");
  console.log("Происходит рендер компонента Message.");

  return (
    <div>
      <h1>{message}</h1>
      <input type="text" value={message} onChange={event => setMessage(event.target.value)} />
    </div>
  );
};

export default Message;
```

* Объявляем состояние в виде простой строки.
* Привязываем это состояние к значению элемента (в данном случае input, используя пропс value).
* В событии изменения элемента вызываем функцию изменения состояния.
* Теперь при изменении элемента меняется состояние, а при изменении состояния меняется значение в элементе. Вот и получилось двустороннее связывание.

## Вложенный элемент

Теперь пример посложнее - элемент будет вложен в отдельный компонент и нужно прокинуть атрибуты из компонента MyInput до внутреннего элемента input:

```react
import {useState} from 'react';

const Message = () => {
  const [message, setMessage] = useState("Привер, мир!");

  return (
    <div>
      <h1>{message}</h1>
      <MyInput type="text" value={message} onChange={event => setMessage(event.target.value)} />
    </div>
  );
};

export default Message;
```

Все эти атрибуты нужно прокинуть до элемента, лежащего внутри компонента MyInput. Это можно сделать с помощью оператора разбиения `...`, разбив объект пропсов на отдельные свойства. Таким образом все атрибуты, которые мы указали для MyInput, окажутся и в обычном input:

```react
const MyInput = (props) => {
  return (
    <input {...props} />
  );
};

export default MyInput;
```

# Одностороннее связывание

При одностороннем связывании мы не связываем элемент с состоянием, а просто получаем значение непосредственно из элемента. Ссылка на примеры с сайта [реакта](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref).

У каждого компонента есть атрибут `ref`. Если положить туда объект, то после формирования реального дома реакт положит в этот объект ссылку на узел и мы сможем к нему обращаться.

## Простой элемент

```react
import {useRef} from 'react';

const Message = () => {
  const messageRef = useRef(null);  // <-- 1. С помощью хука создаем объект

  const log = () => {
    console.log(messageRef.current.value);  // <-- 3. Получаем значение элемента
  }

  return (
    <div>
      <input type="text" ref={messageRef} />  {/* <-- 2. Связываем этот объект с элементом */}
      <button onClick={log}>Вывести в консоль</button>
    </div>
  );
};

export default Message;
```

* хук useRef возвращает нам объект со свойством `current`.
* Передаем полученный от хука объект в атрибут `ref` элемента ввода и таким образом в объекте оказывается ссылка на этот DOM-элемент.
* Используя эту ссылку, мы получаем значение из поля ввода и выводим в консоль.

## Самописный компонент

Ссылка на эту тему на сайте [реакта](https://react.dev/reference/react/useRef#i-cant-get-a-ref-to-a-custom-component). Чтобы заработало, обычно требуется перезагрузка страницы с программой.

```react
import {useRef} from 'react';
import InputCustom from './InputCustom';

const Message = () => {
  const messageRef = useRef(null);

  const log = () => {
    console.log(messageRef.current.value);
  }

  return (
    <div>
      <InputCustom type="text" ref={messageRef} />  <!-- ref у самописного компонента -->
      <button onClick={log}>Вывести в консоль</button>
    </div>
  );
};

export default Message;
```

Самописные компоненты по умолчанию не дают доступ к своему дом-узлу. Т.е. в данном примере тот факт, что мы просто написали `<InputCustom type="text" ref={messageRef} />` не заставит компонент InputCustom положить в объект ссылку на свой дом узел. Поэтому надо явно заставить его сделать это, оформив компонент как колбэк для функции `React.forwardRef()`:

```react
import React from 'react';

const InputCustom = React.forwardRef((props, ref) => {
  return (
    <input ref={ref} {...props} />
  );
});

export default InputCustom;
```

