# Приложение - это единственный объект

Каждый JSX-тег это по сути вызов метода `React.createElement('тег', {атрибут: значение}, телоТега)`. Например:

```react
return (<h1 className='c1'>Hello, React!</h1>);
```

```react
return (React.createElement('h1', {className: 'c1'}, 'Hello, React!'));
```

А если элементы вложены друг в друга, то это почти то же самое:

```react
return (
    <div className='c1'>
      <h1 className='c2'>Hello, React!</h1>
      <p className='c3' myAttr="foobar">Изучаем устройство React.</p>
    </div>
  );
```

```react
return React.createElement('div', {className: 'c1'}, 
    React.createElement('h1', {className: 'c2'}, 'Hello, React!'),
    React.createElement('p', {className: 'c3', myAttr: 'foobar'}, 'Изучаем устройство React.')
  );
```

Т.о. парсинг JSX сводится к вызову методов React.createElement, а все приложение в конечном итоге представляет собой единственный объект, внутрь которого вложена куча других объектов по тому же принципу. Можно вставить этот код в реакт-проект, в index-файл, поставить точку останова и посмотреть, как выглядит созданный через createElement объект.

У него такие свойства:

* type - html-тег, которому соответствует объект.
* key
* ref
* props - "пропс". В этом свойстве лежит объект, в который попадают атрибуты, которые мы указываем при использовании компонента. Атрибуты становятся свойствами этого объекта.
  * children - стандартное свойство пропса, которое есть всегда. Оно содержит элементы, вложенные в данный элемент. Если вложен только один элемент, тогда в children лежит объект, т.е. вложенный элемент непосредственно. Если же вложено несколько элементов-соседей, как в примере выше, тогда в props будет лежать массив с этими элементами.
  * className и прочие - все атрибуты, которые мы указываем для компонента, превращаются в самостоятельные поля объекта пропс.
* TODO еще есть _store и еще некоторые, мб потом погуглить про ним.



# Рендер

Реакт отслеживает компоненты, создавая их экземпляры. Каждый экземпляр имеет состояние и жизненный цикл.

`Initial Render` - это процесс самой первой отрисовки интерфейса. `Re-render` - это процесс, который возникает, когда в состоянии приложения происходит изменение и требуется выяснить, какую часть интерфейса надо перерисовать.

Насколько я понял, рендер - это процесс формирования виртуального дома. Т.е. он включает в себя перевод JSX в вызовы React.createElement, чтобы сформировать дерево элементов, а также сравнение нового дома со старым, чтобы понять, что именно надо обновить.

Reconciliation - еще какой-то этап?

Мб дело примерно так? Рендер - это процесс формирования виртуального дома из JSX. Когда приложение рендерится первый раз, то идет просто рендер, а потом коммит, т.е. перевод виртуального дома в реальный дом. Когда возникает изменение состояния, опять происходит рендер, т.е. формирования нового виртуального дома. Затем происходит реконсиляция, т.е. определение, чем новый дом отличается от старого. И когда реакт понял, чем, то снова делает коммит. Так мб это работает?

+Повторный рендеринг идет не от корня, а от компонентов, чье состояние изменилось.









# Ссылки

Некоторые ссылки на всякий случай:

* https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/
* https://www.freecodecamp.org/news/react-under-the-hood/
* https://www.telerik.com/blogs/understand-how-rendering-works-react
* https://legacy.reactjs.org/docs/reconciliation.html
* https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/
* 