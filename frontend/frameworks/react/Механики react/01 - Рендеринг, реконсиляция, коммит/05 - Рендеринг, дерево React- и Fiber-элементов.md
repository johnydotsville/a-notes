# Общий вайб

```react
<App />
```

```react
const App = () => {
  // ...
  return (
    <Foo>
      <Bar>
        <div>
        	<Baz />
        	<Zxc />
        </div>
      </Bar>
    </Foo>
  )
}
```

Транспилятор преобразует весь JSX в вызовы React.createElement(). Этот метод создает т.н. реакт-элемент. Это основа для дальнейшего построения fiber-элемента.

react-элемент выглядит примерно так:

```javascript
{
  $$typeof: Symbol(react.element),
  type: MyComponent, // Ссылка на функцию/класс
  key: 'uniq_id',
  ref: null,
  props: {
    title: 'Test',
    children: null
  }
}
```

Его можно представить себе как простой шаблон для построения более сложного fiber-элемента, который уже сможет хранить в себе такие вещи как состояние компонента, мемоизированные данные и т.д.

Чтобы создать реакт-элемент, не нужно вызывать функцию компонента. Поэтому реакт-элемент создается быстро. Для примера выше получится такое дерево реакт-элементов:

```javascript
// Листинг A
{
  $$typeof: Symbol(react.element),
  type: Foo, // Функция Foo
  props: {
    children: {
      $$typeof: Symbol(react.element),
      type: Bar, // Функция Bar
      props: {
        children: {
          $$typeof: Symbol(react.element),
          type: 'div', // Стандартный DOM-элемент
          props: {
            children: [
              {
                $$typeof: Symbol(react.element),
                type: Baz, // Функция Baz
                props: {}
              },
              {
                $$typeof: Symbol(react.element),
                type: Zxc, // Функция Zxc
                props: {}
              }
            ]
          }
        }
      }
    }
  }
}
```

Здесь важно почувствовать следующий момент: пока реакт не вызвал функцию App, он не знал, что она возвращает, какое дерево элементов. Поэтому он после создания реакт-элемента для App начинает создавать fiber-элемент для App. Вот только тогда он и вызывает функцию App и видит, что она возвращает.

Следим за мыслью дальше: чтобы создать дерево реакт-элементов, показанное в листинге A, реакту *не надо* выполнять функции Foo, Bar, Baz, Zxc. Почувствуй разницу между вызовом Foo и React.createElement('Foo'):

```javascript
const App = () => {
  return React.createElement(
    Foo, 
    null, 
    React.createElement(
      Bar,
      null,
      React.createElement(
        'div',
        null,
        React.createElement(Baz, null),
        React.createElement(Zxc, null)
      )
    )
  );
};
```

Т.о. при выполнении функции App реакт получает дерево реакт-элементов, но не полное для всего приложения, а только для компонента App.

Теперь он начинает обходить это дерево по одному элементу и для каждого создавать fiber-элемент. Для этого вызывает функцию Foo, получает его дерево react-элементов и начинает строить fiber-элементы для него. В общем, так он спускается до самого низа, потом создает аналогично fiber-элемент для Bar, div, Baz, Zxc.

В итоге получается fiber-дерево для всего приложения. Этот процесс построения fiber-дерева называется *рендеринг*.

> Важный момент: сначала создается fiber-элемент (или fiber-узел, это синонимы), и только потом уже выполняется функция компонента. Потому что внутри функции мы можем использовать хуки, например useState, который должен сохранить начальное состояние в узел. Соотвественно, узел надо создать *до* выполнения функции, чтобы он уже был готов и хуки \ прочее могли с ним работать.

Важно понимать, что после построения каждого fiber-элемента реакт проверяет, есть ли у него еще время, чтобы строить очередной fiber-элемент, или надо приостановиться и дать управление браузеру. Также реакт отдает управление браузеру, даже если еще есть время, в случае когда обнаруживает, что от браузера пришло событие, которое считается высокоприоритетным, например, пользовательский ввод (клик мышкой, ввод с клавиатуры).

Благодаря такому подходу рендеринг не занимает единолично все время главного потока, и за счет регулярного возврата управления браузеру страница имеет хороший отклик. Когда браузер поработал, реакт снова получает управление и продолжает рендеринг.

Все это реализуется планировщиком, реализованным в реакте, и подписками на события браузера.



TODO: Можно было бы еще дописать про приоритетность рендеринга. Не всякий рендеринг имеет одинаковый приоритет.



# Проверка от Дипси

Дал дипси проверить этот конспект, у него хорошо получилось структурировать и добавить технические детали:

---

### **1. Корректные утверждения:**
✅ **Про `React.createElement`:**  
- Да, JSX преобразуется в `React.createElement(type, props, children)`, который возвращает **React-элемент** (неизменяемый объект-описание).  
- Функции компонентов (`Foo`, `Bar` и т.д.) **не вызываются** на этом этапе — они становятся значением `type`.

✅ **Про Fiber-алгоритм:**  
- React обходит дерево React-элементов **пошагово**, создавая Fiber-узлы.  
- Прерывания (`shouldYield`) возможны после обработки каждого Fiber-узла.  
- Высокоприоритетные события (клики, ввод) прерывают фоновый рендеринг.

✅ **Про этапы работы:**
1. Транспиляция JSX → `React.createElement()`.  
2. Создание React-элементов (без вызова компонентов).  
3. Построение Fiber-дерева (с вызовами компонентов и прерываниями).  

---

### **2. Уточнения:**
#### **а) Когда вызываются функции компонентов?**
- **Только при обработке их Fiber-узлов.**  
  Пример для `<Foo><Bar /></Foo>`:  
  1. React создаёт React-элемент для `Foo` (где `Bar` — это `props.children`).  
  2. На этапе Fiber-рендеринга:  
     - Вызывает `Foo()` → получает его React-элементы.  
     - Видит `Bar` в `children` → создаёт Fiber для `Bar` → вызывает `Bar()`.

#### **б) Полное ли дерево React-элементов?**
- **Нет**, React не строит всё дерево сразу.  
- На каждом шаге:  
  - Вызывается текущий компонент → возвращает React-элементы для своих детей.  
  - Дети обрабатываются **только когда до них доходит очередь**.

#### **в) Fiber-узел vs React-элемент**
| React-элемент          | Fiber-узел                              |
| ---------------------- | --------------------------------------- |
| Неизменяемый объект    | Изменяемая структура                    |
| `type`, `props`, `key` | `stateNode`, `memoizedState`, `effects` |
| Создаётся сразу        | Создаётся инкрементально                |

---

### **3. Пример для вашего кода:**
#### **Шаги работы:**
1. **Исходный код:**
   ```jsx
   const App = () => {
     return (
       <Foo>
         <Bar>
           <div><Baz /><Zxc /></div>
         </Bar>
       </Foo>
     );
   };
   ```

2. **После транспиляции:**
   ```js
   const App = () => {
     return React.createElement(
       Foo,
       null,
       React.createElement(
         Bar,
         null,
         React.createElement(
           'div',
           null,
           React.createElement(Baz, null),
           React.createElement(Zxc, null)
       )
     );
   };
   ```

3. **Порядок обработки Fiber-алгоритмом:**
   - `App` → `Foo` → `Bar` → `div` → `Baz` → `Zxc`.  
   - На каждом шаге:  
     - Создаётся Fiber-узел.  
     - Если это компонент — вызывается его функция.  
     - Проверяется `shouldYield()`.

