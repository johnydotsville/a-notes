# Пропсы

## Что такое пропсы

Пропсы - это некоторые входные данные для компонента. Можно сказать, параметры для него, т.к. компонент это по сути функция.

## Передача пропсов в компонент

Чтобы пользоваться пропсами в компоненте, нужно их туда передать:

```react
<Info header={"Важная информация"} 
      article={{title: "О наркотиках", 
                author: "Мистер Маки", 
                content: "Наркотики - эт плохо, пнятненько?"
               }}
    />
```

* Здесь пропсами являются `header` (простая строка) и `article` (объект). Для собственных компонентов можно придумывать любые пропсы, а у реактовских стандартных компонентов пропсы обычно называются по именам атрибутов соответствующих тегов.
* Все "атрибуты" компонента собираются в единый параметр с именем `props`. В данном случае в пропсах будет два поля - header и article.
* Значение "атрибуту" задается через фигурные скобки `{}`.
  * Значением может быть как простое значение, так и сложный объект.

## Использование пропсов в компоненте

Все переданные пропсы доступны внутри компонента через стандартный параметр `props`:

```react
const Info = (props) => {  // <-- Пропсы - это просто параметр функции
  console.log(props);
  return (
    <div>
      <h1>{props.header}</h1>  {/* <-- Извлекаем нужные данные из пропсов */}
      <div>{props.article.title}</div>
      <div>{props.article.author}</div>
      <div>{props.article.content}</div>
    </div>
  );
};
```

 Для удобства и наглядности этот параметр обычно деструктуризируют.

## Дефолтные значения для пропсов

На случай, если пользователь компонента не передаст в него какие-то пропсы, мы можем задать им значения по умолчанию:

```react
const Info = ({header='Привет, автор!', article={}}) => {
  return (
    <div>
      <h1>{header}</h1>
      <div>{article.title}</div>
      <div>{article.author}</div>
      <div>{article.content}</div>
    </div>
  );
};
```

Без значений по умолчанию не переданный пропс получит undefined и это может привести к ошибкам. Например, undefined в header проблем не вызовет, а вот без значения по умолчанию для article будет попытка вызвать undefined.title, что приведет к ошибке.

# Возможности по работе с пропсами

При работе с пропсами полезно знать возможности JS по деструктуризации объектов и как работает оператор разложения (`...`). Эти темы разобраны в конспектах по JS, а тут просто демонстрация как они могут быть полезны в реакте.

## Деструктуризация пропсов

Пусть props имеет такую структуру:

```
{
  header,
  article: {
    title,
    author,
    content
  }
}
```

```react
<Info header={"Важная информация"} 
      article={{title: "О наркотиках", 
                author: "Мистер Маки", 
                content: "Наркотики - эт плохо, пнятненько?"
               }}
    />
```

Внутри компонента мы можем воспользоваться деструктуризацией, чтобы не писать каждый раз `props.`:

```react
const Info = ({header, article}) => {  // <-- Деструктуризируем пропсы
  return (
    <div>
      <h1>{header}</h1>  <!-- Теперь нет нужды писать каждый раз props. -->
      <div>{article.title}</div>
      <div>{article.author}</div>
      <div>{article.content}</div>
    </div>
  );
};
```

## Проброс пропсов дальше

Иногда компоненту нужно просто "прокинуть" полученные пропсы дальше, причем получает он их единым объектом, а прокинуть нужно по-отдельности. В этом случае помогает оператор разложения.

Например, у нас есть кастомный input, который под капотом использует стандартный реактовский инпут и вся кастомизация заключается, по сути, в добавлении класса для стилизации, а остальные пропсы надо передать как есть:

```react
function CInput(props) {  // <-- Кастомный input задает класс, чтобы применились стили
  return (
    <input className="niceCustomInput" {...props} />
  );
}

export default function App() {
  return (
    <div>
      <Gallery />
      {/* Используем кастомный input, передавая ему настройки для стандартного input'а */}
      <CInput type="text" defaultValue="carter" name="login" required />
    </div>
  );
}
```

Внутри реактовский input ожидает пропсы в виде отдельных атрибутов type, defaultValue, name и required и т.д. Но CInput получает их пачкой, в props. Значит нам пришлось бы написать что-то вроде этого:

```react
function CInput(props) {
  return (
    <input className="customInput" 
           type={props.type} defaultValue={props.defaultValue}
           name={props.name} required={props.required} />
           // Либо деструктурировать props и все равно писать передачу вручную
  );
}
```

Однако в конструкции `<input className="niceCustomInput" {...props} />` с помощью оператора разложения `{...props}` мы превращаем ее по сути в такую:

```react
<input className="niceCustomInput" type="text" defaultValue="carter" name="login" required />
```

## Сбор разбитых пропсов вместе

Оператор разложения удобно использовать в комбинации с деструктуризацией. Мы можем выдрать из пропсов отдельные поля, а остальные собрать обратно в объект с помощью оператора разложения. Например:

```react
function CInput({className='niceCustomInput', ...rest}) {  // <-- Выдираем className из пропсов, а остальное собираем в rest
  return (
    <input className={className} {...rest}  />
  );
}

export default function App() {
  return (
    <div>
      <Gallery />
      <CInput type="text" defaultValue="carter" name="login" required />
    </div>
  );
}
```

Допустим, мы хотим проверить, задан ли для компонента класс и если не задан, то поставить значение по умолчанию. Для этого нам нужно извлечь из пропсов className и проверить его, однако если при деструктуризации мы укажем только className, то остальные пропсы потеряются. При этом мы достоверно не знаем, какие остальные атрибуты задаст пользователь компонента. Т.е. задача такая "проверить className, а остальное передать дальше как есть".

В этом нам опять поможет оператор разложения. Конструкция `function CInput({className='niceCustomInput', ...rest})` приведет к тому, что className извлечется из пропсов в отдельный параметр, а все остальные атрибуты (в данном примере это type, defaultValue, name, required) соберутся в параметр rest. И если окажется, что className не передали, то параметр className получит значение по умолчанию "niceCustomInput". Оставшиеся параметры мы передаем в input как есть, деструктурируя rest.

# Направление передачи пропсов

> В этой демке используется управляемый компонент - в Capture обработчиком изменения input'а является функция установки состояния. Про управляемые компоненты есть отдельный конспект.

Пропсы передаются от родителя к ребенку, обратная передача невозможна, потому что дети очевидно не знают где они используются.

Передача в обратную сторону возможна через колбэки. Если родитель передает ребенку колбэк через пропсы, то ребенок может этот колбэк вызвать и передать в него нужные родителю данные.

Например:

```react
import {useState} from 'react';

function Capture({sendText}) {  // <-- Дочерний компонент
  const [phrase, setPhrase] = useState('Привет, мир!');
  return (
    <>
      <input type="text" value={phrase} onChange={event => setPhrase(event.target.value)} />
      {/* Вызываем полученный от родителя колбэк, передавая в него нужные данные: */}
      <button onClick={event => sendText(phrase)}>Послать текст в родитель</button>
    </>
  );
}

export default function Display() {  // <-- Родительский компонент
  const [message, setMessage] = useState('Демо передачи данных из ребенка в родитель.');

  return(
    <>
      <div>{message}</div>
      <Capture sendText={setMessage} />  {/* <-- Передаем ребенку колбэк */}
    </>
  )
}
```

Здесь у нас родительский компонент Display и в нем состояние в виде message, которое мы хотим изменить из дочернего компонента Capture. Для этого мы передаем ему через пропсы функцию изменения состояния setMessage, а он вызывает ее при щелчке на кнопку, передавая ей значение из своего поля. Таким образом данные из Capture попадают в Display и там отображаются.

# Стандартные пропсы

## children

Пропс `children` содержит в себе контент компонента ("текст", содержимое между парными тегами). Например:

```react
<MyButton disabled>Создать</MyButton>
```

```react
const MyButton = ({children, ...rest}) => {
  return (
    <button {...rest}>{children}</button>
  );
};
```

Здесь children будет содержать надпись "Создать". Т.о. мы можем передать в реактовскую кнопку текст, использованный в кастомной кнопке. Аналогично работает и для более сложных случаев. children содержит всю структуру внутри парного тега. Если там будет объемный JSX, мы точно также можем получить его через children.
