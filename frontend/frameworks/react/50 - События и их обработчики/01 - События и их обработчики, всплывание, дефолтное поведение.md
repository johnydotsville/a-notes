# Навешивание обработчика на событие

С некоторыми компонентами связаны определенные события. Например, кнопка и событие щелчка по ней. С этим событием мы можем связать нужную нам функцию ("повесить обработчик") и она будет выполняться, когда произойдет событие. Например:

```react
export default function Greeter() {
  function handleGoodbyeClick() {
    console.log('Пока!');
  }
    
  function handleCustomGoodbyeClick(message) {
    console.log(message);
  }

  return (
    <>
      <button onClick={() => console.log('Привет!')}>Приветствие</button>
      <button onClick={handleGoodbyeClick}>Прощание</button>
      <button onClick={() => handleCustomGoodbyeClick('До свидания!')}>Особое прощание</button>
    </>
  )
}
```

На первую кнопку мы повесили обработчик с помощью лямбды, а на вторую - просто указав функцию для вызова. Важно! Мы не вызываем здесь функцию, а именно указываем, т.е. пишем не `handleGoodbyeClick()`, а `handleGoodbyeClick`. Если нужно вызвать обработчик с каким-то параметром, то пользуемся лямбдой, как в третьей кнопке.

Функции-обработчики обычно объявляются внутри компонента. Им можно давать имена по шаблону `handleИмяСобытия`.

# Передача обработчиков через пропсы

Через пропсы можно передавать не только данные для отображения, но и функции. Обычно компоненты нижнего уровня ничего не знают о состоянии компонентов верхнего, но при этом должны запускать действия на основе этого состояния.

Например, пусть у нас есть список песен и каждую песню можно воспроизвести или скачать с помощью соответствующей кнопки. Эта кнопка должна запускать функцию скачивания или воспроизведения, передавая ей id нужной песни. Но откуда кнопке знать, с какой песней она связана?

Задача решается передачей кнопке готовой функции, которая навешивается на событие щелчка. Т.о. кнопка просто запускает функцию с правильным id, хотя сама ничего о песнях не знает.

```react
import {useState} from 'react';

function Button({children, onPress}) {  // <-- Базовая кнопка "глупая"
  return <button onClick={onPress}>{children}</button>
}

function PlayButton({onPlay}) {  // <-- Эта кнопка ничуть не умнее
  return <Button onPress={onPlay}>Воспроизвести</Button>
}

function DownloadButton({onDownload}) {  // <-- И эта тоже
  return <Button onPress={onDownload}>Скачать</Button>
}

// <-- А вот компонент Track в курсе, с какой песней он связан
// <-- Синтаксис вложенной деструктуризации см. в конспекте по языку
function Track({song: {id, artist, track}}) {
  function handlePlayClick(songId) {
    console.log('Воспроизводится песня с id ' + songId);
  }

  function handleDownloadClick(songId) {
    console.log('Скачивается песня с id ' + songId);
  }

  return (
    <div>
      <div>{artist} - {track}</div>
      {/* Передаем "глупцам" нужные функции */}
      <PlayButton onPlay={() => handlePlayClick(id)} />
      <DownloadButton onDownload={() => handleDownloadClick(id)} />
    </div>
  )
}

export default function Player() {
  const [songs, setSongs] = useState([
    {id: 10, artist: 'Marilyn Manson', track: 'Great big white world'},
    {id: 20, artist: 'Slipknot', track: 'Psychosocial'},
    {id: 30, artist: 'Nirvana', track: 'Smells like teen spirit'}
  ]);
  
  return (
    <>
      { songs.map(s => <Track key={s.id} song={s} />) }
    </>
  );
}
```

Что здесь примечательного:

* В собственных компонентах мы можем использовать любые названия для событий, которые нам кажутся логичными. P.S. Правда "свои события" это громко сказано, потому что по сути это просто пропс с функцией, которую мы в конечном итоге кладем в настоящее событие базового компонента.
* Компонент Player содержит данные о песнях.
  * Компонент Track содержит логику для воспроизведения и скачивания песни, а также визуально представляет песню.
    * Эту логику в виде готовых для вызова функций он передает кнопкам, которые о песнях ничего не знают, но тем не менее должны запускать их скачивание и воспроизведение.

# Сайд-эффекты

Обработчики событий - хорошие места для выполнения сайд-эффектов.

# Объект события, e

При возникновении каждого события формируется объект `event`. Этот объект передается в обработчик и мы можем его получить, если объявим обработчик с параметром. Обычно этот параметр называется `e`, от **e**vent. 

Что интересного в этом компоненте:

* Свойство `target` - содержит объект, в котором произошло событие.
* Методы:
  * `.stopPropagation()` - препятствует всплытию события вверх по дереву компонентов.
  * `.preventDefault()` - отключает вызов дополнительного стандартного поведения, если оно существует. Например, при отправке формы таким поведением является перезагрузка страницы.

Например, получим заголовок кнопки, по которой щелкнули:

```react
export default function EventInfo() {
  const handler = (e) => {  // <-- Получаем объект события в обработчике
      console.log('Обработка щелчка по кнопке ' + e.target.innerText);
  };
  return <button onClick={handler}>Просто кнопка</button>
}

// Вывод:
// Обработка щелчка по кнопке Просто кнопка
```

# Всплытие события (event propagation)

Вложенные друг в друга компоненты образуют дерево. Событие "всплывает" (это называется event propagation) по дереву компонентов вверх, начиная от компонента, где оно непосредственно возникло, и до самого верхнего. Например, если у нас много вложенных div'ов и мы щелкнем по самому внутреннему, то будет считаться, что мы щелкнули и по всем div'ам, в которые он вложен. Исключение (в реакте) - событие `onScroll`. Например:

```react
function CompA() {
  const handler = () => { console.log('Обработка щелчка по div в компоненте CompA') }
  return (
    <div onClick={handler}>
      <button onClick={() => console.log('Обработка щелчка по кнопке')}>Всплывающее событие</button>
    </div>
  );
}

export default function Propagation() {
  const handler = () => { console.log('Обработка щелчка по div в компоненте Progapation') }
  return <div onClick={handler}><CompA /></div>
}
```

Нажав на кнопку, мы увидим такую последовательность сообщений:

```
Обработка щелчка по кнопке
Обработка щелчка по div в компоненте CompA
Обработка щелчка по div в компоненте Progapation
```

Возникнув в кнопке, событие onClick выполнилось также и во всех элементах, в которые эта кнопка вложена.

## Запрет всплытия

Если мы хотим, чтобы какой-то компонент обработал событие, но выше оно не пошло, то в этом компоненте в обработчике события вызываем метод `stopPropagation()` на объекте события:

```react
function CompA() {
  const handler = () => { console.log('Обработка щелчка по div в компоненте CompA') }
  return (
    <div onClick={handler}>  {/* F */}
      <button onClick={e => {
          e.stopPropagation();  {/* <-- Запретили событию всплывать выше */}
          console.log('Обработка щелчка по кнопке');
        }}>Всплывающее событие</button>
    </div>
  );
}

export default function Propagation() {
  const handler = () => { console.log('Обработка щелчка по div в компоненте Progapation') }
  return <div onClick={handler}><CompA /></div>
}

// Вывод:
// Обработка щелчка по кнопке
```

Событие обработается на кнопке, но выше не пойдет. Если бы мы хотели, чтобы событие всплыло, например, до компонента CompA, но не дошло до компонента Propagation, тогда нужно было бы вызвать метод stopPropagation() в обработчике, отмеченном в примере комментарием `F`.

# Дефолтное поведение

С некоторыми событиями связано т.н. дефолтное поведение - дополнительные действия, которые вызываются автоматически при возникновении события. Например, при отправке формы страница перезагружается:

```react
export default function Behavior() {
  function handleSubmit(e) {
    console.log('Обработка отправки формы');
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" placeholder="Введите что-нибудь" />
      <button type="submit">Отправить</button>  {/* <-- Страница перезагрузится при нажатии */}
    </form>
  );
}
```

Если это поведение является нежелательным, его можно отключить с помощью метода `.preventDefault()` на объекте события. Вызывать его можно так:

```react
export default function Behavior() {
  function handleSubmit(e) {
    e.preventDefault();  // <-- Отключаем дефолтное поведение, теперь страница не перезагрузится
    console.log('Обработка отправки формы');
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" placeholder="Введите что-нибудь" />
      <button type="submit">Отправить</button>
    </form>
  );
}
```