# Извлечение стилей

Изначально, если не предпринимать никаких действий, то стили, которые мы описываем в css-файлах, после сборки оказываются в коде бандла. Т.е. по сути становятся частью js-скрипта. В этом можно убедиться, если собрать проект (не важно, в dev- или prod-режиме), открыть бандл и через поиск попробовать найти какой-нибудь css-класс.

С помощью плагина `MiniCssExtractPlugin` мы можем извлечь стили в отдельные файлы. Такой подход имеет следующие преимущества:

* Возможность кэшировать файл со стилями.
* Побороть проблему *Flash of Unstyled Content* (`FOUC`), когда страница появляется на короткое время с дефолтными стилями браузера.

TODO: можно потом разобраться подробнее в этой теме.

# Плагин MiniCssExtractPlugin

## Пакеты

| Плагин               | Документация                                                 | Замечания                    |
| -------------------- | ------------------------------------------------------------ | ---------------------------- |
| MiniCssExtractPlugin | [Документация](https://webpack.js.org/plugins/mini-css-extract-plugin/) | Работает только с webpack 5. |

```
npm i -D mini-css-extract-plugin
```

В документации много примеров на разные случаи, на совместное использование с другими лоадерами \ плагинами.

## webpack.config.js

```javascript
import MiniCssExtractPlugin from "mini-css-extract-plugin";  // <-- ES6-стиль.
const MiniCssExtractPlugin = require("mini-css-extract-plugin");  // <-- CommonJS-стиль.
```

Есть базовое правило:

* Не использовать MiniCssExtractPlugin одновременно со style-loader. TODO: почему?

style-loader подходит для dev-режима, а для prod - извлечение стилей. Поэтому можно добавить условие в конфиг вебпака, чтобы в каждом режиме использовался нужный подход:

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");  // <-- Импортируем плагин

module.exports = (settings, argv) => {
  const isDev = argv.mode === "development";
  const isProd = argv.mode === "production";

  // <-- Создаем и настраиваем экземпляр плагина
  const miniCss = new MiniCssExtractPlugin({
    filename: "css/[name].[contenthash:8].entry.css",  // <-- Для файла точки входа.
    chunkFilename: "css/[name].[contenthash:8].chunks.css"  // <-- Для "ленивых чанков".
  });

  return {
    // Остальная часть конфига
    plugins: [
      isProd ? miniCss : false  // <-- Используем miniCss только в проде.
      // Остальные плагины
    ],
    module: {
      rules: [
        // Лоадеры для остальных файлов
        {  // <-- В лоадере для стилей либо style-loader, либо MiniCssExtractPlugin.loader
          test: /\.s[ac]ss$/i,
          use: [
            isDev ? "style-loader" : MiniCssExtractPlugin.loader,
            "css-loader",
            "sass-loader"
          ]
        },
      ],
    }
  }
};
```

## Комментарии

В папку с демками я положил папку `style_extraction`, там два примера - без чанков и с чанками. Если эти примеры сбилдить, то по результирующим файлам можно убедиться в нижеописанных фактах:

* При билде проекта стили оформляются в отдельный файл, вместо того, чтобы встраиваться в исходный код бандла.

* Файл появляется в директории рядом с бандлом и подключается к html.

* На каждый js-файл, использующий стили, формируется отдельный css-файл. Например, пусть у нас много компонентов и каждый компонент использует свой собственный файл со стилями. При этом мы не делаем "чанкинг" (дальше есть конспект про ленивые чанки и разбиение приложения на части). Тогда из всех этих компонентов при билде получается единственный js-файл. Соответственно, и css-файл тоже получится один. Причем в него сольется содержимое всех отдельных css-файлов, которыми пользовались компоненты.

  Если же мы делаем чанкинг, тогда у нас получится больше одного js-файла и, соответственно, столько же css-файлов. При этом к index.html подключится только файл со стилями, относящийся к главному файлу бандла (точка входа). Остальные файлы стилей будут подключаться программно, это можно увидеть если открыть главный файл бандла и поискать там по названию чанковых css-файлов.

Заморачиваться с настройками пока смысла нет. Хватает будто и этих двух, с именами файлов для точки входа и для чанковых.