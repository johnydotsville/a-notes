# Идентификатор запроса, queryKey

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],    // <-- Идентификатор запроса.
  queryFn: async () => {
    const result = await fetch(`${baseUrl}/tasks`)
    return result.json();
  }
});
```

Идентификатор запроса позволяет RQ отличать запросы друг от друга. Когда благодаря идентификатору выясняется, что какой-то запрос уже выполнялся, то результат просто берется из кэша.

queryKey выполнен в виде массива. Каждый элемент имеет свое назначение:

* Первый - обычно позиционируется как идентификатор группы запросов. Обычно строка.

* Второй и последующие - идентификаторы запросов внутри группы. Должны быть или примитивными значениями, или объектами которые легко сериализуются (т.е. поля объекта должны быть примитивами). Не допускаются сложные объекты вроде функций и т.д.

  ```javascript
  queryKey: ["books"]  // 1
  queryKey: ["books", authorId]  // 2
  queryKey: ["books", genre]     // 3
  queryKey: ["books", authorId, genre]  // 4
  ```

> P.S. Вообще, каждый элемент равнозначен. Первый не обязан быть строкой, просто это является хорошей практикой, первым элементом определять как бы семейство похожих запросов. Например, "books", "posts", "employees" и т.д.

Идентификатора группы достаточно, когда у нас нет необходимости как-то дополнительно уточнять запрос. 

Например, на странице отображается каталог книг, просто книги которые можно почитать. Для такой страницы подойдет запрос [1].

Мы нажимаем на книгу и переходим на страницу с ее описанием. У книги очевидно есть жанр и автор. Поэтому на странице этой книги можно разместить например такие компоненты:

* Все книги этого автора. Тут подойдет запрос [2].
* Книги других авторов такого же жанра. Тут запрос [3].
* Книги этого автора в таком же жанре, как и эта. Тут запрос [4].

Например, мы зашли на страницу книги "Путешествие к центру Земли". Жанр - фантастика, автор - Жюль Верн. У нас сработали запросы 2, 3, 4. В списке книг такого же жанра мы щелкнули на книгу "Машина останавливается", автор Эдвард Морган Форстер, но жанр тоже фантастика. Поэтому когда откроется страница этой книги, то выполнялся два запроса - список книг Форстера и список Форстер + фантастика, а просто список "фантастика", без уточнения автора, уже возьмется из кэша.

# Способы оформления queryKey

Как уже говорилось, в массиве queryKey должны быть значения, которые легко сериализовать.

Есть два концептуальных подхода к оформлению:

* Отдельными примитивными значениями `queryKey: ["posts", priority, tags ]`
* Объектом с полями `queryKey: ["posts", { priority, tags }]`

Зачастую, если мы пишем в queryKey какие-то идентификаторы, то функция выборки данных зависит от них и хочет получать их в виде параметров. Подробнее о параметрах в конспекте про написание функции выборки.

Суть в том, что если идентификаторы указаны как отдельные примитивы, то мы становимся зависимы от их порядка, т.к. деструктурируя массив queryKey получаем элементы в порядке их следования, и если потом добавим в queryKey новый элемент, порядок может сломаться.

Если же мы оформляем индентификаторы как объект, нам становится проще деструктурировать, т.к. мы используем имена полей.

TODO: сейчас трудно формулировать и привести пример. Потом скопировать хороший пример, когда попадется.

