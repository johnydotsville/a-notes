# Хук useMutation, базовый пример

Пример кастом-хука, в котором инкапсулировано использование хука useMutation:

```javascript
export const useDeleteTask = () => {
  const client = useQueryClient();

  const deleteTaskMutation = useMutation({
    mutationFn: deleteTask,
    onSuccess: () => client.invalidateQueries({ queryKey: ['tasks'] })
  });

  return {
    fnDeleteTask: (id: number) => deleteTaskMutation.mutate(id)
  }
}
```

Функция, непосредственно выполняющая удаление:

```typescript
export async function deleteTask(id: number) {
  const url = `http://localhost:3001/tasks/${id}`;
  const response = await fetch(url, { method: 'DELETE' });

  if (!response.ok) {
    throw new Error(`Не удалось удалить задачу ${id}`);
  }
  return true;
}
```

# Артефакты useMutation

* useMutation возвращает объект с артефактами вроде isSuccess, mutate.
  * Этот объект обычно не принято деструктурировать.
  * Переменную под этот объект принято именовать по шаблону `действиеMutation`. Например, если назначение мутации - это удалить задачу из списка задач, то имя переменной будет `deleteTaskMutation`.

## Доступные артефакты

* `mutate()` - функция, которая вызывает mutationFn.
* TODO



# Выполнение мутации

* Для выполнения мутации нужно вызвать артефакт-функцию `.mutate(x)`

  * Переданный ей параметр уходит в mutationFn.
    * Если параметров много, лучше оформить их в виде объекта.

  

## Как отобразить изменения, сделанные мутацией

* Когда мутация выполнена, для отображения изменений в интерфейсе есть несколько путей:
  * Пессимистичное обновление - ждем пока сервер выполнит операцию и вернет ответ, потом обновляем интерфейс.
    * Инвалидировать кэш, чтобы RQ запросил данные повторно.
  * Оптимистичное обновление - сразу обновляем интерфейс, не ожидая ответа сервера. Если вдруг ответ сервера "противоречит" выполненным изменениями, откатываем их.

# Функция mutationFn

## Правила оформления

Функция mutationFn:

* Должна быть асинхронная.
* Должна возвращать что-то, что может быть расценено как true. Т.е. нельзя не вернуть ничего, потому что тогда не сработает колбэк onSuccess.
  * Это значение можно получить через параметр onSuccess.

## Ошибки в mutationFn

* Если в mutationFn возникает ошибка, RQ ловит ее и передает в коллбэк onError.





# Общие советы

* Каждое действие оформлять в виде отдельной мутации.









# Черновик







## Передать несколько параметров в mutate

Делается через объект.

```typescript
export const useDeleteTask = () => {
  const client = useQueryClient();

  const deleteTaskMutation = useMutation({
    mutationFn: ({ id, fail }: { id: number, fail: boolean }) => deleteTask(id, fail),
    onSuccess: () => client.invalidateQueries({ queryKey: ['tasks'] })
  });

  return {
    fnDeleteTask: (id: number) => deleteTaskMutation.mutate({ id: id, fail: true })
  }
}
```





# Лог

## useMutation

- [x] Возвращает объект с типичные артефакты.

  - [x] isPending, 
  - [x] Деструктурировать не принято, без ДП лучше читаемость.

- [x] Хорошие практики.

  - [x] Паттерн именования "действиеMutation", пример deleteTaskMutation.
  - [x] На каждое разные действия - собственная мутация.
  - [x] Параметры мутации передавать в виде объекта, особенно когда параметров несколько.

- [ ] Механики.

  - [ ] ??? Ререндер при изменении состояний мутации. Погуглить лучше, про оптимизации и как избежать ререндера.
  - [ ] ??? Что является признаком успешной | неуспешной мутации?

- [ ] TODO

  - [x] Как оформить функцию мутации, что она должна возвращать?

  - [ ] Если мутация удаляет данные, то как правильно это все провернуть?

    - [ ] Инвалидировать кэш и запросить данные повторно с сервера? Или просто точечно удалить из кэша тоже? У обоих подходов есть плюсы и минусы.

  - [x] ??? Что такое оптимистичное и пессимистичное обновление \ удаление?

    

- [x] Надо ли инвалидировать кэш вручную после запроса мутации?

- [x] Инвалидация - пометка данных как устаревших, флаг isStale: true.

- [ ] Зачем в useMutation поле mutationKey?





