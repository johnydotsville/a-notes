# Активные и неактивные данные

* `Активные` данные: когда какой-то компонент использует хук useQuery и загружает данные, то он тем самым подписывается на эти данные и они считаются активными.
* `Неактивные` данные: когда компонент размонтируется, тогда происходит отписка от данных. Когда у данных не остается ни одного подписчика, эти данные становятся неактивными.

# gcTime и staleTime

P.S. gcTime (garbage collect Time) раньше называлось cacheTime.

* `gcTime` - это время хранения *неактивных* (inactive) данных или проще говоря "сколько времени хранить данные, когда у них не осталось подписчиков".
  * Начинает тикать с момента, когда у данных не остается ни одного подписчика.
  * Дефолт 5 минут. Если за это время никто к ним не обратится, то сборщик мусора их удалит.
* `staleTime` - это время устаревания *активных* данных или проще говоря "через сколько времени перезагрузить данные с сервера, если у них есть подписчики".
  * Тикает, пока данные активны, т.е. пока у них есть подписчики.
  * Дефолт 0. Как только это время прошло, RQ `инвалидирует` данные, т.е. помечает их как устаревшие. Когда компонент-подписчик попробует обратиться к ним, то RQ запустит функцию загрузки повторно, чтобы загрузить актуальную версию данных.

В целом, gcTime и staleTime друг с другом непосредственно не связаны. Например, если данные стали неактивными, а мы вручную сделали рефетч, то это не сделает их активными.

# Вопросы и ответы

## staleTime = 0 - зачем?

* [x] Какой смысл в том чтобы помечать данные как устаревшие сразу после загрузки? Разве это не приведет к повторной загрузке и лишним рендерам?

Не приведет. Работает так: компонент Foo запрашивает данные 'tasks'. В кэше их нет, RQ запрашивает их с сервера. Компонент Bar тоже запрашивает данные 'tasks'.

Ситуация 1: данные еще не выбрались. Второй запрос не создается, т.е. оба компонента взаимодействуют с одним запросом. Когда они выберутся, компоненты получат уведомление и перерендерятся.

Ситуация 2: данные уже готовы, когда Bar к ним обращается, но помечены как устаревшие. Bar получает "старые" данные из кэша, а RQ вновь вызывает функцию запроса данных.

Когда данные приходят, RQ сравнивает их с теми, что уже лежат в кэше. Если выясняется, что данные пришли те же самые, то RQ не оповещает компоненты. Если данные изменились, тогда оповещает и происходит повторный рендер. И там уже сам react проверяет, нужно ли вносить изменения в реальный DOM или нет. Например, хоть данные пришли новые, но по результатам расчетов оказывается, что в интерфейсе все то же самое. Например, количество товара стало меньше, но не настолько, чтобы заменять надпись "Наличие: много", на "Наличие: мало".
