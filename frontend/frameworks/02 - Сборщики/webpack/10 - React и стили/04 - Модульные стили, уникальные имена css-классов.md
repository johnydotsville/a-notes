# Модульные стили

Модульные стили (в конспекте по реакту тоже есть такая тема), нужны для того, чтобы в итоговой html-разметке имена стилей были уникальные. Если не использовать модульные стили, а просто писать имена css-классов для указания стиля элементам, то может получиться так, что где-то имя получится не уникальное и возникнет конфликт. Теоретически, это может случиться даже при использовании БЭМ-методологии. Поэтому модульные стили помогают с технической точки зрения сгенерировать гарантированно уникальные имена для css-классов.

# Настройка

В папке с демками есть демка с полной версией проекта.

## Файл стилей

Создаем файл стилей, например, `App.module.css`. Суффикс module является техническим соглашением, поэтому является обязательным при использовании модульных стилей:

```css
.card {
  display: inline-block;
  border: 2px solid black;
  background-color: antiquewhite;
}

.cardSpace {
  padding: 15px;
  margin: 15px;
}

.header {
  text-decoration: underline; 
}
```

## Компонент

Создадим компонент `App.tsx`, в котором подключим стили и применим их к элементам. typescript будет ругаться на такой импорт, но потом мы создадим ему описание:

```react
import * as styles from "./App.module.css";

export default function App() {
  return (
    <div className={`${styles.card} ${styles.cardSpace}`}>
      <h1 className={styles.header}>Hello, webpack!</h1>
      <p>Пример на использование модульных стилей.</p>
    </div>
  )
}
```

## global.d.ts

Чтобы ts понимал импорт в модульном стиле, создадим в корне проекта файл `global.d.ts`:

```typescript
declare module "*.module.css" {  // <-- Внимание на расширение.
  interface IClassNames {
    [className: string]: string
  }
  const classNames: IClassNames;
  export = classNames;
}
```

Если в проекте используется scss, то и расширение в данной конфигурации нужно указывать нужное.

## webpack.config.js

Чтобы имена для css-классов изменились, нам нужно выполнить дополнительную настройку css-лоадера. Именно он отвечает за именование. Кроме того, чтобы можно было наглядно увидеть, во что превратились имена, мы еще поставим плагин извлечения стилей в отдельный файл `npm i -D mini-css-extract-plugin` 

> Про MiniCssExtractPlugin есть отдельный конспект, в котором показаны его настройки и дополнительные важные вещи. Здесь они не нужны, поэтому тут про него ничего не объясняется.

Фрагмент конфига с нужными настройками:

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");  // <-- Импортируем плагин извлечения стилей.

module.exports = (settings, argv) => {
  const isDev = argv.mode === "development";
  return {
    // Остальная часть конфига
    plugins: [
      htmlWebpack,
      new MiniCssExtractPlugin()  // <-- Регистрируем плагин извлечения стилей.
    ],
    module: {
      rules: [
        // Остальные лоадеры
        {
          test: /\.css$/i,
          use: [
            MiniCssExtractPlugin.loader,  // <-- Применяем лоадер плагина извлечения стилей.
            {
              loader: "css-loader",  // <-- Настраиваем css-лоадер для преобразования имен.
              options: {
                modules: {
                  localIdentName: isDev ? "[path][name]__[local]" : "[hash:base64:8]"
                },
              }
            }
          ],
        }
      ],
    }
  }
};
```

Как будут выглядеть стили:

* Конструкция `[path][name]__[local]` даст имя вроде `src-components-App-module__message`:
  * Структура названия:
    * `scr-components` - это path, по нему можно понять, в какой директории лежит файл стилей.
    * `App-module` - это name, имя файла стилей (без расширения).
    * `message` - это селектор внутри самого файла стилей.
* Конструкция `[hash:base64:8]` даст имя вроде `z2KE00Yy`. Это фрагмент хэша, для каждого селектора он не будет повторяться.

Про localIdentName можно почитать [тут](https://webpack.js.org/loaders/css-loader/). Пока необходимости читать детально вроде бы нет.

## Проверяем

Теперь можно сбилдить проект в dev- и prod-режимах и посмотреть в извлеченном файле стилей, какие имена получают селекторы.