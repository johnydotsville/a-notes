# Синхронная перемотка

Зачем нужно:

* Тестируем код с таймаутами/задержками без реального ожидания.
* Избегаем долгих тестов (иначе тест упадёт по таймауту).
* Контролируем время детерминированно.

```typescript
it('Таймаут', async() => {
  vi.useFakeTimers();  // <-- Используем фейковые таймеры.
  
  try {
    mockApi(new Promise(() => { }));
  
    const promise = fetchData<Task[]>(url.toString());  // <-- Здесь без await.
    vi.advanceTimersByTime(6000);  // <-- Перематываем время.

    const error = await promise.catch(err => err);  // <-- Ждем промис после перемотки.

    expect(error).toBeInstanceOf(Error);
    expect(error).toMatchObject({ message: 'Попробуйте еще раз позже.' });
  } finally {
    vi.useRealTimers();  // <-- Возвращаем реальные таймеры.
  }
});
```

Как работает:

* Активируем фейковые таймеры.
  * Они устанавливаются глобально, на всю сессию тестирования. Поэтому их важно возвращать к нормальным.
* Сначала создаем промис, но (важно!) не дожидаемся его.
* Проматываем время.
* Теперь дожидаемся промис.
* В конце деактивируем фейковые таймеры.

Важные замечания:

* Возвращать реальные таймеры в finally - стандартная практика. Фреймворк каждый тест проводит независимо и в целом таймеры одного теста не повлияют на другие, поскольку фреймворк их восстановит, но в некоторых случаях он может все же не восстановить, если специально его настроить. Поэтому лучше явно возвращать реальные таймеры, чтобы наверняка.
  * Если фейковые таймеры используются очень часто, можно поместить их в beforeAll \ afterAll.

```typescript
beforeAll(() => vi.useFakeTimers());
afterAll(() => vi.useRealTimers());
```

