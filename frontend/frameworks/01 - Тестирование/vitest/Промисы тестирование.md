При тестировании промисов есть два стиля.

# Стиль 1: Тестирование самого промиса

```typescript
const promise = fetchData<Task[]>(url.toString());

await expect(promise).rejects.toThrow(Error);
await expect(promise).rejects.toMatchObject({ message: 'Попробуйте еще раз позже.' });
```

Как работает:

* В expect передаем промис.
  * В этом случае он возвращает thenable-обертку.
  * У этой обертки есть свойства rejects и resolves. В них лежит матчер.
    * У этого матчера есть привычные методы проверок.
* Особенности:
  * Надо обязательно дожидаться обертку каждый раз. Т.е. даже если промис завершенный, все равно надо использовать await, потому что иначе получим ложно-успешный тест.
  * Методы матчера нельзя чейнить (но это с промисами не связано, их в принципе нельзя чейнить, все они возвращают void).

Когда использовать:

* В простых сценариях, когда надо проверить какое-то *одно* базовое условие. Например, что промис возвращает какое-то значение или выбрасывает исключение.
  * Если условий несколько, то лучше использовать стиль 2. В примере выше видно, что для каждой проверки приходится заново дожидаться обертку, что есть не комильфо.

# Стиль 2: Тестирование результата промиса

```typescript
const promise = fetchData<Task[]>(url.toString());
const error = await promise.catch(err => err);
// const result = await promise.then(res => res);

expect(error).toBeInstanceOf(HttpError);
expect(error).toMatchObject({ message: expectedMessage });
```

Как работает:

* Извлекаем ошибку \ результат из промиса.
  * Тут например с помощью catch ловим ошибку и делаем ее результатом колбэка. И через await извлекаем в переменную.
* Тестируем ошибку \ результат непосредственно.

Когда использовать:

* Когда нужны множественные проверки, проще извлечь результат и гонять его как обычное значение.

# Итого

Концептуально тестирование промисов не отличается от тестирования обычных значений. Матчеры все те же самые. Единственная разница в том, что надо с помощью rejects \ resolves их вызывать и дожидаться.