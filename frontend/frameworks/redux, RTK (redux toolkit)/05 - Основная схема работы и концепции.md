# Зачем нужен Redux

Суть использования редакса - это вынести общее состояние в отдельный объект и предоставить всем компонентам удобный доступ к этому состоянию. Общее состояние - это то, которое может понадобиться компонентам на разных уровнях вложенности - как самым высоким, так и очень глубоко вложенным. Для того, чтобы не пришлось прокидывать это состояние сквозь десятки компонентов через пропсы, и существует редакс.

При этом у компонентов может быть и свое локальное состояние. Если вдруг оно не нужно никому, кроме самого компонента и пары его дочек, то нет смысла выносить такое состояние в общее хранилище.

# Redux

## Концепции

### Фрагмент состояния

`Фрагменты` - можно назвать "кусочками", из которых собирается итоговое состояние. Пример двух фрагментов:

```javascript
export const initialStatePerson = {
  firstname: null,
  lastname: null
}
```

```javascript
export const initialStateExperience = {
  lookingForJob: false,  // <-- Ищет ли работу
  workedFor: []  // <-- Где работал
};
```

### Редюсер

`Редюсер` - это функция, которая обрабатывает состояние. Если состояние сформировано из нескольких фрагментов, то для каждого фрагмента пишется свой редюсер, а потом они объединяются в `корневой редюсер`.

Схема работы редюсера:

* Принимает действие (`action`).
* Решает, должен ли он это действие обработать.
  * Редюсер понимает, должен ли он обрабатывать действие, по `типу` этого действия.
  * Если должен, то извлекает из действия `нагрузку`, применяет ее к своему фрагменту состояния и возвращает его новую версию.
  * Если не должен, то возвращает свой фрагмент состояния в неизмененном виде.

Технически, можно представить что все редюсеры объединяются в этакую вертикальную "трубу". Сверху в нее забрасывается действие и оно летит сквозь все редюсеры до самого низа. Когда действие "пролетает" очередной редюсер, он выплевывает свой фрагмент состояния (измененный или нет), и все эти плевки собираются в единый целостный комок состояния.

Первый параметр редюсера - это фрагмент состояния, за которое редюсер ответственный. Ему присваивается дефолтное значения и при объединении редюсеров из этих фрагментов собирается целостное состояние.

В редюсерах не должно быть сайд-эффектов. Это чистые функции. Асинхронные действия, в которых нужны например запросы на сервер, обрабатываются особым образом с помощью специальных библиотек, о которых отдельный конспект.

```javascript
export const reducerPerson = (state = initialStatePerson, action) => {  // <-- Дефолт для фрагмента
  switch (action.type) {  // <-- Проверяем тип действия.
    case 'SET_FIRSTNAME':  // <-- Пишем типы действий, на которые редюсер должен реагировать.
      return {  // <-- Формируем фрагмент состояния
        ...state,  // <-- Не теряем то, что уже было в фрагменте.
        ...action.payload  // <-- Добавляем данные из нагрузки.
      };
    case 'SET_LASTNAME':
      return {
        ...state,
        ...action.payload
      };
    default:  // <-- Если редюсер не реагирует на действие, возвращает свой фрагмент как есть.
      return state;
  }
};
```

```javascript
export const reducerExperience = (state = initialStateExperience, action) => {
  switch (action.type) {
    case 'JOB_APPLY':
      return {
        ...state,
        workedFor: [action.payload.current, ...state.workedFor]
      };
    case 'LOOKING_FOR_JOB':
      return {
        ...state,
        lookingForJob: !state.lookingForJob
      }
    default:
      return state;
  }
}
```

### Корневой редюсер

`Корневой редюсер` нужен:

* Для объединения всех редюсеров в единую "трубу", через которую полетят действия.
* Указания полей состояния, в которых будут хранится фрагменты состояния.

```javascript
import { combineReducers } from 'redux';

export const rootReducer = combineReducers({
  person: reducerPerson,  // <-- "Person-фрагмент" попадет в итоговое состояние в поле person
  experience: reducerExperience  // <-- "Experience-фрагмент" попадет в поле experience
});
```

### Action и Action-creator

`Action` - это обычный объект, в котором два общепринятых поля:

* `type` - тип действия. Обычная строка, по которой редюсер понимает, должен он реагировать на это действие или нет.
* `payload` - данные, которые переносит действие. Называют "нагрузкой".

```javascript
{
  type: 'SET_LASTNAME',
  payload: {
    lastname: 'Doe'
  }
}
```

Для создания действий пишутся action-creator'ы. Это обычные функции, которые просто возвращают объект правильной структуры:

```javascript
export const actionSetFirstname = (firstname) => {
  return {
    type: 'SET_FIRSTNAME',
    payload: {
      firstname: firstname
    }
  }
}
```

Действий можно придумать сколько угодно, зависит от того какие изменения мы хотим вносить в состояние.

```javascript
export const actionSetLastname = (lastname) => {
  return {
    type: 'SET_LASTNAME',
    payload: {
      lastname: lastname
    }
  }
}
```

```javascript
export const actionJobApply = (company) => {
  return {
    type: 'JOB_APPLY',
    payload: {
      current: company
    }
  }
}
```

```javascript
export const actionSwitchLookingForJob = () => {
  return {
    type: 'LOOKING_FOR_JOB',
    payload: { }
  }
}
```

### Хранилище и Провайдер

Для пользования состоянием в программе мы:

* Создаем хранилище.
  
  * Передаем в специальную функцию корневой редюсер и она собирает целостное состояние из фрагментов. Она прокидывает в "трубу" редюсеров тестовое действие, каждый редюсер возвращает свой фрагмент состояния и т.о. получается целостное состояние.
  
    ```javascript
    {
      person: {
        firstname: null,
        lastname: null
      },
      experience: {
        lookingForJob: false,
        workedFor: []
      }
    }
    ```
* Оборачиваем приложение в специальный компонент-провайдер, указывая ему объект хранилища.
* PROFIT! Можно пользоваться состоянием в любых компонентах приложения.

```javascript
import { createStore } from 'redux';

const myStore = createStore(rootReducer);
```

```jsx
import { Provider } from 'react-redux';

export default function ReduxBasicDemo() {
  return (
    <Provider store={myStore}>
      <App />
    </Provider>
  );
}
```

## Как пользоваться

### Отправка данных в хранилище

* Через хук `useDispatch` получаем функцию-диспетчер.
* Передаем диспетчеру действие.
  * Для создания действия пользуемся action-creator'ами.
* Редакс обновляет состояние и изменения доступны по всему приложению.

```javascript
import { useDispatch } from 'react-redux';

// В компоненте
const dispatch = useDispatch();  // <-- Получаем функцию диспетчеризации через хук.

dispatch(actionSetFirstname('John'));  // <-- Диспатчим действие.
```

### Получение данных из хранилища

* Через хук `useSelector` подписываемся на интересующую нас часть состояния.
  * Для этого просто пишем колбэк, в котором обращаемся к этой части.
* Когда эта часть изменяется, подписчик об этом узнает и перерисовывается.

```javascript
import { useSelector } from 'react-redux';

// В компоненте
const firstname = useSelector(state => state.person.firstname);
```

# Redux Toolkit

Основные концепции такие же, как в редаксе - экшены, экшен-криейторы, редюсеры.

* По умолчанию в тулките подключены:
  
  * `redux-thunk` - для диспатча асинхронных действий.
  
  * `redux devtools` - для просмотра состояния в браузере через GUI.
  
  * Библиотека `Immer`, позволяет писать редюсеры в мутирующем стиле, что гораздо удобнее. Под капотом иммер переделает эти "мутации" в создание нового объекта.
    
    Важно! Иммер автоматически работает только внутри createSlice. Но если функция большая, можно оформить ее отдельной функцией и указать в createSlice, тогда иммер все равно будет работать, т.к. "внешняя" функция все равно как бы находится внутри createSlice.

* Хранилище создается функцией `configureStore`, а не `createStore`. Отличие в том, что новая функция автоматически встраивает мидлвары танк и девтулс. В остальном можно конфигурировать как хочешь.

## Слайсы

Слайс - это дополнительная концепция от RTK. Это объект, где мы:

* Задаем начальное значение фрагмента состояния.
* Функции для работы с этим фрагментом.
* RTK автоматически собирает редюсер для фрагмента и создает action creator'ы.

```javascript
import { createSlice } from '@reduxjs/toolkit';

const slicePerson = createSlice({
  name: 'person',
  initialState: {
    firstname: null,
    lastname: null
  },
  reducers: {
    setFirstname: (state, action) => {
      state.firstname = action.payload;  // <-- Immer позволяет "мутировать" данные.
    },
    setLastname: (state, action) => {
      state.lastname = action.payload;
    }
  }
});
```

```javascript
const sliceExperience = createSlice({
  name: 'experience',
  initialState: {
    lookingForJob: false,
    workedFor: [] 
  },
  reducers: {
    jobApply: (state, action) => {
      state.workedFor.unshift(action.payload);
    },
    switchLookingForJob : state => {
      state.lookingForJob = !state.lookingForJob;
    }
  }
});
```

Самое важное тут понять как RTK формирует редюсер и action creator'ы из конструкции

```javascript
reducers: {
  setFirstname: (state, action) => {
    state.firstname = action.payload;
  },
  setLastname: (state, action) => {
    state.lastname = action.payload;
  }
}
```

RTK:

- Создаст action-creator на основе имени поля.
  
  - Это будет функция setFirstname, которая принимает один параметр с нагрузкой, например `setFirstname('John')` и возвращает action:
  
    ```javascript
    { 
      type: 'person/setFirstname',  // <-- Тип действия это "имя слайса + имя поля"
      payload: "John"
    }
    ```
  
  - Имя action'а имеет формат "имя слайса + имя свойства", фактически "имя слайса + имя action creator'а".
    
  - Аналогично для setLastname.
  
  - action creator'ы принимают единственный параметр - нагрузку. Можно отдельно через prepare настроить, чтобы было несколько параметров. Об этом в отдельном конспекте.
  
- Создаст редюсер для обработки фрагмента состояния, соберет в него функции и настроит их на реакцию на нужные типы действий.
  
  - Функция из поля
    
    ```javascript
    setFirstname: (state, action) => {
      state.firstname = action.payload;
    }
    ```
    
    Будет срабатывать на действие с типом `person/setFirstname`

## Как получить reducer и action creator'ы из слайса

```javascript
export const { setFirstname, setLastname } = slicePerson.actions;
export const reducerPerson = slicePerson.reducer;

export const { jobApply, switchLookingForJob } = sliceExperience.actions;
export const reducerExperience = sliceExperience.reducer;
```

## Как настроить хранилище

```javascript
import { configureStore } from "@reduxjs/toolkit";

const myStore = configureStore({
  reducer: { 
    person: reducerPerson,
    experience: reducerExperience
  }
});
```

Здесь ситуация как в обычном редаксе - указываем названия полей в итоговом состоянии и редюсеры, а функция configureStore получает от них начальные значения и собирает хранилище:

```javascript
{
  person: {
    firstname: null,
    lastname: null
  },
  experience: {
    lookingForJob: false,
    workedFor: []
  }
}
```

Потом передаем хранилище провайдеру:

```jsx
import { Provider } from 'react-redux';

export default function ReduxBasicDemo() {
  return (
    <Provider store={myStore}>
      <App />
    </Provider>
  );
}
```

## Как пользоваться

Точно так же как и в обычном редаксе, через useDispatch и useSelector. Например:

```javascript
import { useDispatch } from 'react-redux';

const dispatch = useDispatch();

dispatch(setFirstname('John'));
```

```javascript
import { useSelector } from 'react-redux';

const firstname = useSelector(state => state.person.firstname);
```



