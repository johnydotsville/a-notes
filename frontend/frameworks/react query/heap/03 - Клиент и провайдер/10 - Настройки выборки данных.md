# Глобальная настройка через клиент

```react
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {  // <-- Настраиваем параметры выборки данных, глобально.
      refetchInterval: 3000,
      cacheTime: 50000
    }
  }
});

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </StrictMode>,
)
```

# Настройка для конкретного запроса

TODO: возможно это стоит перенести в конспект по useQuery.

```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],
  queryFn: async () => {
    const result = await fetch(`${baseUrl}/tasks`)
    return await result.json();
  },
  refetchInterval: 3000,  // <-- Персональные настройки
  cacheTime: 50000
});
```

Замечания:

* Это синтаксис, актуальный на данный момент. Раньше был другой, сейчас он не работает.
* TS может в IDE ругаться на такую структуру настроек, но на работу не влияет.

# Доступные настройки

## cacheTime и staleTime

* `cacheTime` - это время хранения *неактивных* (inactive) данных. Дефолт 5 минут.
* `staleTime` - это время устаревания *активных* данных. Дефолт 0.

cacheTime: Когда какой-то компонент использует хук useQuery и загружает данные, то он тем самым подписывается на эти данные и данные считаются *активными*. Когда компонент размонтируется, тогда происходит отписка и данные становятся *неактивными*. И только с этого момента для них начинает тикать cacheTime. Если за это время никто к ним не обратится, то сборщик мусора их удалит.

staleTime: пока данные активны, для них тикает staleTime. Как только это время прошло, RQ *инвалидирует* данные, т.е. помечает их как устаревшие. Когда компонент-подписчик попробует обратиться к ним, то RQ запустит функцию загрузки повторно, чтобы загрузить актуальную версию данных.

Т.е. два этих параметра друг с другом непосредственно не связаны. Например, если данные стали неактивными, а мы вручную сделали рефетч, то это не сделает их активными.

## refetchInterval

TODO