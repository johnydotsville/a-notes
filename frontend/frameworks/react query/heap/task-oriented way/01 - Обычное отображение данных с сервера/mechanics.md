# Механики

## Компонент

```javascript
useQuery({
  queryKey: ["tasks"],
  queryFn: () => fetchTasks({ limit: 4 })
});
```

* useQuery - основной хук для запроса данных.
  * queryKey - идентификатор запроса.
    * Хук сохраняет данные в кэше под указанным идентификатором.
    * При использовании useQuery всегда надо указывать идентификатор, поэтому если кто-то вызывает хук с идентификатором, который уже есть в кэше, то хук просто возвращает данные из кэша.
  * queryFn - функция запроса данных.
    * Должна быть асинхронная, т.е. возвращать промис. В данном случае fetchTasks реализована как асинхронная, значит колбэк в queryFn возвращает промис, поэтому к самому колбэку async дописывать не надо.



```javascript
const {
  data,
  isPending,
  isFetching,
  error
} = useQuery
```

* useQuery возвращает объект с разными полезными вещами.
  * data - это данные, которые возвращает функция загрузки данных.
  * isPending - bool-флаг. Данные отсутствуют в кэше, функция выборки данных запущена, но запрос еще не вернул ответ. isPending это как бы первичная загрузка данных.
  * isFetching - bool-флаг. Функция выборки данных запущена. Отличие от isPending в том, что здесь подразумевается не только начальная загрузка, но и повторная фоновая выборка.
    * UPD. Можно в принципе просто isFetching использовать.
  * error - ошибка, возникшая при запросе данных.

## Функция загрузки данных

```javascript
return { 
  tasks, 
  meta: { tasksTotalCount } 
};
```

* Функция в данном случае должна возвращать массив задач.
  * Но для целей пагинации еще надо вернуть общее количество данных.
    * Когда нужны такие "дополнительные" вещи, которые связаны с данными, принято из функции выборки возвращать объект. Одно поле будет содержать данные, а второе - принято называть meta и класть в него объект со всеми этими "дополнительными" вещами.

