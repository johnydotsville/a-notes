

# Хук useQuery

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],    // <-- Идентификатор запроса.
  queryFn: async () => {  // <-- Функция загрузки данных.
    const result = await fetch(`${baseUrl}/tasks`)
    return result.json();
  }
});
```

В одном компоненте можно использовать хук useQuery много раз, если компоненту нужно много разных данных.

# Артефакты

* `data` - когда загрузка завершена, в объект data попадают полученные данные. Пока не загружены, data = undefined.

* `isPending` - становится true, когда RQ запускает функцию загрузки данных.

* `isFetching` - TODO: вроде когда перезапрос идет, т.е. уже повторно херачит.

* `error` - в случае ошибки при загрузке данных в error попадает объект ошибки.

  



# Идентификатор запроса, queryKey

## Зачем нужен

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],    // <-- Идентификатор запроса.
  queryFn: async () => {
    const result = await fetch(`${baseUrl}/tasks`)
    return result.json();
  }
});
```

Идентификатор запроса позволяет RQ отличать запросы друг от друга. Когда благодаря идентификатору выясняется, что какой-то запрос уже выполнялся, то результат просто берется из кэша.

queryKey выполнен в виде массива. Каждый элемент имеет свое назначение:

* Первый - обычно позиционируется как идентификатор группы запросов. Обычно строка.

* Второй и последующие - идентификаторы запросов внутри группы. Должны быть или примитивными значениями, или объектами которые легко сериализуются (т.е. поля объекта должны быть примитивами). Не допускаются сложные объекты вроде функций и т.д.

  ```javascript
  queryKey: ["books"]  // 1
  queryKey: ["books", authorId]  // 2
  queryKey: ["books", genre]     // 3
  queryKey: ["books", authorId, genre]  // 4
  ```

> P.S. Вообще, каждый элемент равнозначен. Первый не обязан быть строкой, просто это является хорошей практикой, первым элементом определять как бы семейство похожих запросов. Например, "books", "posts", "employees" и т.д.

Идентификатора группы достаточно, когда у нас нет необходимости как-то дополнительно уточнять запрос. 

Например, на странице отображается каталог книг, просто книги которые можно почитать. Для такой страницы подойдет запрос [1].

Мы нажимаем на книгу и переходим на страницу с ее описанием. У книги очевидно есть жанр и автор. Поэтому на странице этой книги можно разместить например такие компоненты:

* Все книги этого автора. Тут подойдет запрос [2].
* Книги других авторов такого же жанра. Тут запрос [3].
* Книги этого автора в таком же жанре, как и эта. Тут запрос [4].

Например, мы зашли на страницу книги "Путешествие к центру Земли". Жанр - фантастика, автор - Жюль Верн. У нас сработали запросы 2, 3, 4. В списке книг такого же жанра мы щелкнули на книгу "Машина останавливается", автор Эдвард Морган Форстер, но жанр тоже фантастика. Поэтому когда откроется страница этой книги, то выполнялся два запроса - список книг Форстера и список Форстер + фантастика, а просто список "фантастика", без уточнения автора, уже возьмется из кэша.

## Способы оформления queryKey

В массиве queryKey должны быть значения, которые легко сериализовать.

Есть два концептуальных подхода к оформлению:

* Отдельными примитивными значениями `queryKey: ["posts", priority, tags ]`
* Объектом с полями `queryKey: ["posts", { priority, tags }]`

Зачастую, если мы пишем в queryKey какие-то идентификаторы, то функция выборки данных зависит от них и хочет получать их в виде параметров. Подробнее о параметрах в конспекте про написание функции выборки.

Суть в том, что если идентификаторы указаны как отдельные примитивы, то мы становимся зависимы от их порядка, т.к. деструктурируя массив queryKey получаем элементы в порядке их следования, и если потом добавим в queryKey новый элемент, порядок может сломаться.

Если же мы оформляем индентификаторы как объект, нам становится проще деструктурировать, т.к. мы используем имена полей.

TODO: сейчас трудно формулировать и привести пример. Потом скопировать хороший пример, когда попадется.

## Отношения между ключами

Между ключами есть иерархические отношения. Например

```javascript
queryKey: ["tasks", paginationClientSettings]  // 1
```

является подмножеством

```javascript
queryKey: ['tasks']  // 2
```

Поэтому, если инвалидировать 2, тогда инвалидируется и 1. Это актуально например для такой ситуации:

* Какой-то компонент загрузил данные запросом 1.
* Мы удалили элемент данных.
* Инвалидируем ['tasks'] и и все пагинированные данные тоже маркируются как устаревшие. 
  * Это важно, потому что по сути после удаления какие-то закэшированные данные станут не актуальны. Например, мы были на 5 и 6 странице, они закэшировались. Потом перешли на 4 и удалили элемент. По сути, один из элементов теперь должен переехать с 5 страницы на 4, а с 6 на 5. Поэтому важно инвалидировать ['tasks'] в целом, чтобы и подгруппы инвалидировались.

Если прямо очень надо инвалидировать конкретно 1, тогда есть флаг `exact: true`.







# Функция загрузки данных, queryFn

Это функция, которая реализует выборку данных. Например, запрос на сервер.

## Асинхронность

Функция загрузки *должна* быть асинхронной и возвращать *промис*. Если передать синхронную, она все равно автоматически завершится промисом, так что лучше сразу писать правильно.

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],
  queryFn: async () => {
    const result = await fetch(`${baseUrl}/tasks`)
    return result.json();
  }
});
```

> Здесь важно не допустить распространенную ошибку "двойного await": `return await result.json()`. Метод json уже возвращает промис, что является корректным. Если же мы пишем перед ним await, получается что мы извлекаем его результат, а потом он автоматически опять оборачивается в промис. Это вносит задержку и в принципе является говнокодом.

## Отлов ошибок в queryFn

Если в queryFn возникает непойманное исключение, то RQ сам его ловит и возвращает ошибку в объект error из хука.

Однако рекомендуется всегда писать try - catch, даже есть не планируем писать обработку прямо сейчас. Можно просто перевыбросить исключение в данный момент, зато будет задел на будущее. Плюс будет наглядно видно, где может возникнуть ошибка:

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ["posts"],
  queryFn: async () => {
    try {
      const result = await fetch(`${baseUrl}/tasks`)
      return result.json();
    } catch (err) {
      console.log(err);  // <-- В будущем может понадобиться более сложная обработка.
      throw err;
    }
  }
});
```

## Передача параметров в queryFn

### Проблема

Когда функция маленькая, ее можно написать непосредственно в queryFn:

```javascript
export const TaskList = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ["posts"],
    queryFn: async () => {  // <-- Функция описана прямо на месте.
      try {
        const result = await fetch(`${baseUrl}/tasks`)
        return result.json();
      } catch (err) {
        console.log(err);
        throw err;
      }
    }
  });
  ...
}
```

И то это уже выглядит громоздко. Поэтому обычно функции выносят отдельно, а в queryFn просто указывают их:

```javascript
async function fetchTasks() {  // <-- Функцию описывают отдельно.
  try {
    const result = await fetch(`${baseUrl}/tasks`)
    return result.json();
  } catch (err) {
    console.log(err);
    throw err;
  }
}
```

```javascript
export const TaskList = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchTasks  // <-- А тут просто указывают.
  });
  ...
}
```

Но что если у функции есть параметры?

```javascript
async function fetchTask(id, criteria, token) {  // <-- Что если тут нужны параметры?
  // Код выборки данных.
}
```

Для передачи параметров в функцию есть несколько подходов. Они не равнозначны и не однозначны, каждый хорош в какой-то своей ситуации.

### Способы передать параметры

Три способа:

* Через контекст react query.
* Через замыкание.
* Комбинация контекст + замыкание.

### Контекст react query

Когда RQ вызывает queryFn, он передает ей объект контекста:

```javascript
{  // <-- Структура ctx
  queryKey: any[];          // Массив из queryKey
  signal?: AbortSignal;     // Сигнал для отмены запроса (от AbortController)
  meta?: Record<string, unknown>;  // Метаданные, переданные в query
  pageParam?: unknown;      // Параметр пагинации (для useInfiniteQuery)
}
```

Параметры, которые могут понадобиться в функции загрузки данных, условно можно разделить на две группы:

* Условия отбора данных (например, id задачи, категория задачи и т.д.). По сути эти параметры идентифицируют запрос, а значит, по-хорошему, мы должны их перечислить в queryKey. Значит сможем их получить из контекста.
* Вспомогательные параметры, которые не влияют на идентификацию запроса, но нужны для его выполнения. Хороший пример - токен авторизации. Его мы не можем указать в queryKey. Такие параметры можно передавать с помощью лямбды + замыкания.

## TODO реализация передачи параметров

TODO: Примеры получились грубые и очень приблизительные. Думаю забить пока на них и скопировать удачные варианты, когда подвернется из реальных ситуаций. Не хочется тратить время на выдумывание синтетики.

TODO: Есть паттерны, например функцию пишем с параметрами без привязки к RQ, а потом пишем адаптер к этой функции. Адаптер может получить контекст например, извлечь из него параметры, и передать в функцию загрузки. Но как правило функции загрузки не используются в проекте как-то независимо, они обычно уже ориентированы на rq, так что это может быть излишним. Тем не менее, такая практика существует.

### Каноничный способ, через контекст

Таким способом хорошо передавать параметры, которые входят в состав queryKey.

```javascript
export const Task = ({ task }) => {
  const taskId = task.id;

  const { data, isLoading, error } = useQuery({
    queryKey: ["posts", taskId],
    queryFn: fetchTaskById  // <-- Указываем функцию
  });
  ...
}
```

Функция загрузки:

```javascript
async function fetchTaskById(ctx) {  // <-- RQ передает нам контекст.
  const { queryKey } = ctx;  // <-- Извлекаем массив зависимостей.
  const [_, id] = queryKey;  // <-- Извлекаем нужные параметры.
  try {
    const result = await fetch(`${baseUrl}/tasks/${id}`);  // <-- Применяем параметры.
    return result.json();
  } catch (err) {
    console.log(err);
    throw err;
  }
}
```

### Лямбда и замыкание

Этот способ хорошо подходит для передачи параметров, которые не относятся к идентификатору запроса. Стало быть, не входят в состав queryKey и через контекст мы их получить не можем. Поэтому используем замыкание для передачи:

```javascript
export const useUserData = () => {
  const { token } = useAuth(); // <-- Получаем токен каким-либо образом.

  return useQuery({
    queryKey: ["user"], // <-- Токен НЕ относится к идентификатору.
    queryFn: () => fetchUserData(token), // <-- Передаем его через замыкание.
  });
};
```

Функция загрузки:

```javascript
const fetchUserData = async (token: string) => {
  const response = await fetch("/api/user", {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  return response.json();
};
```

### Комбинация, контекст + замыкание

```javascript
export const useUserData = () => {
  const { token } = useAuth();

  return useQuery({
    queryKey: ["user", id],
    queryFn: (ctx) => fetchUserData(token, ctx),
  });
};

const fetchUserData = async (token, ctx) => {
  const { queryKey } = ctx;
  const [_, userId] = queryKey;
  const response = await fetch(`/api/user/${userId}`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  return response.json();
};
```



# Отмена загрузки данных

TODO: signal из контекста.









# Черновик









# Лог



## useQuery

- [ ] useQuery нужен для загрузки данных. Управляет всей обвязкой, связанной с выполнением запроса.
- [ ] useQuery можно применять много раз в одном и том же компоненте, если надо много разных данных.
- [ ] Параметры хука.
  - [ ] [queryKey](#queryKey) - идентификатор запроса.
  - [ ] [queryFn](#queryFn) - функция загрузки данных.
- [ ] Что возвращает хук.
  - [ ] Возвращает объект, свойства которого - ["артефакты"](#артефакты-useQuery): флаг загрузки, фраг успеха \ неудачи, хранение данных \ ошибки и т.д.
- [ ] Настройки запроса.
  - [ ] useQuery позволяет задать персональные настройки для запроса, переопределив глобальные.
    - [ ] ??? enabled
      - [ ] true* - хук загружает данные сразу при рендере компонента.
      - [ ] false - не загружает.
        - [ ] Можно загрузить вручную артефактом refetch.
- [ ] TODO
  - [ ] ??? Зависимые запросы, Отложенные запросы, Автоматические запросы.
  - [ ] ??? Как страница обновляется автоматически? reactQuery перезапрашивает данные, изменяется состояние и компонент перерисовывается?

## queryKey

- [ ] queryKey - идентификатор запроса. Благодаря ему RQ различает запросы.
  - [ ] Выполнен как массив для зависимостей-идентификаторов, однозначно позволяющих либе отличить запрос от остальных запросов.
    - [ ] Идентификаторы должны быть легко сериализуемы. Т.е. можно использовать примитивы и объекты, свойства которых - примитивы.
    - [ ] Первый элемент обычно строка, концептуально - "группа" запросов.
      - [ ] Дальше либо примитивы, либо объект объединяющий несколько примитивов. Концептуально - идентификатор запроса внутри группы.

## queryFn

- [ ] queryFn - функция загрузки данных.
  - [ ] Должна быть асинхронной и возвращать промис.
  - [ ] Когда RQ вызывает функцию загрузки данных, он передает ей объект [контекста ctx](#Контекст-RQ).
  - [ ] Передача параметров в queryFn.
    - [ ] Разные способы.
      - [ ] Через контекст.
      - [ ] Лямбда + замыкание.
      - [ ] Комбинация первого и второго.

### Контекст RQ

- [ ] Возможности контекста.
  - [ ] Содержит массив queryKey.
  - [ ] Содержит signal, благодаря которому можно прервать запрос.



- [ ] Возврат из queryFn дополнительных данных, например не только список задач, но и общее количество задач на сервере. Паттерн поле meta.
- [ ] ??? Когда запускается функция? Когда в жизненном цикле так сказать.
  - [ ] Функция (первый раз) запускается сразу при вызове хука, т.е. в момент выполнения функции компонента, т.е. в момент создания fiber-узла компонента.



## new

