# Зачем нужен кэш

Кэширование с помощью React Query нужно для того, чтобы:

* Когда люди ходят по одним и тем же страницам приложения, данные не тянулись каждый раз с сервера, а брались по возможности из кэша. Допустим, человек открыл страницу описания фильма. При этом с сервера загрузилась информация о фильме, список актеров и т.д. Потом человек перешел на страницу другого фильма и загрузилась информация о другом фильме. Потом он снова вернулся на страницу первого фильма. Если бы не react query, нам бы пришлось снова грузить информацию с сервера. Но поскольку у нас react query, то информация берется из его кэша. Т.о. и нагрузка на сервер снижается, и приложение работает быстрее, потому что из кэша данные берутся мгновенно.
* Если разные компоненты пользуются одними и теми же данными, то их можно просто взять из кэша. Допустим, на главной странице банка есть компонент с курсом валют. И в компоненте перевода денег с одного счета на другой тоже может понадобиться информация о курсе. Например, если человек переводит с рублевого счета на долларовый, то необходимо вывести предупреждение "Внимание! Пересчет будет произведен по такому-то курсу". Получается, для этого компонента и компонента с главного экрана нужны одинаковые данные. Поэтому не обязательно снова делать запрос на сервере, можно взять курс просто из кэша. Особенно если политика банка такова, что курс фиксируется на сутки и не меняется в этот промежуток.

# Где хранится кэш

React Query хранит кэш в оперативке. Соответственно, кэш уничтожается при обновлении страницы или закрытии вкладки.

# Кэш не привязан к компонентам

Кэш не привязан к компонентам. Т.е. тот факт, что мы используем хук useQuery в компоненте никак не привязывает полученные данные к этому компоненту. Данные хранятся в кэше, а компонент просто *подписан* на эти данные. Соответственно, если данные обновляются, то RQ сообщает об этом компоненту и тот может обновиться, чтобы отобразить актуальные данные.



# Идентификация данных в кэше

У каждого набора данных в кэше есть уникальный идентификатор (ключ), который задается при использовании хука useQuery. С помощью этого идентификатора RQ различает запросы и когда useQuery вызывается с идентификатором, который уже есть в кэше, то RQ возвращает связанные с этим идентификатором данные.

Благодаря идентификатору можно инвалидировать отдельные блоки данных, а не весь кэш.



# Устаревание данных, время хранения

## cacheTime и staleTime

Важные понятия:

* `Активные` данные: когда какой-то компонент использует хук useQuery и загружает данные, то он тем самым подписывается на эти данные и они считаются активными.
* `Неактивные` данные: когда компонент размонтируется, тогда происходит отписка от данных. Когда у данных не остается ни одного подписчика, эти данные становятся неактивными. 

cacheTime и staleTime:

* `cacheTime` - это время хранения *неактивных* (inactive) данных или проще говоря "сколько времени хранить данные, когда у них не осталось подписчиков".
  * Начинает тикать с момента, когда у данных не остается ни одного подписчика.
  * Дефолт 5 минут. Если за это время никто к ним не обратится, то сборщик мусора их удалит.
* `staleTime` - это время устаревания *активных* данных или проще говоря "через сколько времени перезагрузить данные с сервера, если у них есть подписчики".
  * Тикает, пока данные активны, т.е. пока у них есть подписчики.
  * Дефолт 0. Как только это время прошло, RQ `инвалидирует` данные, т.е. помечает их как устаревшие. Когда компонент-подписчик попробует обратиться к ним, то RQ запустит функцию загрузки повторно, чтобы загрузить актуальную версию данных.

В целом, cacheTime и staleTime друг с другом непосредственно не связаны. Например, если данные стали неактивными, а мы вручную сделали рефетч, то это не сделает их активными.

staleTime один на данные, а не один на каждый компонент, который ими пользуется.

### staleTime = 0

- [x] Какой смысл в том чтобы помечать данные как устаревшие сразу после загрузки? Разве это не приведет к повторной загрузке и лишним рендерам?

Не приведет. Работает так: компонент Foo запрашивает данные 'tasks'. В кэше их нет, RQ запрашивает их с сервера. Компонент Bar тоже запрашивает данные 'tasks'.

Ситуация 1: данные еще не выбрались. Второй запрос не создается, т.е. оба компонента взаимодействуют с одним запросом. Когда они выберутся, компоненты получат уведомление и перерендерятся.

Ситуация 2: данные уже готовы, когда Bar к ним обращается, но помечены как устаревшие. Bar получает "старые" данные из кэша, а RQ вновь вызывает функцию запроса данных.

Когда данные приходят, RQ сравнивает их с теми, что уже лежат в кэше. Если выясняется, что данные пришли те же самые, то RQ не оповещает компоненты. Если данные изменились, тогда оповещает и происходит повторный рендер. И там уже сам react проверяет, нужно ли вносить изменения в реальный DOM или нет. Например, хоть данные пришли новые, но по результатам расчетов оказывается, что в интерфейсе все то же самое. Например, количество товара стало меньше, но не настолько, чтобы заменять надпись "Наличие: много", на "Наличие: мало".

# Выборка данных

Происходит с помощью хука useQuery. При оформлении запроса мы задаем ему ключ и данные сохраняются в кэше под этим ключом.

## Первый запрос

* Когда данных, связанных с вызванным запросом, в кэше еще нет, RQ запрашивает их, а клиенту возвращает флаги вроде isFetching: true. Тот может на их основе нарисовать что-то вроде "Данные загружаются, подождите".
* Когда данные пришли, RQ сохраняет их в кэш, а клиентам посылает уведомление.
  * Интересный факт: по умолчанию, свежевыбранные данные сразу становятся устаревшими.
* Клиенты перерендерятся и при этом получают данные.



# Инвалидация кэша

Инвалидация кэша - это пометка данных с определенным ключом как устаревших, т.е. установка флага isStale для них. Инвалидация может произойти, если у данных истекло staleTime или если мы эти данные инвалидировали вручную методом `queryClient.invalidateQueries(x)`.

При инвалидации есть два сценария:

* Инвалидированы активные данные.
  * RQ оповещает подписчиков и делает повторный запрос. Благодаря такой схеме подписчики получают флаг isFetching: true, что данные загружаются. Они все еще могут отображать текущие данные, которые хранятся в кэше, а за счет флага можно показывать какой-нибудь статус, вроде "Данные могут быть не актуальны, идет повторная загрузка..."
  * Когда приходит результат, тогда RQ снова оповещает подписчиков. isFetching: false + имеем свежие данные.
* Инвалидированы неактивные данные. 
  * RQ сделает перезапрос только когда кто-то к этим данным обратится.









# TODO

Механики кэша.

- [ ] ??? Хранение данных в кэше.
  - [ ] Накапливается.
  - [ ] Разные механики оптимизации кэша (частичное удаление данных, хранение только видимых данных и т.д.)

