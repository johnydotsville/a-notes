# Обертки для примитивов

Все примитивные типы, кроме null и undefined, имеют обертки. Называются они так же как примитивы, только с большой буквы: `String`, `Number`, `Boolean`, `Symbol`, `BigInt`.

Обертки содержат полезные методы для работы с соответствующим типом. Это их основное назначение.

## Механика оберток

Механика такая:

* Когда на примитиве вызывается метод, то
* Создается объект-обертка.
* Метод выполняется и возвращает значение.
* Объект-обертка уничтожается.

Т.о., обертка живет весьма не долго.

Пример:

```javascript
let message = "Hello, world!";
let capsed = message.toUpperCase();

console.log(capsed);  // HELLO, WORLD!
```

Метод обертки получает данные, хранящиеся в примитиве, обрабатывает их и возвращает результат. После этого обертка уничтожается. За кулисами движок может делать разные оптимизации, так что мб и не совсем уничтожается, но именно с логической точки зрения обертка перестает существовать после того, как метод выполнен.

Еще пример и одновременно вопрос:

```javascript
let str = "Привет";
str.test = 5;
alert(str.test);  // Что здесь будет?
```

Ответ: в строгом режиме будет ошибка, а в обычном - undefined. При попытке обратиться к свойству test на примитиве, создается обертка. Строгий режим не позволяет ее редактировать, поэтому присвоение даст ошибку. Нестрогий режим ошибку не даст, но после присвоения обертка уничтожится. Так что повторная попытка обратиться к свойству даст undefined.

P.S. Здесь у меня есть несколько вопросов, которые впрочем с практической точки зрения не сильно важны, поэтому ковыряться я не стану, а просто оставлю их и если когда-нибудь случайно вдруг узнаю ответы, запишу их. Вопросы такие:

* `str.test = 5;` в строгом режиме. Ошибку вызывает именно попытка инициализации свойства или сам факт попытки добавить свойство?
* `alert(str.test)` - здесь undefined появляется из-за того, что свойство именно отсутствует? Или из-за того что заново создается обертка, в нее добавляется test, но из-за того, что там нет значения, получается undefined? Вроде как должен быть первый вариант, потому что undefined мы получаем когда пытаемся обратиться к несуществующему в объекте свойству.