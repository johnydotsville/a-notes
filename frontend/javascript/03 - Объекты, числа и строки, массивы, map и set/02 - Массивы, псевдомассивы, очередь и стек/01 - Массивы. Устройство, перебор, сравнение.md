# Массивы

## Объявление

Два способа:

```javascript
let arr = [];  // Пустой массив
let arr = ["Яблоко", "Апельсин", "Груша"];
```

```javascript
let arr = new Array();   // Пустой массив
let arr = new Array(5);  // Массив заданного размера, вместо элементов - undefined
let arr = new Array("Яблоко", "Апельсин", "Груша");
```

Синтаксис со скобками `[]` является более распространенным.

## Размер массива

Размер массива хранится в свойстве `length`:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];
let len = arr.length;  // 3
```

Важная особенность: на самом деле length это не количество элементов в массиве, а максимальный индекс + 1:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

arr[100] = "Слива";

console.log(arr.length);  // 101
```

Мы можем перезаписывать это свойство. Это может иметь смысл для быстрого укорачивания массива:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

console.log(arr);  // ['Яблоко', 'Апельсин', 'Груша']
arr.length = 2;
console.log(arr);  // ['Яблоко', 'Апельсин']. По сути, удалили один элемент.
arr.length = 0;
console.log(arr);  // []  // Очистили массив
```



## Доступ к элементам

Нумерация начинается с 0. Для доступа к элементам есть два синтаксиса:

* `[]` - позволяет задать только положительный индекс.
* `.at(-1)` - позволяет задавать как положительный, так и отрицательный индекс. Положительный аналогичен использованию скобок. Отрицательный - ведет отсчет от конца массива. Новая возможность.

```javascript
let arr = ["Яблоко", "Апельсин", "Груша", "Мандарин"];
let first = arr[0];  // Яблоко
let last = arr.at(-1);  // Мандарин
```

```javascript
let last = arr[arr.length - 1];  // По старинке
```

# Устройство массива

Внутри массив является объектом. Соответственно, к нему применимы все правила, касающиеся объектов, например копирование по ссылке.

Движок js проводит оптимизации, за счет которых массивы работают быстро. Если мы начинаем работать с массивом как с обычным объектом, то движок начинает рассматривать его как обычный объект и соответственно отключает все оптимизации. Триггером для отключения оптимизаций служат:

* Добавление массиву произвольных свойств.

  ```javascript
  let arr = ["Яблоко", "Апельсин", "Груша"];
  arr.comment = "Массив с фруктами";
  ```

* Создание "дыр" между элементами.

  ```javascript
  let arr = ["Яблоко", "Апельсин", "Груша"];
  arr[100] = "Ананас";
  ```

* Заполнение массива в обратном порядке.

  ```javascript
  let arr = [];
  arr[1] = "Апельсин";
  arr[0] = "Яблоко";
  ```

* Хранение в массиве разнородных данных:

  ```javascript
  let arr = [
    "Яблоко", 
    { name: "Tom" }, 
    function() { console.log("Функция хранится в массиве.") },
    true
  ];
  
  
  console.log(arr[0]);  // Яблоко
  console.log(arr[1].name);  // Tom
  arr[2]();  // Функция хранится в массиве.
  ```

# Перебор элементов

## for ... of

Цикл `for ... of` позволяет нам перебрать только числовые свойства массива, т.е. по сути только сами элементы:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let item of arr) {
  console.log(item);  // "Яблоко", "Апельсин", "Груша"
}
```

Нам доступен только сам элемент, без индекса.

## for

Обычный `for` может пригодиться, если нужны какие-нибудь проверки непосредственно индекса. Например, вывести только элементы на четных позициях:

```javascript
//             0          1         2
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  if (i%2 == 0) console.log(arr[i]);  // Яблоко, Груша
}
```

## for ... in

Этот цикл не рекомендуется использовать для перебора массивов, потому что:

* Он оптимизирован для работы с произвольными объектами, но не массивами.
* Он перебирает все свойства объекта, а в случае массива нас интересуют только числовые. В случае т.н. "псевдомассивов" можем получить лишнее.

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let item in arr) {
  console.log(arr[item]);  // С виду все нормально, но есть нюанс.
}
```

# Многомерные массивы

Элементами массива так же могут быть массивы:

```javascript
let arr = [
  [0, 0, 3],
  [0, 7, 0],
  [4, 0, 0]
];

let center = arr[1][1];  // 7
```

Правильный синтаксис обращения к элементам во вложенном массиве - именно `[i][j]`, а не `[i, j]`.

# Преобразование в строку

У массивов нету `Symbol.toPrimitive` и метода `valueOf`. Их метод `toString` возвращает строку со списком элементов, разделенных запятой:

```javascript
let arr = [7, 5, 3];

let s = arr.toString();  // 7,5,3
```

# Сравнение массивов

## Через оператор ==

Массивы нельзя сравнивать через оператор равенства, потому что он не работает с ними как с каким-то особенным типом. Массив - это объект, поэтому два массива будут равны, только если указывают на один и тот же объект:

```javascript
let arr1 = [7, 5, 3];
let arr2 = arr1;

console.log(arr1 == arr2);  // true
console.log([7, 5, 3] == [7, 5, 3]);  // false
```

Кроме того, сравнение с примитивами может дать хитрый результат:

```javascript
console.log(0 == []);    // true
console.log("0" == []);  // false
```

В первом случае массив преобразуется в примитив - в строку. Он пустой, поэтому превратится в строку `""`. Она для сравнения с 0 преобразуется в число и тоже станет 0. Поэтому итог - true. Во втором случае получится сравнение `"0" == ""`, поэтому будет false.





