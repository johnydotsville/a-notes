

В основном написано по материалам сайта https://learn.javascript.ru/array-methods

TODO: полный список, есть некоторые интересные методы, которые я тут не рассмотрел еще https://www.w3schools.com/jsref/jsref_fill.asp

# Проверка на массив

## Array.isArray

Поскольку массив является объектом по своей природе, то `typeof` их не различает:

```javascript
console.log(typeof {}); // object
console.log(typeof []); // тоже object
```

Поэтому, чтобы распознать массив, есть отельный метод:

```javascript
console.log(Array.isArray({})); // false
console.log(Array.isArray([])); // true
```

# Удаление, добавление, замена элементов

## splice

Метод `splice(start [, deleteCount, item1, item2 ... itemN])` позволяет удалить из массива некоторое количество элементов, начиная с указанного, и вставить на их место другие элементы.

Особенности:

* Удаленные элементы возвращаются в виде отдельного массива.
* Можно не удалять элементы, передав 0, а просто вставить новые.
* start может быть отрицательным, тогда счет ведется от конца массива. -1 это последний элемент (получается позиция "перед последним").
* Объединить таким образом два массива не получится. Если в качестве добавляемого элемента будет массив, то он вставится именно как ссылка на массив, а не как набор элементов. Для сливания массивов есть метод `concat`.

Примеры:

► Удаление:

```javascript
//          0       1       2       3         4         5
let arr = ["Я", "въезжаю", "в", "стройку", "Мижган", "давай"];
let deleted = arr.splice(2, 3);  // deleted ['в', 'стройку', 'Мижган']
```

► Замена:

```javascript
//          0       1       2       3         4         5
let arr = ["Я", "въезжаю", "в", "стройку", "Мижган", "давай"];
let deleted = arr.splice(2, 3, "в", "гараж", "Димон");  // deleted ['в', 'стройку', 'Мижган']
// arr ['Я', 'въезжаю', 'в', 'гараж', 'Димон', 'давай']
```

► Вставка в середину без удаления:

```javascript
//          0       1       2       3         4         5
let arr = ["Я", "въезжаю", "в", "стройку", "Мижган", "давай"];
let deleted = arr.splice(2, 0, "эту", "заброшенную");  // deleted [], ничего не удалено
// arr ['Я', 'въезжаю', 'эту', 'заброшенную', 'в', 'стройку', 'Мижган', 'давай']
```

► Вставка в конец:

```javascript
//          0       1       2       3         4         5
let arr = ["Я", "въезжаю", "в", "стройку", "Мижган", "давай"];
let deleted = arr.splice(6, 0, "снимай");  // <-- 6, позиция "за последним"
// или let deleted = arr.splice(arr.length, 0, "снимай");
```

# Возврат подмассива, копирование массива

## slice

Метод `slice([start, end])`. Комбинации такие:

* Без указания индексов - скопирует массив целиком.
* Без end - скопирует от start до конца.
* С обоими аргументами - скопирует фрагмент `[start, end)`.

Примеры:

```javascript
//               0         1         2            3         4
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин", "Банан"];

let copy = fruits.slice();  // ['Яблоко', 'Груша', 'Апельсин', 'Мандарин', 'Банан']
let frag1 = fruits.slice(3);     // ['Мандарин', 'Банан']
let frag2 = fruits.slice(1, 3);  // ['Груша', 'Апельсин'], 3 индекс не включен
```

# Объединение массивов

## concat

Метод `concat(arg1, arg2, ... argN)`. Особенности:

* Аргументами могут быть массивы или обычные элементы.
* Метод возвращает новый массив, а исходные не меняются.
* Если аргумент - массивоподобный объект, то он вставится как объект. Если нужно вставить именно свойства этого объекта, то нужно в этот объект добавить символьное свойство `[Symbol.isConcatSpreadable]: true`. P.S. К обычным объектам это отношение не имеет, да и вообще это больше для справки, вряд ли кто-то действительно такой мурой занимается.

```javascript
let pack1 = ["Яблоко", "Груша"];
let pack2 = ["Мандарин", "Банан"];
let orange = "Апельсин";

let fruits = pack1.concat(pack2, orange);
// fruits ['Яблоко', 'Груша', 'Мандарин', 'Банан', 'Апельсин']
```

# Действие для каждого элемента

## forEach

Обойти все элементы и выполнить для каждого действие можно методом `forEach(function(item, index, array))`. Особенности:

* forEach ничего не возвращает.
* Можем написать действие с помощью лямбды или обычной функции.

```javascript
let arr = [5, 7, 4, 10];

arr.forEach((item, ind, array) => {  // <-- Через лямбду
  array[ind] *= 2;
  console.log(`Было: ${item}, стало: ${array[ind]}`);
});

console.log(arr);  // [10, 14, 8, 20]

// Вывод
Было: 5, стало: 10
Было: 7, стало: 14
Было: 4, стало: 8
Было: 10, стало: 20
[10, 14, 8, 20]
```

```javascript
// Через синтаксис обычной функции
arr.forEach(function(item, ind, array) {
  array[ind] *= 2;
  console.log(`Было: ${item}, стало: ${array[ind]}`);
});
```

## map

`map(function(item, index, array))` обходит все элементы, выполняет для каждого указанную функцию и возвращает массив обработанных значений. Исходный массив не изменяется.

```javascript
let arr = [5, 7, 4, 10];

let doubled = arr.map(item => item *= 2);
// let doubled = arr.map((item, index, array) => item *= 2);

console.log(arr);      // [5, 7, 4, 10]
console.log(doubled);  // [10, 14, 8, 20]
```

# Проверка для каждого элемента

## some, every

Выполняет для каждого элемента указанную функцию `function(item, index, array)`.

* `some` - возвращает true, если функция вернула true хотя бы для одного элемента
* `every` - возвращает true, если функция вернула true для каждого элемента.

```javascript
let arr = [5, 7, 4, 10];
let someGt8 = arr.some(n => n > 8);  // true, есть хотя бы один элемент > 8
let allGt8 = arr.every(n => n > 8);  // false, не все элементы > 8
```

# Поиск элемента

## indexOf и lastIndexOf

`indexOf(item [, start])` возвращает индекс элемента, если он есть есть в массиве, и `-1`, если элемента нет. start - индекс элемента, с которого надо начинать поиск:

```javascript
//            0         1          2         3         4
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];
let banan = arr.indexOf("Банан");  // 3
let apple = arr.indexOf("Яблоко", 2);  // -1
```

`lastIndexOf(item [, start])` ищет, начиная с конца массива. Если указать start, то "концом" поиска будет считаться эта позиция:

```javascript
//            0         1          2         3         4
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];
let orange = arr.lastIndexOf("Апельсин");  // 4
let orange = arr.lastIndexOf("Апельсин", 2);  // -1, не найдено, т.к. массив как бы "обрезался" по 2 элемент включительно
```



## includes

`includes(item [, start])` возвращает true \ false, в зависимости от того, есть ли в массиве элемент. start - индекс элемента, с которого надо начинать поиск. 

```javascript
//            0         1          2         3         4
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];
let banan = arr.includes("Банан");    // true
let pear = arr.includes("Груша", 2);  // false
```

## Отличия indexOf и includes

`includes` более новый метод, он использует строгое равенство при сравнении и правильно обрабатывает NaN.

## find, findIndex, findLastIndex

Эти функции используют поиск по условию `find(function(item, index, array))`. Они обходят все элементы и к каждому применяют указанную функцию. Если функция дает true, то обход на этом завершается. `find` возвращает сам элемент, а `findIndex` и `findLastIndex` - индекс элемента. Ну и соответственно, первый метод ведет поиск с начала массива, а второй - с конца. Если элемент не найден, возвращается undefined.

```javascript
//            0         1          2         3         4
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];

let item = arr.find(i => i.length > 6);   // Мандарин
item = arr.findIndex(i => i.length > 6);  // 2
item = arr.findLastIndex(i => i.length > 6);  // 4
item = arr.findLastIndex(i => i.length > 20);  // undefined
```

## filter

Использует поиск по условию `filter(function(item, index, array))` и возвращает *все* элементы, для которых функция-условие вернула true.

```javascript
//            0         1          2         3         4
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];
let items = arr.filter(i => i.length > 6);   // ['Мандарин', 'Апельсин']
```

# Изменение порядка элементов

## Сортировка

### sort

Метод `sort(fn)`. Особенности:

* Принимает функцию, реализующую алгоритм сравнения строк. Без этой функции элементы сравниваются как строки.
* Изменяет исходный массив. Также возвращает измененный массив, но это не важно, потому что исходный изменяется.

```javascript
let arr = [5, 7, 4, 10];

arr.sort();
console.log(arr);  // [10, 4, 5, 7], т.к. элементы сравнились как строки

arr.sort((a, b) => a - b);
console.log(arr);  // [4, 5, 7, 10], т.к. элементы сравнились как числа
```

## Инверсия

### reverse

`reverse` меняет порядок элементов на обратный. Меняет исходный массив и также возвращает измененный массив.

```javascript
let arr = [5, 7, 4, 10];

arr.reverse();
console.log(arr);  // [10, 4, 7, 5]
```

# Строка из элементов массива

## join

Метод `join(соединитель)` объединяет элементы массива в строку, вставляя между ними указанную строку в качестве разделителя элементов:

```javascript
let arr = ["Яблоко", "Груша", "Мандарин", "Банан", "Апельсин"];
let str = arr.join(" & ");
console.log(str);  // Яблоко & Груша & Мандарин & Банан & Апельсин
```

# Расчет итога по массиву

## reduce, reduceRight

Метод `reduce(function(accumulator, item, index, array) [,initialAccumValue])` используется для подсчетов каких-то итогов по всем элементам массива. Он обходит все элементы, для каждого выполняет функцию, а ее результат помещает в переменную `accumulator` и этот результат переходит на следующую итерацию. В конце reduce возвращает значение аккумулятора. `reduceRight` то же самое, только массив обходится с конца.

Пример: рассчет суммы элементов массива:

```javascript
let arr = [5, 7, 3, 15];

let sum = arr.reduce(
  ((accum, item) => accum + item), 
  0);  // <-- Начальное значение аккумулятора

console.log(sum);  // 30
```

# Параметр thisArg

Почти все методы, которые принимают функции, вроде map, filter и т.д., также принимают параметр `thisArg`. Передавая через него значение, мы указываем выполняющейся функции, что она должна подставить для this, если он в ней используется.

Например: пусть у нас есть объект с границами призывного возраста и функцией, которая определяет, может ли человек вступить в армию:

```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  dutyCheck(person) {
    return person.age >= this.minAge && person.age < this.maxAge;
  }
};
```

В этом примере this должен указывать на объект army, чтобы все работало как надо. У нас есть такой набор людей, которых мы хотим проверить, могут ли они служить:

```javascript
let guys = [ 
  { name: "Tom",  age: 19},  // Может
  { name: "Sid",  age: 17},  // Маленький, не может
  { name: "Huck", age: 20},  // Может
  { name: "Jim",  age: 40}   // Вышел из призывного возраста, не может
];
```

Для фильтра нам нужна функция `dutyCheck` из объекта army, и чтобы this внутри нее указывал на этот же объект:

```javascript
let soldiers = guys
  .filter(army.dutyCheck, army)  // <-- Указываем функцию и объект для this внутри нее
  .map(p => p.name);  // <-- Оставим от объектов только имена для наглядности

console.log(soldiers);  // ['Tom', 'Huck']
```

Без передачи army, this внутри функции army.dutyCheck указывал бы на объект Window (если скрипт выполняется в браузере) и метод бы работал не правильно.