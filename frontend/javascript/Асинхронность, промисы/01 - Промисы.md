

# Идея промиса

Промис - это соединительная ткань между кодом-работягой и кодом, которому нужен результат работы. Мы передаем в промис код-работягу (обычно этот код выполняется не мгновенно, а какое-то время), затем настраиваем "потребителей" и когда работяга завершает работу, промис передает результат потребителям.

# Создание промиса

```javascript
let prom = new Promise((resolve, reject) => {
  let num = Math.random() * 10;
  if (num >= 7) {
    resolve(num);
  } else {
    if (num >= 4)
      reject(new Error("Полученное число недостаточно большое."));
    else
      throw new Error("Произошла непредвиденная ошибка.");
  }
});

prom.then(
  result => console.log("Результат задачи из промиса: " + result),
  error => console.log("Задача в промисе завершилась некорректно: " + error.message)
);
```

При создании промиса мы передаем ему функцию-работягу с двумя параметрами. Общепринятые названия для них - resolve и reject. Это функции, которые мы должны вызвать в работяге, чтобы отметить завершение ее работы. Их нам передает сам промис. Вызовом `resolve(результат)` мы обозначаем успешное выполнение задачи и передаем промису результат работы (промис переходит в состояние fulfilled), а вызовом `reject(ошибка)` мы обозначаем провал задачи и передаем промису причину провала (промис переходит в состояние rejected). В случае возникновения непойманного исключения промис автоматически переходит в состояние rejected и получает выскочившую ошибку.

Работа автоматически начинается сразу при создании промиса, так что явно его запускать не надо. На старте статус промиса pending. Как такового результата у самого промиса нету, поэтому если не вызвать resolve или reject, то промис останется в состоянии pending. Поэтому их нужно вызывать в любом случае.

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно. Так же как и статус меняется только один раз.

# Обработка результата

## Методы then, catch, finally

Эти методы можно объединять в цепочки, потому что каждый из них возвращает промис на основе результата принятого колбэка. Более детально об этом в разделе "Цепочки промисов".

## Метод then

Получить доступ к результату или ошибке промиса можно с помощью метода `then`, который принимает две функции:

```javascript
prom.then(
  result => console.log(result),
  error => console.log(result.message)
);
```

Если к моменту вызова then промис уже завершился, то он выполняет одну из этих функций сразу, а если не завершился - то после завершения. Если завершился успешно, то выполняет первую, передавая ей результат. Если провалился, то выполняет вторую, передавая ей ошибку.

## Метод catch

Если у выполняемой в промисе функции результата как такового нет (например, она просто загружает из интернета скрипт и подключает его на страницу), а значит нам не нужен и обработчик результата, но мы хотим отлавливать ошибки, то можем использовать метод `catch` вместо then:

```javascript
prom.catch(
  error => console.log(result.message)
);
````

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
prom
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То можно принять ошибку не только из prom, но и из then.

## Метод finally

Метод `finally` принимает функцию без аргументов:

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно он нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис - успешно или нет. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый метод возвращает промис, то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение, а передает его дальше:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => {
    console.log("Выполняем общие действия.");
    return 10;  // <-- Пытаемся перекрыть результат исходного промиса
  })
  .then(result => {
    console.log(result);  // 5
  });
```

Хотя finally тоже возвращает промис, но как мы видим, результат колблэка в finally (10) игнорируется и в колбэк в then попадает значение 5.

# Цепочки промисов

## Механика работы цепочки

Методы then, catch и finally тоже возвращают промисы, поэтому становится возможным формировать из них цепочки. Например:

```javascript
//     1        2        3        4          5
prom.then(F1).then(F2).then(F3).catch(F4).finally(F5);
```

Каким образом они формируют промисы? Грубо говоря, первый then выполняет функцию F1, которую мы ему передали (колбэк), берет ее результат и возвращает нечто вроде:

```javascript
return new Promise((resolve, reject) => resolve(результат));
```

> P.S. Реальное устройство конечно сложнее, но для логического понимания как это работает, такой модели достаточно.

Таким образом на выходе первого then получается новый промис, завершенный, с готовым результатом. На этом промисе вызывается второй then и происходит то же самое - выполняется колбэк F2, его результат оборачивается в промис и этот промис возвращается. И так до конца по всей цепочке.

Отличия заключаются только в том, что именно возвращает колбэк. Он может вернуть простое значение, или вообще ничего, а может вернуть промис. Рассмотрим разные ситуации на конкретных примерах.

## Примеры работы цепочек

### Колбэк не возвращает ничего

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {  // <-- Колбэк выведет результат промиса в консоль и ничего не вернет
    console.log(result);  // 5
  })
  .then(result => {  // <-- Поэтому сюда не попадет никакое значение
    console.log(result);  // undefined
  });
```

Результат первого then можно воспринимать как

```javascript
return new Promise((resolve, reject) => resolve());
```

### Колбэк возвращает простое значение

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);  // 5
    return "Привет, промис!";  // <-- Колбэк вернул простое значение
  })
  .then(result => {
    console.log(result);  // Привет, промис!
  });
```

Результат первого then можно воспринимать как

```javascript
return new Promise((resolve, reject) => resolve("Привет, промис!"));
```

### Колбэк возвращает промис

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);  // 5
    return new Promise((resolve, reject) => {  // <-- Результат колбэка - промис
      let ms = 2000;
      setTimeout(() => resolve(`Вы увидели это сообщение с задержкой ${ms} мс.`), ms);
    });
  })
  .then(result => {
    console.log(result);  // Вы увидели это сообщение с задержкой 2000 мс.
  });
```

Поскольку результатом колбэка уже является промис, можно считать, что then его и возвращает.

### Ошибка в колбэке

Когда промис завершен через reject или когда возникает не пойманная ошибка в самом промисе или в колбэке в then \ catch \ finally - это все по сути одно и то же. Промис переходит в состояние rejected и сохраняет в себе эту ошибку:

```javascript
new Promise((resolve, reject) => {
  // <-- Ошибка могла бы быть тут
  resolve(5);  // <-- Или вместо resolve мог быть reject
})
  .then(result => {
    console.log(result);
    // <-- И тут могла бы быть ошибка
    return new Promise((resolve, reject) => {
      let ms = 2000;
      setTimeout(() => reject(new Error("Ошибочка вышла!")), ms);
    });
  })
  .catch(err => {  // <-- В любом случае мы объект этой ошибки получили бы тут
    console.log(err.message);  // Ошибочка вышла!
  });
```

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);
    throw new Error("Ошибочка вышла!");
  })
  .catch(err => {
    console.log(err.message);  // Ошибочка вышла!
  });
```

# Пример

Задача такая: подключить библиотеку lodash и с помощью нее вывести в консоль случайное число.

```javascript
function addScript(src) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Не удалось подключить скрипт ${src}.`));
    document.head.append(script);
  });  
}

addScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js")
  .then(result => printRandomNumber(1, 100))
  .catch(err => console.log(err.message));

function printRandomNumber(min, max) {
  console.log(_.random(min, max));
}
```

Комментарии:

* Функция добавления скрипта на страницу возвращает промис.
  * В данном случае мы подключаем скрипт lodash. Он лежит по известному адресу в интернете.
  * Подключение заключается в создании элемента `<script>` и добавлении его на страницу программным способом.
  * Скачивание начинается в момент выполнения .append
  * Если элемент скрипта добавился на страницу нормально, то он браузер выполняет onload, а если есть проблемы - onerror.
    * Именно поэтому мы на эти события навешиваем лямбды с вызовом resolve и reject.
    * Т.о. промис завершится, когда сработает одно из этих событий.
* На промис мы вешаем обработчики результата и ошибки.
  * В случае успеха вызываем функцию, которая пользуется lodash'ем для генерации случайного числа.
    * Как такового "результата" работы у нашего работяги нет, поэтому вызываем `resolve()`  без аргументов. Результатом является сам факт успешной загрузки скрипта и добавление его на страницу.
  * В случае ошибки просто выводим текст ошибки в консоль.



