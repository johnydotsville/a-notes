# Наследование классов

Все наследование под капотом тоже строится на основе голых прототипов, правда "ручная" реализация сложнее, чем в случае "ручных" классов, так что я не стал возиться. Основная сложность вроде бы в реализации вызова родительского конструктора. Но самая-самая основа выражается одной строчкой:

```avascript
Child.prototype = Object.create(Parent.prototype);
```

Т.е. для дочерних объектов прототипом служит родительский объект.

# extends

Наследование выполняется ключевым словом `extends`:

```javascript
class MyArray extends Array {  // <-- extends
  get first() {
    return this[0];
  }
  get last() {
    return this.at(-1);
  }
}

const arr = new MyArray(5, 7, 4, 10, 15);
arr.unshift(3);  // <-- Объект унаследовал все методы
arr.push(20);
console.log(arr.length); // 7  // <-- И свойства массивов.
console.log(arr.first);  // 3  // <-- Приобрел свои собственные методы.
console.log(arr.last);   // 20
console.log(arr[5]);  // 15  // <-- Весь синтаксис обычных массивов продолжает работать
console.log(MyArray.isArray(arr));  // true  // <-- А сам класс MyArray также унаследовал статику от Array
```

Что получаем:

* Объекты, созданные через MyArray имеют все те же методы и свойства, что и объекты, созданные через Array.
* Сам MyArray унаследовал всю статику от Array.
* Весь синтаксис, применимый к массивам, работает и с потомком.

## О конструкторах

### Единственный конструктор

В JS у класса только один конструктор. Невозможно написать несколько конструкторов с разными параметрами, как в других ООП-языках.

### Конструктор по умолчанию

Если мы не написали для потомка конструктор явно, то он создастся автоматически и все полученные параметры он передаст родительскому конструктору. Примерно так:

```javascript
autoCreatedChildConstructor(параметры) {
  super(параметры);
}
```

### Собственный и родительский конструктор

Если мы хотим создать для потомка собственный конструктор, то *обязаны* вызвать в нем родительский конструктор (через `super()`) и сделать это *до* первого использования this. Родительский конструктор нужно вызывать, даже если ничего в него не передается.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Rabbit extends Animal {
  constructor(name, earLeng) {
    super(name);  // <-- super() вызываем обязательно, причем до первого использования this
    this.earLeng = earLeng;  // <-- Нельзя написать это перед вызовом super
  }
}

let rabbit = new Rabbit("Белый кролик", 20);

console.log(rabbit.name);     // Белый кролик
console.log(rabbit.earLeng);  // 20
```

### Переопределенные поля в родительском конструкторе

У родительского конструктора есть особенность: он всегда использует поля из собственного класса. Пример для наглядности, что имеется ввиду:

```javascript
class Animal {
  name = "Животное";

  constructor() {
    console.log(this.name);  // <-- Всегда будет использовать "Животное"
    this.move();  // <-- А тут зависит от того, кто вызывает
  }

  move() {
    console.log(`${this.name} передвигается.`);
  }
}

class Rabbit extends Animal {
  name = "Кролик";
  // constructor(...args) {  // <-- Неявно
  //   super(...args);
  // }
  move() {
    console.log(`${this.name} прыгает.`);
  }
}

let rabbit = new Rabbit();
/*
  Животное
  Животное прыгает
*/
rabbit.move();  // Кролик прыгает.
```

В чем здесь интерес? Rabbit является потомком Animal и имеет такое же поле (name) и такой же метод (move). Кролик наследует конструктор животного, в котором выводится значение поля и вызывается метод move. При этом видно, что значение name берется из класса Animal, а реализация метод - из класса Rabbit (иначе было бы написано "Животное передвигается"). В этом и заключается тонкость - родительский конструктор всегда использует поля из собственного класса. Подробнее об этом тут https://learn.javascript.ru/class-inheritance

## Выражение после extends

После `extends` можно указывать любое выражение, результатом которого является класс:

```javascript
function foobar() {
  return class {  // return class Animal {  // Можно указывать имя класса
    constructor(name) {
      this.name = name;
    }

    run() {
      console.log(`${this.name} бежит.`);
    }
  }
}

class Rabbit extends foobar() {  // <-- Вызываем функцию, которая возвращает класс
  hide() {
    console.log(`${this.name} спрятался.`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run();
rabbit.hide();
```

# super

Ссылку на родителя из потомка можно получить через `super`. Например, если нужно вызвать из дочернего конструктора \ метода родительский:

```javascript
class TypedMap extends Map {
  #keyType;
  #valueType;

  constructor(keyType, valueType, entries) {
    if (!keyType || !valueType) {
      throw new Error("Для TypedMap требуется указать типы ключа и значения.");
    }
    if (entries) {
      for (const entry of entries) {
        const [key, value] = entry;
        if (typeof key !== keyType || typeof value !== valueType) {
          throw new TypeError("Неверный тип ключа или значения.");
        }
      }
    }
    
    super(entries);  // <-- Вызываем родительский конструктор и отдаем ему записи
    // Хотя super вызывается далеко не в начале, это ничего, ведь выше мы не юзали this.

    this.#keyType = keyType;
    this.#valueType = valueType;
  }

  set(key, value) {
    if (typeof key !== this.#keyType) {
      throw new TypeError("Неправильный тип ключа.");
    }
    if (typeof value !== this.#valueType) {
      throw new TypeError("Неправильный тип значения.");
    }

    super.set(key, value);  // <-- Вызываем родительскую реализацию метода
  }
}


const tmap = new TypedMap("number", "string");
tmap.set(1, "Tom");
// tmap.set("2", "Huck");  // Ошибка! Неправильный тип ключа.

console.log(tmap.get(1));
```

Несколько правил относительно super:

* `super` в конструкторе потомка нужно обязательно вызывать ДО первого использования this, иначе будет ошибка:

  ```javascript
  childConstructor(foobar, zxc) {
    super(zxc);  // <-- Так правильно - используем super ДО обращения к this.
    this.foobar = foobar;
    // super(zxc);  // <-- Ошибка! super нельзя использовать ПОСЛЕ обращения к this.
  }
  ```

* `super` в методах потомка можно вызывать в любом месте.

# О методах

## Поиск методов

Поиск методов осуществляется в таком порядке:

* Непосредственно в объекте, на котором метод вызван.
* В прототипе объекта.
* В прототипе прототипа.

## Переопределение методов

* Чтобы переопределить метод родителя, достаточно в потомке создать аналогичный метод. Никаких особенных ключевых слов не требуется.
* Для вызова родительской реализации есть ключевое слово `super.метод()`.
