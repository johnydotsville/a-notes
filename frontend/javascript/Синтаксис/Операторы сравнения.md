# Операторы сравнения

| Оператор  | Назначение                              |
| --------- | --------------------------------------- |
| `>`, `>=` | Больше, больше или равно                |
| `<`, `<=` | Меньше, меньше или равно                |
| `==`      | Равно (с приведением типов к числу)     |
| `!=`      | Не равно (с приведением типов к числу)  |
| `===`     | Строгое равно (без приведения типов)    |
| `!==`     | Строгое не равно (без приведения типов) |

Оператор сравнения возвращает одно из двух:

* `true`
* `false`

## Сравнение строк

Правила:

* Строки сравниваются посимвольно. Используется Unicode.
* У какого символа код больше, та строка и считается больше. Маленькие буквы больше больших, потому что в таблице Unicode расположены дальше и, соответственно, у них код больше.
* Если строки до сих пор равны, но одна длиннее другой, то она считается больше. Например, `Слонопотам > Слон`.

## Сравнение разных типов

При сравнении разных типов js пытается привести каждый из них к числу.

```javascript
let s = "01";   // Становится числом 1
let b = s > 0;  // true
```

```javascript
let s = "1 0";  // Не удалось привести к числу, s осталось строкой
let b = s > 0;  // false
```

Чтобы при проверке на равенство допускать меньше ошибок из-за такого преобразований типов, нужно пользоваться вместо обычных `==` и `!=` операторами *строгого* равенства и неравенства `===` и `!==`, которые не выполняют преобразование типов. Если у операндов разные типы, сравнение сразу выдает false:

```javascript
let a = "";
let b = false;
let c = a == b;  // true, т.к. "" стало числом 0 и false тоже стало 0

let d = a === b;  // false, т.к. у операндов разные типы
```

## null и undefined

Некоторые правила:

* `null === undefined` это false, потому что у них разные типы. Проверка на строгое равенство с любым другим типом тоже дает false.
* `null == undefined` это true. Но проверка на равенство с любым другим типом дает false.
* При использовании других операторов сравнения, например, `<`, `<=` и т.д., null становится `0`, а undefined `NaN`.

Примеры с хитростью:

```javascript
let a = null > 0;   // false, null становится числом 0
let b = null == 0;  // false, null НЕ преобразуется в число при использовании ==
let c = null >= 0;  // true, null становится числом 0 и условие выполняется
```

```javascript
let a = undefined > 0;   // false, undefined становится NaN
let b = undefined < 0;   // false, undefined становится NaN
let c = undefined == 0;  // false, undefined никому не равно, кроме null
```

## Как избежать проблем

* Проверки на равенство \ неравенство выполнять с помощью строгих операторов.

* Не использовать остальные операторы для сравнения с переменными, которые могут быть null или undefined. Для этих случаев отдельно проводить проверку на null и undefined и только потом уже выполнять требуемую проверку. Например:

  ```javascript
  let age = prompt("Сколько вам лет?");
  if (age !== null && typeof age == "number") {
    if (age < 18) 
      alert("Вы несовершеннолетний. Закройте страницу.")
    else
      alert("Проходите.");
  } else {
    alert("Вы не указали возраст и поэтому не можете пройти дальше.");
  }
  ```

  Если пользователь нажмет кнопку "Отмена" в промпте, то age станет null. При сравнении с 18 null станет 0 и проверка покажет, что пользователь несовершеннолетний, хотя на самом деле он даже не указал возраст. Поэтому сначала проверяем переменную age на null и только потом, когда убедились, что в ней есть значение, проверяем условие.

  P.S. Просто проверить на null недостаточно, потому что человек может ввести в это поле строку и тогда мы все равно попадем в ветку с "Проходите". Так что нужно еще проверять на то, является ли введенное значение числом. В этом случае можно вообще убрать проверку на null и оставить только на число. В общем, TODO можно вернуться сюда, когда узнаю как в мире js такое положено обрабатывать.

