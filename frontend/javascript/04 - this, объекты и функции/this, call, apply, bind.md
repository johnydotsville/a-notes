# this

Инфа о том, как вычисляется this

https://stackoverflow.com/questions/28016664/when-you-pass-this-as-an-argument/28016676#28016676

## Момент вычисления this

`this` - это ключевое слово, а не переменная или поле. this в js вычисляется в момент вызова функции. Когда функция вызывается на объекте, то в this помещается ссылка на этот объект:

```javascript
let tom = { name: "Tom" };
let huck = { name: "Huck" };

let hello = function() {
  console.log("Hello! My name is " + this.name);
}

tom.h = hello;  // Закинем функцию в оба объекта,
huck.h = hello; // у каждого из которых есть св-во name.

tom.h();   // Hello! My name is Tom
huck.h();  // Hello! My name is Huck
```

Если попробовать вызвать функцию hello без объекта:

```javascript
hello();
```

То здесь два варианта развития событий:

- В строгом режиме this получит значение undefined, и попытка обратиться к свойству name на undefined приведет к ошибке "Cannot read properties of undefined (reading 'name') at hello".
- В обычном режиме this получит значение глобального объекта `window` и ошибки не будет, но name мы не увидим, потому что у window такого свойства нет.

# Контекст

## Потеря контекста

`this` в JS - это "контекст". Когда this используется в методах объекта и метод вызывается на объекте, то контекстом является сам объект и this имеет правильное значение. Но есть нюанс.

► Контекста может не быть. Например, если this используется в обычной функции, не принадлежащей объекту:

```javascript
function intro() {  // <-- Обычная функция, но использует this
  console.log("I am " + this.name);
}

intro();  // I am "" // Нет контекста
```

► Контекст может потеряться. Например, если выдернуть метод из объекта и использовать его как отдельную функцию:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

user.intro();  // I am Tom  // Функция используется в контексте объекта, все нормально

let f = user.intro;  // Выдернули функцию из объекта, потеряли контекст
f();  // I am ""
```

## Как указать функции контекст

### call

У объекта функции есть метод `call(context, arg1, arg2, ..., argN)`, первый аргумент устанавливает this для функции. Например:

```javascript
let tom = { name: "Tom" };
let huck = { name: "Huck" };

let hello = function() {
  console.log("Hello! My name is " + this.name);
}

hello.call(tom);   // Hello! My name is Tom
hello.call(huck);  // Hello! My name is Huck
```







## Как привязать \ не потерять контекст, bind

### Метод bind

У объекта функции есть метод `bind`, который позволяет прибить к функции контекст, чтобы он у нее появился (или не потерялся). Важно! Этот метод не изменяет исходную функцию, он возвращает function-like объект, который лишь вызывает исходную функцию, передавая ей контекст.

► Прибьем контекст к обычной функции, использующей this:

```javascript
function intro() {  // <-- Обычная функция, но использует this
  console.log("I am " + this.name);
}

let user = {
  name: "Tom"
}

intro();  // I am "" // Нет контекста
let f = intro.bind(user);  // Прибили контекст
f();  // I am Tom  // Контекст появился, поэтому name теперь имеет значение
```

► Сохраним контекст для метода, выдернутого из объекта:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);
f();  // I am Tom
```

Для чего вообще может понадобиться выдирать метод из объекта? Ну например чтобы передать его в качестве колбэка. При этом очевидно нужно сохранить контекст, потому что метод объекта без контекста как правило смысла не имеет, т.к. использует в себе поля объекта.

### bind не влияет на исходную функцию

Как говорилось выше, bind возвращает function-like объект, не меняя исходную функцию. Для наглядности:

► На примере обычной функции:

```javascript
function intro() {
  console.log("I am " + this.name);
}

let user = {
  name: "Tom",
}

intro();  // I am ""
intro.bind(user);
intro();  // I am ""  // <-- Исходная функция intro не изменилась, поэтому и результат такой же

let introBinded = intro.bind(user);  // <-- Нужно сохранить function-like объект
// <-- и тогда при его использовании он вызовет исходную функцию, передав ей контекст
introBinded();  // I am Tom
```

► На примере метода объекта:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro;  // <-- Выдернули функцию из объекта, чтобы потерять контекст
f();  // I am ""  // <-- Конекст потерян, поэтому this.name дает пустую строку
let binded = f.bind(user);  // <-- Прибили к функции контекст
binded();  // I am Tom

let fb = user.intro.bind(user);
fb();  // I am Tom
```

### Как bind запоминает контекст

P.S. Здесь у меня уже поплава пошла. Я два часа пишу эти примеры, экспериментирую и уже не способен адекватно понять, как лучше это написать. Так что я просто свалю в кучу эти эксперименты с посильными комментариями, а потом как-нибудь будущий я перечитает это в отдельный день и раскидает по разделам как надо.

bind в момент своего вызова запоминает объект контекста. Если этот объект подменить на другой или стереть (например, положить в переменную новый объект), то на вызов прибитой функции это не повлияет, она будет работать с исходным объектом. Но если исходный объект именно *изменить* (например, поменять значение поля или поменять реализацию какого-нибудь метода), то прибитая функция эти изменения увидит. Изменить можно все элементы контекста - и поля, и методы. Неизменной останется только сама прибитая функция.



```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);  // <-- 1. user будет запомнен в его текущей форме

// <-- 2. Делаем вызов с задержкой, чтобы успеть запороть user'а
setTimeout(f, 1000);  // <-- 4. Все равно все правильно: I am Tom

user = "Стерли!";  // <-- 3. Уничтожаем объект контекста до момента вызова прибитой функции
```

Аналогично, если подменить объект user на другой с аналогичной структурой, на вызов это не повлияет:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Tom

user = {
  name: "Huck",
  intro() {
    console.log("Вообще другая функция.");
  }
}
```

Но вот если не заменять исходный объект на новый, а *изменить* исходный, то эти изменения повлияют на вызов прибитой функции:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Huck

user.name = "Huck";  // <-- Новое имя учтется
user.intro = function() {  // <-- А новая реализация метода - нет
  console.log("Вообще другая функция.");
}
```

Опять же, нюанс, вроде бы очевидно из описания bind, но все же напишу: фиксируется только реализация прибиваемой функции. Все остальное - будто данные, или функции, могут изменяться. Пример:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
    this.demo();
  },
  demo() {
    console.log("foobar");
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  /*
  I am Huck
  HELLO, WORLD!  // а не foobar
*/

user.name = "Huck";
user.intro = function() {
  console.log("Вообще другая функция.");
}
user.demo = function() {
  console.log("HELLO, WORLD!");
}
```

### bindAll

Импровизированный метод замены всех методов объекта на аналогичными, но с прибитым контекстом:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

for (let key in user) {  // <-- "bindAll"
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
```

### Альтернатива bind'у

Пишу просто для справки. Альтернатива с уязвимостью. Можно сохранить контекст, если создать функцию-обертку:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = function() {
  user.intro();  // <-- Используем замыкание, чтобы не потерять контекст
};

f();  // I am Tom
```

Уязвимость заключается в том, что к моменту вызова функции f, в объекте user может измениться реализация метода intro:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = function() { 
  user.intro() 
};

// <-- Отложим вызов, чтобы успеть изменить объект
setTimeout(f, 1000);  // "Вообще другая функция. name: "Huck""

user = {
  name: "Huck",
  intro() {  // <-- Изменили реализацию метода
    console.log("Вообще другая функция. name: " + this.name);
  }
}
```

Как будто такой сценарий маловероятен, какой смысл заменять метод таким образом? Но факт есть факт. Bind бы такого не допустил, т.к. он возвращает новый объект функции на основе существующего и стало быть замена функции в объекте ему нипочем. Однако конечно от замены данных мы не застрахованы:

```javascript
let user = {
  name: "Tom",
  intro() {
    console.log("I am " + this.name);
  }
}

let f = user.intro.bind(user);

setTimeout(f, 1000);  // I am Tom

user = {
  name: "Huck",
  intro() {
    console.log("Вообще другая функция.");
  }
}
```





## this и лямбды

TODO: сейчас известно только то, что лямбды заимствуют this из области видимости выше. Подробнее - позже.