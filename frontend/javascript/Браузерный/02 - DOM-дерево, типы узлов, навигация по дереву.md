

# DOM-дерево, типы узлов

Все элементы html-страницы образуют объекты, из которых формируется DOM-дерево. Например:

```html
<!DOCTYPE HTML>
<html>
<head>
  <title>Изучаем DOM</title>
</head>
<body>
  <!-- Комментарии тоже являются отдельными узлами -->
  DOM-дерево.
</body>
</html>
```

Всего существует 12 типов узлов, но наиболее широко используемыми являются эти четыре:

* `document` - входная точка в DOM.
* узлы-элементы - это HTML-теги.
* текстовые узлы - текстовое содержимое тегов.
* комментарии.

Практически все, что есть в разметке, формирует узлы. В данном примере есть следующие узлы:

* `<!DOCTYPE HTML>`
* html
  * head
    * Текстовый узел из переноса строки и двух пробелов перед title.
    * title
      * Текстовый узел "Изучаем DOM".
    * Текстовый узел из переноса строки.
  * Текстовый узел из переноса строки.
  * body
    * Текстовый узел из переноса строки и двух пробелов перед комментарием.
    * Комментарий.
    * Текстовый узел из переноса строки и двух пробелов, текста "DOM-дерево" и переноса строки после него.

Замечания:

* Я мог немного напутать тут при описании узлов, особенно до body. Но возиться не хочется. Главное тут понять принцип - при разборе разметки узел "накапливается" до момента обнаружения следующего узла. Поэтому, например, после комментария перенос строки, два пробела, надпись "DOM-дерево." и еще один перенос строки образуют единый текстовый узел, а не разные.
* Каждый символ, пусть даже невидимый, вроде переноса строки, начинает новый узел, который копится до обнаружения следующего. Поэтому между тегами, размещенными на разных строках, будут текстовые узлы, которые будут находиться в коллекции элементов, о чем нужно помнить.

Несколько особенностей:

* При построении дерева браузер может самостоятельно исправлять некоторые ошибки, вроде не закрытых тегов.
* Все, что написано между `</body>` и `</html>` браузер автоматически переносит в конец body.
* Между `<html>` и `<head>` пробелы игнорируются, поэтому нет и текстового узла.
* Хотя текстовые узлы, состоящие из одних пробелов, являются полноценными членами DOM-дерева, но они не показываются в инструментах разработки, чтобы экономить место.

# Навигация по DOM

## Доступ к html, head, body

Точкой входа в DOM является объект `document`.

Есть несколько свойств, напрямую связанных с типичными элементами:

* `document.documentElement` - это тег html.
* `document.head` - это тег head.
* `document.body` - это тег body.

Свойства могут быть null. Например, если в скрипте, расположенном в head, попытаться обратиться к `document.body`, то оно будет null, потому что его в данный момент еще не существует.

## Дети и потомки

Дети - это элементы, непосредственно вложенные в элемент. Потомки - это дети+вложенные в них элементы. Например:

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и велел его <i>сварить</i></p>
</body>
```

Здесь детьми `<body>` являются `<h1>` и `<p>`. А  `<i>` для `<body>` является потомком, но не ребенком. `<i>` - это ребенок `<p>`. Ну и текстовые узлы, соответственно, тоже входят в родство.

### .childNodes

Это свойство возвращает *коллекцию* (именно коллекцию, а не массив) детей, включая текстовые узлы.

```javascript
const childs = document.body.childNodes;
```

```
childs: NodeList(4)
0: text
1: h1
2: text
3: p
```

### .firstChild, .lastChild

Эти свойства дают быстрый доступ к первому и последнему ребенку элемента.

### .hasChildNodes()

Метод `.hasChildNodes()` позволяет проверить, есть ли у элемента дети.

## DOM-коллекции

* Почти все DOM-коллекции, вроде .childNodes, являются живыми, т.е. в каждый момент времени отражают текущее состояние дерева.
* Обходить эти коллекции положено с помощью `for ... of`.
* Эти коллекции только для чтения. Через них нельзя изменять дерево, для этого есть отдельные методы.

## Соседи и родитель

Соседи - это элементы, находящиеся на одном уровне вложенности. Например:

```html
<body>
  <h1>Стихотворение</h1>
  <p>Раз прислал мне барин чаю и велел его <i>сварить</i></p>
</body>
```

`<h1>` и `<p>` - это соседи, а их родитель - `<body>`.

### .nextSibling() и .previousSibling()

Возвращают следующего и предыдущего соседа.

### .parentNode()

Возвращают родителя элемента.

## Только теги

Если нам не нужны текстовые узлы и комментарии, а нужны только теги, то для работы с ними есть специальные методы:

* `.children` - все дети, являющиеся тегами.

* `.firstElementChild`, `.lastElementChild` - первый и последний ребенок-тег.

* `.previousElementSibling()`, `.nextElementSibling()` - предыдущий и следующий сосед-тег.

* `.parentElement()` - родитель-тег.

  * Здесь нюанс - обычно parentElement и parentNode равны, кроме случая с html. Для html родителем является объект document, который не является тегом. Поэтому:

    ```javascript
    document.documentElement.parentNode;  // document
    document.documentElement.parentElement;  // null
    ```

    