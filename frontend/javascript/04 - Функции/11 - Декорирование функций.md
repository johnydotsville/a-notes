# Декорирование функций

Здесь сначала простой пример на декорирование обычной функции, просто для демонстрации принципа, а потом - декорирование функции из объекта. Мне наверное около часа потребовалось, чтобы понять как это работает. Так что можно считать это нормальной такой проверкой на понимание как вычисляется this и на функции, которые возвращают функции.

## Декорирование обычной функции

Есть функция, которая возвращает квадрат переданного числа.

```javascript
function doubled(value) {
  console.log("Для получения результата вызван метод doubled.");
  return value * value;
}
```

Нужно сделать кэширование, чтобы результат для чисел, для которых раньше уже выполнялся расчет, возвращался из кэша, без повторного вызова функции.

```javascript
function cache(func) {
  let storage = new Map();

  return function(value) {
    if (storage.has(value)) {
      return storage.get(value);
    }
    
    let result = func(value);
    storage.set(value, result);

    return result;
  }
}

doubled = cache(doubled);

console.log(doubled(4));
console.log(doubled(5));
console.log(doubled(4));
```

Комментарии:

* Здесь мы выражением `doubled = cache(doubled);` фактически перезаписали исходную функцию. Теперь у нас есть только версия с кэшированием.
* Остальное как будто довольно очевидно: передаем исходную функцию в кэширующую и возвращаем другую функцию, которая вызывает исходную.

## Декорирование метода объекта

Есть объект с двумя методами. Методов два исключительно потому, что в декорируемом методе должен быть this, чтобы он мог потеряться, а мы должны были бы предотвратить эту потерю.

```javascript
"use strict";

let actions = {
  
  doubledCalc(value) {
    return value * value;
  },

  doubled(value) {
    console.log("Для получения результата вызван метод doubled.");
    return this.doubledCalc(value);
  }
};
```

Задача такая же - сделать кэширование.

```javascript
function cache(func) {
  let storage = new Map();

  return function(value) {
    if (storage.has(value)) {
      return storage.get(value);
    }
    
    let result = func.call(this, value);
    storage.set(value, result);

    return result;
  }
}

actions.doubled = cache(actions.doubled);

console.log(actions.doubled(4));
console.log(actions.doubled(5));
console.log(actions.doubled(4));
```

Комментарии:

* Основная сложность для меня была в том, что я не сразу понял, каким образом тут в this попадает исходный объект. Я даже не уверен, что объяснение сделает эту вещь понятнее, но попробую.
  * Когда мы вызываем `cache(actions.doubled);`, то отрываем метод doubled от объекта actions и передаем этот метод в кэширующую функцию `cache` через параметр `func`. Отрываем не в том смысле, что метод исчезает из объекта actions, а в том, что если теперь использовать этот метод сам по себе, например `func(value)`, то this внутри func не будет указывать на объект actions.
    * Теперь важно понять, что cache возвращает функцию, которая будет вызвана позже. Т.е. в выражении `func.call(this, value);` this важен не сейчас, на моменте формирования кэшированной функции, а на моменте ее будущего вызова. Сейчас, в момент вызова cache, значением this будет undefined, но это не важно.
  * Далее, выражением `actions.doubled = cache(actions.doubled);` мы фактически заменяем в объекте изначальный метод на его кэшированную версию. Старый метод конечно же остается в памяти (за счет того, что мы передали его в кэширующую функцию и она им пользуется), но нам напрямую он больше не доступен. К нему может обращаться только обертка, получившаяся при вызове `cache(actions.doubled);`
  * И вот теперь кульминация: мы вызываем кэшированный метод `actions.doubled(4)` на объекте actions, стало быть this внутри doubled будет указывать на этот самый объект actions.
    * Вот теперь за счет этого `func.call(this, value);` вызывается с правильным this. Это выражение, `func.call(this, value);` по сути становится то же самое что исходное `actions.doubled()`.

