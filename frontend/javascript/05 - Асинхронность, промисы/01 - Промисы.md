# Промис

## Идея промиса

Промис - это соединительная ткань между кодом-работягой и кодом, которому нужен результат работы. Мы передаем в промис код-работягу, затем настраиваем "потребителей" и когда работяга завершает работу, промис передает результат потребителям.

## Общий синтаксис

```javascript
let prom = new Promise((resolve, reject) => {
  let num = Math.random() * 10;
  if (num >= 7) {
    resolve(num);
  } else {
    if (num >= 4)
      reject(new Error("Полученное число недостаточно большое."));
    else
      throw new Error("Произошла непредвиденная ошибка.");
  }
});

prom.then(
  result => console.log("Результат задачи из промиса: " + result),
  error => console.log("Задача в промисе завершилась некорректно: " + error.message)
);
```

### Колбэки resolve и reject, статус промиса

При создании промиса мы передаем ему колбэк-работягу с двумя параметрами. Общепринятые названия для них - resolve и reject. Их нам передает сам промис. Это функции, которые мы должны вызвать в работяге, чтобы отметить завершение работы промиса. На старте статус промиса pending ("в ожидании") и если не вызвать resolve или reject, то промис останется в этом состоянии и будет считаться незавершенным.

Вызовом `resolve(результат)` мы обозначаем успешное выполнение работяги и передаем промису результат работы (промис переходит в состояние fulfilled), а вызовом `reject(ошибка)` мы обозначаем провал работяги и передаем промису причину провала (промис переходит в состояние rejected).

Если возникает непойманное исключение, это то же самое, что вызвать reject и передать в него это исключение. Т.е. промис в этом случае как бы сам ловит это исключение и отклоняется с ним.

Промис отрабатывает только один раз. Как-то повторно запустить его невозможно. Так же как и статус меняется только один раз.

### Синхронная работа - асинхронная обработка результата

Работа автоматически начинается сразу при создании промиса, так что явно его запускать не надо. Промис выполняется синхронно, а обработка результата его работы происходит асинхронно. Подробнее о синхронности и асинхронности и как это организовано - в конспекте про Event Loop. Пока же просто визуально посмотрим на последовательность вывода в консоль:

```javascript
console.log("Начало скрипта");

new Promise((resolve, reject) => {
  console.log("В начале промиса");  // <-- Промис выполняется СИНХРОННО
  for (let i = 0; i < 10; i++) {
    syncDelay();
  }
  console.log("В конце промиса");
  resolve(7);
})
  .then(result => {  // <-- Обработка результата промиса происходит АСИНХРОННО
    console.log("Результат промиса: " + result);
  });

console.log("В конце скрипта");

function syncDelay() {  // <-- Имитация долгой синхронной работы, просто очень большой цикл
  for (let i = 0; i < 999999999; i++);
}
/*
  Начало скрипта
  В начале промиса
  В конце промиса
  В конце скрипта
  Результат промиса: 7  // <-- Т.к. обработка результата асинхронная, мы видим это на последнем месте
*/
```

### Опциональность resolve и reject

Строго говоря, в колбэке не обязательно указывать параметры, т.е. промис можно написать и вот так:

```javascript
let prom = new Promise(() => {  // <-- Нет resolve и reject в параметрах
  throw new Error("Шеф, все пропало!");
});

prom.catch(err => console.log(err.message));  // Шеф, все пропало!
```

Просто в этом случае у нас не будет возможности завершить промис самостоятельно. Например, промис из примера выше автоматически завершится reject'ом, потому что внутри колбэка выброшена ошибка. Но самостоятельно мы бы не смогли его заreject'ить, т.к. передали промису колбэк без параметров.

Соответственно, можно передать колбэк всего с одним параметром, под resolve:

```javascript
let prom = new Promise((resolve) => {
  resolve("Привет, мир!");
});

prom.then(result => console.log(result));  // Привет, мир!
```



## Обработка результата

### Методы then, catch, finally

Эти методы можно объединять в цепочки, потому что каждый из них возвращает промис на основе результата принятого колбэка. Более детально об этом в разделе "Цепочки промисов".

### Метод then

Получить доступ к результату или ошибке промиса можно с помощью метода `then`, который принимает две функции:

```javascript
prom.then(
  result => console.log(result),
  error => console.log(result.message)
);
```

Если промис завершился успешно, то выполнится первый колбэк и через свой параметр он получит результат промиса. Если промис отклонился, то выполнится второй колбэк и через свой параметр он получит ошибку, приведшую к отклонению.

Передавая колбэки в then, мы ставим их в отдельную очередь и выполняться они будут асинхронно, после того как выполнятся все синхронные функции.

### Метод catch

Если у выполняемой в промисе функции результата как такового нет (например, она просто загружает из интернета скрипт и подключает его на страницу), а значит нам не нужен и обработчик результата, но мы хотим отлавливать ошибки, то можем использовать метод `catch` вместо then:

```javascript
prom.catch(
  error => console.log(result.message)
);
````

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
prom
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То можно принять ошибку не только из prom, но и из then.

При возникновении ошибки она проскакивает все звенья цепочки до первого попавшегося catch. Если там ее не обработать, она полетит до следующего catch и так до тех пор, пока цепочка не закончится и скрипт не ляжет.

### Метод finally

Метод `finally` принимает функцию без аргументов:

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно он нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис - успешно или нет. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый метод возвращает промис, то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение, а передает его дальше:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => {
    console.log("Выполняем общие действия.");
    return 10;  // <-- Пытаемся перекрыть результат исходного промиса
  })
  .then(result => {
    console.log(result);  // 5
  });
```

Хотя finally тоже возвращает промис, но как мы видим, результат колблэка в finally (10) игнорируется и в колбэк в then попадает значение 5.

# Цепочки промисов

## Механика работы цепочки

Методы then, catch и finally тоже возвращают промисы, поэтому можно формировать из них цепочки. Например:

```javascript
// Это цепочка
prom
  .then(F1)   // 1
  .then(F2)   // 2
  .then(F3)   // 3
  .catch(F4)  // 4
  .finally(F5);  // 5

// А это - не цепочка, потому что каждый метод вызывается на исходном промисе
prom.then(F1);
prom.then(F2);
prom.then(F3);
prom.catch(F4);
prom.finally(F5);
```

Каким образом эти методы формируют промисы? Грубо говоря, первый then выполняет функцию F1, которую мы ему передали (колбэк), берет ее результат и возвращает нечто вроде:

```javascript
return new Promise((resolve, reject) => resolve(результат));
```

> P.S. Реальное устройство конечно сложнее, но для логического понимания как это работает, такой модели достаточно.

Таким образом на выходе первого then получается новый промис, завершенный, с готовым результатом. На этом промисе вызывается второй then и происходит то же самое - выполняется колбэк F2, его результат оборачивается в промис и этот промис возвращается. И так до конца по всей цепочке.

Отличия заключаются только в том, что именно возвращает колбэк. Он может вернуть простое значение, или вообще ничего, а может вернуть промис. Рассмотрим разные ситуации на конкретных примерах.

## Примеры работы цепочек

### Колбэк не возвращает ничего

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {  // <-- Колбэк выведет результат промиса в консоль и ничего не вернет
    console.log(result);  // 5
  })
  .then(result => {  // <-- Поэтому сюда не попадет никакое значение
    console.log(result);  // undefined
  });
```

Результат первого then можно воспринимать как

```javascript
return new Promise((resolve, reject) => resolve());
```

### Колбэк возвращает простое значение

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);  // 5
    return "Привет, промис!";  // <-- Колбэк вернул простое значение
  })
  .then(result => {
    console.log(result);  // Привет, промис!
  });
```

Результат первого then можно воспринимать как

```javascript
return new Promise((resolve, reject) => resolve("Привет, промис!"));
```

### Колбэк возвращает промис

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);  // 5
    return new Promise((resolve, reject) => {  // <-- Результат колбэка - промис
      let ms = 2000;
      setTimeout(() => resolve(`Вы увидели это сообщение с задержкой ${ms} мс.`), ms);
    });
  })
  .then(result => {
    console.log(result);  // Вы увидели это сообщение с задержкой 2000 мс.
  });
```

Поскольку результатом колбэка уже является промис, можно считать, что then его и возвращает.

### Ошибка в колбэке

Когда промис завершен через reject или когда возникает не пойманная ошибка в самом промисе или в колбэке в then \ catch \ finally - это все по сути одно и то же. Промис переходит в состояние rejected и сохраняет в себе эту ошибку:

```javascript
new Promise((resolve, reject) => {
  // <-- Ошибка могла бы быть тут
  resolve(5);  // <-- Или вместо resolve мог быть reject
})
  .then(result => {
    console.log(result);
    // <-- И тут могла бы быть ошибка
    return new Promise((resolve, reject) => {
      let ms = 2000;
      setTimeout(() => reject(new Error("Ошибочка вышла!")), ms);
    });
  })
  .catch(err => {  // <-- В любом случае мы объект этой ошибки получили бы тут
    console.log(err.message);  // Ошибочка вышла!
  });
```

```javascript
new Promise((resolve, reject) => {
  resolve(5);
})
  .then(result => {
    console.log(result);
    throw new Error("Ошибочка вышла!");
  })
  .catch(err => {
    console.log(err.message);  // Ошибочка вышла!
  });
```

Важный момент: если написать вот так:

```javascript
new Promise(() => {
  setTimeout(() => { throw new Error("Ошибка в промисе!"); }, 1000);  // <-- throw в setTimeout
})
  .then(result => console.log(result))
  .catch(err => console.log(err.message));
```

То в catch мы не попадем, потому что выброс ошибки произошел в отложенном коде. Ошибки ловятся "автоматически" только если происходят синхронно.

# Пример

Задача такая: подключить библиотеку lodash и с помощью нее вывести в консоль случайное число.

```javascript
function addScript(src) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Не удалось подключить скрипт ${src}.`));
    document.head.append(script);
  });  
}

addScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js")
  .then(result => printRandomNumber(1, 100))
  .catch(err => console.log(err.message));

function printRandomNumber(min, max) {
  console.log(_.random(min, max));
}
```

Комментарии:

* Функция добавления скрипта на страницу возвращает промис.
  * В данном случае мы подключаем скрипт lodash. Он лежит по известному адресу в интернете.
  * Подключение заключается в создании элемента `<script>` и добавлении его на страницу программным способом.
  * Скачивание начинается в момент выполнения .append
  * Если элемент скрипта добавился на страницу нормально, то он браузер выполняет onload, а если есть проблемы - onerror.
    * Именно поэтому мы на эти события навешиваем лямбды с вызовом resolve и reject.
    * Т.о. промис завершится, когда сработает одно из этих событий.
* На промис мы вешаем обработчики результата и ошибки.
  * В случае успеха вызываем функцию, которая пользуется lodash'ем для генерации случайного числа.
    * Как такового "результата" работы у нашего работяги нет, поэтому вызываем `resolve()`  без аргументов. Результатом является сам факт успешной загрузки скрипта и добавление его на страницу.
  * В случае ошибки просто выводим текст ошибки в консоль.



