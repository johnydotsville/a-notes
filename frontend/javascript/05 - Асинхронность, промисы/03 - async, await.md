# async \ await

## Концепция

`async` и `await` это ключевые слова, которые упрощают работу с промисами, позволяя организовать асинхронный код в линейном виде, похожим на синхронный. Благодаря этому можно, например, ставить точки останова так же, как в синхронном коде.

* `async` применяется к функции и оборачивает ее результат в успешно завершенный промис.
* `await` применяется к промису для извлечения из него результата (или ошибки). Соответственно, await можно применять к функции, возвращающей промис, или async-функции (что по сути одно и то же).

Видимый эффект от применения await такой, будто скрипт ожидает, пока промис завершится, а потом идет дальше. Но на самом деле код после await асинхронный, соответственно выполнение не зависает.

## Пример

Возьмем обычный промис:

```javascript
function doSome() {  // <-- Сымитируем функцию, которая делает что-то асинхронно, типа fetch    
  return new Promise((resolve, reject) => {
    console.log("Промис начал работу");
    const value = Math.random() * 10;
    const success = value >= 5;
    if (success)
      resolve(value);
    else
      reject(new Error("doSome не смогла выполниться"));
  });
}
```

### Промис без сахара

Извлечем из него результат без использования await:

```javascript
doSome()  // <-- Чтобы получить результат, нам придется использовать then
  .then(result => {
    console.log("Результат получен");
    console.log(result);
  })
  .catch(err => console.log(err.message));

console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

В данном случае мы должны писать код, которому нужен результат, внутри then, что все же затрудняет восприятие и менее симпатично, чем линейный код без колбэков.

### Промис с async \ await

Теперь обработаем результат, но будем использовать await:

```javascript
async function foobar() {
  try {
    const result = await doSome();  // <-- Получаем результат промиса через await
    console.log("Результат получен");  // <-- Сюда попадаем только после завершения промиса
    console.log(result);
  } catch (err) {
    console.log(err.message);
  }
}

foobar();
console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

Больше then не требуется - await извлекает из промиса непосредственно сам результат и возвращает его. Если там ошибка и промис отклонен, то await дает эффект, будто эта ошибка выбросилась, поэтому ее можно поймать обычным try-catch. Если не поймать, то async-функция вернет rejected-промис.

Все, что идет со следующей строки после await, выполнится только после завершения промиса. При этом код остается асинхронным, т.е. грубо говоря, все что идет после await просто как бы становится колбэком для ожидаемого промиса, как будто мы все это поместили в then.

Из тонкостей: await можно использовать только внутри async-функций и нельзя использовать на уровне скрипта. Хотя 