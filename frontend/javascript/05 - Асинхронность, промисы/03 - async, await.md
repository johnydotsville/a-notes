# async \ await

## Концепция

`async` и `await` это ключевые слова, которые упрощают работу с промисами, позволяя организовать асинхронный код в линейном виде, похожим на синхронный. Благодаря этому можно, например, ставить точки останова так же, как в синхронном коде.

* `async` - используется при объявлении функции. Позволяет использовать внутри функции слово await. Если функция, объявленная с async, возвращает какой-то результат, то этот результат оборачивается в успешно завершенный промис. Если внутри функции возникает исключение, то оно оборачивается в отклоненный промис. Т.е. в любом случае результатом async-функции является промис. Eсли функция ничего не возвращает и в ней не произошло исключение, то можно считать, что возвращается промис с resolve() без значения.
* `await` - используется для извлечения результата из промиса. Обычно применяется к функциям, возвращающим промис. Если применить await к промису, то вернется значение, с которым промис был зарезолвлен. Если же промис отклонен, то await выбросит исключение с отклоненным значением.

Видимый эффект от применения await такой, будто скрипт ожидает, пока промис завершится, а потом идет дальше. Но на самом деле код после await асинхронный, соответственно выполнение не зависает.

## Пример

Возьмем обычный промис:

```javascript
function doSome() {  // <-- Сымитируем функцию, которая делает что-то асинхронно, типа fetch    
  return new Promise((resolve, reject) => {
    console.log("Промис начал работу");
    const value = Math.random() * 10;
    const success = value >= 5;
    if (success)
      resolve(value);
    else
      reject(new Error("doSome не смогла выполниться"));
  });
}
```

### Промис без сахара

Извлечем из него результат без использования await:

```javascript
doSome()  // <-- Чтобы получить результат, нам придется использовать then
  .then(result => {
    console.log("Результат получен");
    console.log(result);
  })
  .catch(err => console.log(err.message));

console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

В данном случае мы должны писать код, которому нужен результат, внутри then, что все же затрудняет восприятие и менее симпатично, чем линейный код без колбэков.

### Промис с async \ await

Теперь обработаем результат, но будем использовать await:

```javascript
async function foobar() {
  try {
    const result = await doSome();  // <-- Получаем результат промиса через await
    console.log("Результат получен");  // <-- Сюда попадаем только после завершения промиса
    console.log(result);
  } catch (err) {
    console.log(err.message);
  }
}

foobar();
console.log("Конец программы");
/*
  Промис начал работу
  Конец программы
  Результат получен  // Или "doSome не смогла выполниться"
  7
*/
```

Больше then не требуется - await извлекает из промиса непосредственно сам результат и возвращает его. Если там ошибка и промис отклонен, то await дает эффект, будто эта ошибка выбросилась, поэтому ее можно поймать обычным try-catch. Если не поймать, то async-функция вернет rejected-промис.

Все, что идет со следующей строки после await, выполнится только после завершения промиса. При этом код остается асинхронным, т.е. грубо говоря, все что идет после await просто как бы становится колбэком для ожидаемого промиса, как будто мы все это поместили в then.

Из тонкостей: await можно использовать только внутри async-функций и нельзя использовать на уровне скрипта. Хотя 