Тту куча всякой ерунды, которую надо будет потом причесать и свести воедино после сбора достаточного количества фактов.

# Классы

Класс по своей природе - это функция.

## Единственный конструктор

* Конструктор обозначается ключевым словом `constructor`.
* Конструктор может быть только один в том плане что нельзя написать два раза constructor и сделать "конструктор без параметров", "конструктор с одним параметром" и т.д. TODO: а как тогда тут такое делается? Или это вообще невозможно?

```javascript
class User {

  constructor(name) {
    this.name = name;
  }

  introduce() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

let user = new User("Tom");

console.log(user.name);
```



## Свойства

* Свойства теоретически можно вообще не объявлять, поскольку в JS свойство добавляется в объект при обращении к отсутствующему свойству. Например, пишем вот так:

  ```javascript
  class User {
  
    constructor(name) {
      this.name = name;
    }
  
  }
  ```

  И свойство name появляется.

## Методы

* Методы классов - это не то же самое, что свойства-функции в объектах. Метод, полученный от класса, нельзя "выдернуть" из объекта и использовать самостоятельно. Тут https://learn.javascript.ru/class-inheritance об этом подробнее.

### Синтаксис

* Между методами в классах не надо ставить запятые, потому что это не свойства-функции, как было в объектах.

```javascript
class Animal {
  move(speed) {
    console.log(`Животное двигается со скоростью ${this.speed}`);
  }
   
  stop() {
    this.speed = 0;
    console.log("Животное остановилось.");
  }
}
```

### Статические методы и свойства

* Статический метод и свойство принадлежит классу, а не объекту.
* Статические методы и свойства наследуются.

```javascript
class Animal {
  constructor(name, speed) {
    this.name = name;
    this.speed = speed;
  }

  static whoIsFaster(a, b) {
    if (a.speed > b.speed)
      console.log(`${a.name} быстрее, чем ${b.name}.`);
    else
      console.log(`${b.name} быстрее, чем ${a.name}.`);
  }
}


let rabbit = new Animal("Кролик", 5);
let cat = new Animal("Кошка", 15);
Animal.whoIsFaster(rabbit, cat);  // Кошка быстрее, чем Кролик.
```



# Class expression

Поскольку класс это функция, то с ним можно делать все то же самое, что с функцией - например, передавать куда-то и там использовать.

```javascript
class User {

  constructor(name) {
    this.name = name;
  }

}

function create(klass, username) {
  return new klass(username);
}

let user = create(User, "Huck");

console.log(user.name);  // Huck
```



# Наследование классов

## Синтаксис

### extends

Наследование выполняется ключевым словом `extends`:

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} побежал со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} встал на месте.`);
  }
}
```

```javascript
class Rabbit extends Animal { 
  hide() {
    console.log(`${this.name} спрятался.`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(2);  // Белый кролик побежал со скоростью 2.
rabbit.stop();  // Белый кролик встал на месте.
rabbit.hide();  // Белый кролик спрятался.
```

### Выражение после extends

После `extends` можно указывать любое выражение, результатом которого является класс:

```javascript
function foobar() {
  return class {  // return class Animal {  // Можно указывать имя класса
    constructor(name) {
      this.name = name;
    }

    run() {
      console.log(`${this.name} бежит.`);
    }
  }
}

class Rabbit extends foobar() {  // <-- Вызываем функцию, которая возвращает класс
  hide() {
    console.log(`${this.name} спрятался.`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run();
rabbit.hide();
```



## Поиск методов

Поиск методов осуществляется в таком порядке:

* Непосредственно в объекте, на котором метод вызван.
* В прототипе объекта (по сути, в классе, из которого создан объект).
* В прототипе прототипа (по сути, в классе-родителе того класса, из которого создан объект).

Первый пункт может показаться странным после перехода более традиционных ООП-языков вроде Java, но в JS мы можем добавить метод непосредственно в объект в любое время, поэтому здесь так.

Родительский класс:

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} побежал со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} встал на месте.`);
  }
}
```

Класс-потомок:

```javascript
class Rabbit extends Animal { 
  hide() {
    console.log(`${this.name} спрятался.`);
  }
}
```

Объект из класса-потомка, и этому объекту мы добавили дополнительный метод:

```javascript
let rabbit = new Rabbit("Белый кролик");

rabbit.chew = function() {
  console.log(`${this.name} жует траву.`);
};

rabbit.chew();  // Белый кролик жует траву.
```

## Переопределение

### Переопределение методов

* Чтобы переопределить метод родителя, достаточно в потомке создать аналогичный метод. Никаких особенных ключевых слов не требуется.
* Для вызова родительской реализации есть ключевое слово `super.метод()`.
* Вызывать родительскую реализацию не обязательно в первой же строке, можно сделать это в любом месте.

```javascript
class Animal {  // <-- Родительский класс
  constructor(name) {
    this.name = name;
  }

  stop() {
    console.log(`${this.name} встал на месте.`);
  }
}

class Rabbit extends Animal {  // <-- Класс-потомок
  hide() {
    console.log(`${this.name} спрятался.`);
  }

  stop() {  // <-- Пишем аналогичный метод, чтобы переопределить родительский
    super.stop();  // <-- Вызываем родительский, если надо
    this.hide();  // <-- Можно даже поменять местами, сначала вызвать hide, а потом super.stop()
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.stop();
/*
  Белый кролик встал на месте.
  Белый кролик спрятался.
*/
```

### Переопределение конструктора

* Когда у потомка нет собственного конструктора, то автоматически ему назначается такой конструктор:

  ```javascript
  constructor(...args) {
    super(...args);
  }
  ```

* Если мы хотим создать для потомка собственный конструктор, то обязаны вызвать в нем родительский конструктор (через `super()`) и сделать это *до* первого использования this.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Rabbit extends Animal {
  constructor(name, earLeng) {
    super(name);  // <-- super() вызываем обязательно, причем до первого использования this
    this.earLeng = earLeng;  // <-- Нельзя написать это перед вызовом super
  }
}

let rabbit = new Rabbit("Белый кролик", 20);

console.log(rabbit.name);     // Белый кролик
console.log(rabbit.earLeng);  // 20
```

### Переопределенные поля в родительском конструкторе

У родительского конструктора есть особенность: он всегда использует поля из собственного класса. Пример для наглядности, что имеется ввиду:

```javascript
class Animal {
  name = "Животное";

  constructor() {
    console.log(this.name);  // <-- Всегда будет использовать "Животное"
    this.move();  // <-- А тут зависит от того, кто вызывает
  }

  move() {
    console.log(`${this.name} передвигается.`);
  }
}

class Rabbit extends Animal {
  name = "Кролик";

  move() {
    console.log(`${this.name} прыгает.`);
  }
}

let rabbit = new Rabbit();
/*
  Животное
  Животное прыгает
*/
```

В чем здесь интерес? Rabbit является потомком Animal и имеет такое же поле (name) и такой же метод (move). Кролик наследует конструктор животного, в котором выводится значение поля и вызывается метод move. При этом видно, что значение name берется из класса Animal, а реализация метод - из класса Rabbit (иначе было бы написано "Животное передвигается"). В этом и заключается тонкость - родительский конструктор всегда использует поля из собственного класса. Подробнее об этом тут https://learn.javascript.ru/class-inheritance



# public, private, protected

* В JS нет языковой реализации protected. Она существует на уровне договоренности, что все свойства и методы, которые начинаются с подчеркивания `_`, можно использовать только внутри объекта. Т.о., эти свойства и методы наследуются и доступны в потомках, но снаружи "условно не доступны".
* private элементы реализуются добавлением символа `#` к имени свойства или метода и являются частью имени. Т.е. обращаться к ним нужно например так `this.#amount`. Это новый синтаксис, пока не так широко поддерживается.

```javascript
class Kettle {
  #currentVolume = 0;  // <-- Синтаксическая реализация private-уровня

  constructor(maxVolume, power) {
    this._maxVolume = maxVolume;  // <-- Эмуляция protected-уровня, через соглашение о _
    this._power = power;
  }

  get currentVolume() {  // <-- Для чтения private-поля делаем геттер
    return this.#currentVolume;
  }
  
  addWater(volume) {  // <-- Контролируем количество добавляемой воды
    let newVolume = this.#currentVolume + volume;
    if (newVolume > this._maxVolume) {
      console.log("Вы пытаетесь добавить слишком много воды.");
      return;
    }
    this.#currentVolume = newAmount; 
  }
}

let ket = new Kettle(3000, 250);
ket.addWater(5000);
ket.#currentVolume = 5000;  // Ошибка! Нельзя обратиться к приватному полю.
```

