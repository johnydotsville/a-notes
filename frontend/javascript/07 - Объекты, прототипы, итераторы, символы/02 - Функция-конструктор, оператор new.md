# Смысл конструктора

Технически, конструктор - это обычная функция в объекте, для которой просто есть некоторые соглашения:

* Имя функции-конструктора должно начинаться с большой буквы. Может и с маленькой, но принято с большой, чтобы сразу было видно, что это именно функция-конструктор.
* Вызывать функцию нужно с помощью оператора `new`.

Пример функции-конструктора:

```javascript
function User(name) {
  this.name = name;
};

let tom = new User("Tom");
let huck = new User("Huck");
```

Можно сказать, что new под капотом добавляет в функцию такие действия:

```javascript
function User(name) {
  this = {};  // Создает новый пустой объект и кладет его в this
  this.name = name;
  return this;  // Возвращает this в конце функции
};
```

Т.о., с помощью конструктора мы можем создавать много однотипных объектов.

## Вызов без new

Технически, можно вызывать конструктор без new, но тогда объект не создастся, результатом будет undefined:

```javascript
function User(name) {
  this.name = name;
}

let tom = User("Tom");

console.log(tom);  // undefined
```

Внутри конструктора с помощью конструкции `new.target` можно проверить, вызван ли конструктор без new:

* `new.target === undefined` - значит вызвано без new.
* `new.target === "имя функции"` (например, `User(name)` в нашем случае) - значит вызвано с new.

```javascript
function User(name) {
  if (new.target === undefined) {  // Если вызвали без new, мы за их поправим
    return new User(name);
  }
  this.name = name;
}

let tom = User("Tom");

console.log(tom);  // User {name: 'Tom'}, теперь объект создался.
```

# Одноразовый конструктор

Если при создании объекта нужна какая-то сложная логика, но при этом объект планируется сделать только один, то мы можем эту логику создания поместить в безымянную функцию, которая тут же выполнится. Получится своеобразный "одноразовый конструктор":

```javascript
let tom = new function() {  // new заставит функцию выполниться сразу
  if (2 > 1) {  // Имитация сложной логики
      this.name = "Tom";
  } else {
      this.name = "Huck";
  }
}
```

# return в конструкторе

`return` в конструкторе писать не принято. Однако, синтаксически это возможно. Здесь два варианта:

* Если return пустой или содержит примитив, то из конструктора ничего не вернется, будто return нет вовсе.
* Если return возвращает объект, то вернется именно этот объект.

Например:

```javascript
function User(name) {
  this.name = name;
  return 100;  // <-- return с примитивом
}

let tom = new User("Tom");

console.log(tom);  // User {name: 'Tom'}, return'а как будто и не было
```

```javascript
function User(name) {
  this.name = name;
  return { age: 30 };  // <-- return с произвольным объектом
}

let tom = new User("Tom");

console.log(tom);  // {age: 30}, вернулся объект из return, а не тот, который мы хотели создать.
```

# Методы в конструкторе

Кроме обычных значений, мы можем добавить объекту методы в конструкторе:

```javascript
function User(name) {
  this.name = name;

  this.hello = function() {  // Кладем функции в поля наряду с обычными значениями
    console.log(`Hello, my name is ${this.name}!`);
  }
}

let tom = new User("Tom");
tom.hello();  // Hello, my name is Tom!
```

Стоит отметить, что вот так добавить функции не получится:

```javascript
function User(name) {
  this.name = name;

  hello: function() {  // <-- Так нельзя добавить функцию объекту
    console.log(`Hello, my name is ${this.name}!`);
  }
}
```

Потому что это получается просто описание какой-то функции внутри конструктора и эта функция никуда не сохранена. Не стоит путать конструктор с обычным описанием объекта, в котором этот синтаксис краткого описания функции привел бы к ее в появлению в объекте.

# Прототип и функция-конструктор

У функций (кроме лябмд), есть свойство prototype. Если в него записать какой-нибудь объект, то он будет установлен как прототип для всех объектов, создаваемых с помощью этой функции:

```javascript
let device = {
  connected: false
};

function Mouse(buttons, wired) {
  this.buttons = buttons;
  this.wired = wired;
}

Mouse.prototype = device;  // <-- Указываем, какой прототип ставить объектам, созданным через ФК Mouse

let mouse = new Mouse(5, true);  // <-- Теперь объект device будет прототипом объекта mouse

console.log(mouse.connected);  // false  // <-- Без 10 строчки было бы undefined
```

Вообще, в свойстве prototype у любой функции уже есть по умолчанию объект. Но подробнее об этом в конспекте про классы и про то, как они были устроены до появления слова `class`.