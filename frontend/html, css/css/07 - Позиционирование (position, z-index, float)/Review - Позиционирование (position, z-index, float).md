# position

* Свойство `position` 

  * Задает модель позиционирования.

  * Значения.

    * `static` - дефолтное.
      * Элемент находится на своем нормальном месте в потоке.
      * На элемент не действуют позиционирующие свойства.
    * `relative`
      * Элемент находится на своем нормальном месте в потоке.
      * На элемент действуют позиционирующие свойства.
    * `absolute`
      * Элемент выбивается из потока документа и перестает занимать в нем место, как будто его вообще нет. Визуально перекрывает элементы, оставшиеся в потоке.
      * Ширина элемента становится такой же как ширина его контента.
      * На элемент действуют позиционирующие свойства.
        * Позиционирование идет от ближайшего не-static родителя.
          * Если такого родителя нет, то позиционирование идет от body.
      * Часто absolute используется в комбинации с relative-родителем.
      * Трюк с растягиванием элемента на весь размер родителя:
        * Родителю ставим relative, потомку - absolute и также потомку top, right, bottom и left ставим 0 (или inset 0, чтобы разом для всех сторон).
    * `fixed`
      * Элемент выпадает из потока.
      * На элемент действуют позиционирующие свойства.
        * Позиционирование ведется от краев окна.
          * Хорошо подходит для оформления модальных окон.
    * `sticky`
      * Что-то вроде комбинации relative+fixed.
      * От relative у него то, что он изначально находится на своем нормальном месте в потоке и на него действуют позиционирующие свойства.
      * От fixed у него то, что в момент, когда прокрутка доходит до этого элемента, он "залипает" на одном месте экрана, как fixed.
      * Механика работы:
        * Позиционирующие свойства определяют расстояние от краев окна, при котором элемент должен залипнуть.
        * Когда в результате прокрутки расстояние становится как заданное, элемент залипает на экране на одном месте.
        * Когда прокрутка уходит ниже родителя, sticky-элемент остается в границах родителя и его уже не видно на экране.
      * Особенности:
        * Родитель у стики-элемента не обязательно дб relative.
        * Стики-элемент не ограничивает видимую область родителя. Поэтому когда прочее содержимое родителя оказывается под стики-элементом, они наслаиваются друг на друга.
          * Если под стики-элементом оказывается текст, то этот текст "под" ним. Чтобы избежать визуального перемешивания, можно задать стики-элементу фон.
          * Если под стики-элементом оказывается картинка, то она "над" ним и перекрывает его. Чтобы это исправить, можно выставить стики-элементу z-index.

    

    # z-index

    * Элементы позиционируются не только по горизонтали и вертикали, но еще у них есть глубина.
      * Свойство `z-index` отвечает за положение "по глубине".
    * z-index можно задать только не-static элементам.
    * По умолчанию z-index больше у тех элементов, которые ниже по разметке.
    * Элементы с бОльшим z-index находятся поверх элементов с меньшим z-index.
    * По умолчанию z-index у всех равен auto и браузер сам расставляет им глубину.
    * Элемент с заданным z-index считается выше любого элемента, у которого z-index не задан.
      * Хорошей практикой является задание элементам индексов, кратных 10 или 100. Это позволяет при необходимости проще вставлять новые слои.
    * z-index и вложенные элементы.
      * Z-index вложенных элементов зависит от z-index родителя.
        * Если у родителя задан z-index, то у вложенных элементов z-index не может быть меньше родительского. Т.о. вложенный элемент никак не может визуально оказаться позади родителя.
      * Z-index у элементов, вложенных в разных родителей, не влияют друг на друга.
        * Т.е. z-index у вложенных элементов имеют значение только в пределах этого родителя.

    

    # float

    * `float` в современном мире нужно использовать только по его прямому назначению - оформлять обтекание блока текстом.
    * Значения:
      * none - дефолт.
      * left
      * right
    * float-элемент является блочным, но при этом его ширина становится как ширина его контента.
    * float-элементы выпадают из потока и визуально нависают над обычными элементами.
    * Механика такова, что хотя обычный элемент, оставшийся в потоке, не замечает float-элемент, но текст внутри обычного элемента - замечает float и поэтому упирается в его границу, а не заползает под него.
    * Механики:
      * float и горизотальные отступы.
        * Если надо оттолкнуть текст от float-элемента, то надо делать это через margin float-элемента, а не через padding элемента с текстом. Потому что паддинг будет работать относительно границы самого элемента с текстом.
      * Как обычный элемент может увидеть float.
        * Свойство `clear`
          * Если нужно, чтобы элемент начал замечать float вокруг себя, надо задать ему свойство clear.
          * Значения.
            * left, right, both - соответственно, элемент будет видеть "левые", "правые" float или оба.
      * float'ы видят друг друга и сталкиваются друг с другом в случае чего.
      * Контейнеры с float-элементами внутри.
        * Контейнер не выделяет высоту под float-элемент, потому что не видит его. Из-за этого этот элемент может вылезти за пределы контейнера визуально и перекрыть элементы под контейнером.
          * Чтобы этого не случилось, ставим контейнеру свойство `display: flow-root`

    