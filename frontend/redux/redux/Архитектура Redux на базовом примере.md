# Создание проекта

Написано на основе официального [гайда](https://react-redux.js.org/introduction/getting-started#installation) с сайта редакса. Я выбрал вариант шаблона на основе скрипта `create-react-app`, поэтому команды взял [отсюда](https://github.com/reduxjs/redux-templates/tree/master/packages/cra-template-redux).

* Чтобы команды работали, должен быть установлен node js.

* Создаем директорию под будущую программу и переходим в нее через консоль.

* Используем следующую команду для разворачивания программы из шаблона (my-app это имя директории, куда будет развернута программа):

  ```
  npx create-react-app my-app --template redux
  ```

* При выполнении этой команды автоматически скачаются все необходимые зависимости.

* Для запуска проекта переходим через консоль в его корень и выполняем команду `npm start`.

# Пример

Здесь общий пример, который в следующем разделе будет разбит на отдельные файлы. Там же и более подробное объяснение. А тут только основные моменты объяснены комментариями в коде.

```react
import { useRef } from 'react';
import { createStore } from 'redux';  // <-- Для создания хранилища
import { useDispatch } from 'react-redux';  // <-- Для регистрации изменения хранилища
import { useSelector } from 'react-redux';  // <-- Для подписки на изменение хранилища
import { Provider } from 'react-redux';  // <-- Для предоставления компонентам доступа к хранилищу

// <-- Объект начального состояния
const initialState = {
  name: null
}

// <-- Редюсер, задаем начальное состояние и описываем обработчики для возможных действий.
const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_NAME':
      return {
        ...state,
        ...action.payload
      }
    default:
      return state;
  }
}

// <-- Хранилище. Создаем хранилище и указываем редюсер.
const myStore = createStore(reducer);

// <-- Действие. Формируем объект, который будет понятен редюсеру.
const actionSetName = (name) => {
  return {
    type: 'SET_NAME',
    payload: {
      name: name
    }
  }
}

// <-- Корневой компонент
export default function ReduxBasicDemo() {
  return (
    <Provider store={myStore}>
      <Name />
      <Display />
    </Provider>
  );
}

// <-- Компонент, который изменяет состояние
function Name() {
  const fname = useRef();
  // <-- Получаем функцию для регистрации изменения хранилища.
  const dispatch = useDispatch();

  // <-- Отправляем в хранилище запрос на изменение.
  const applyName = () => dispatch(actionSetName(fname.current.value));

  return (
    <div>
      <input ref={fname}/>
      <button onClick={applyName}>Задать</button>
    </div>
  );
}

// <-- Компонент, который читает состояние.
function Display() {
  // <-- Подписываем компонент на уведомления об изменении хранилища и извлекаем нужные данные.
  const name = useSelector(state => state.name);

  return (
    <div>
      {name ?? "Здесь будет имя"}
    </div>
  );
}
```

Общая схема работы редакса такова:

* Мы создаем *хранилище* и передаем в него *редюсер* (или несколько редюсеров). Хранилище - это исключительно редаксовая тема (импортируется из пакета `redux`).

* Оборачиваем приложение в *провайдер* `Provider` и указываем ему хранилище. Это уже реактовская тема, созданная для интеграции реакта с редаксом (поэтому и импортируется из пакета `react-redux`). Т.о., все вложенные в провайдер компоненты будут иметь доступ к хранилищу.

* В хранилище лежит объект, представляющий собой *состояние* приложения. TODO: похоже, что общее состояние приложения собирается из начальных состояний, которые мы указываем в редюсерах.

* Состояние изменяется в редюсерах. На самом деле состояние не *ИЗ*меняется, а *ЗА*меняется новым, которое формируется на основе склейки старых данных и пришедших новых.

* *Редюсер* - это обычная функция с двумя параметрами: состояние и *действие*.

* Общая схема работы с состоянием такова:

  * Мы регистрируем изменение состояния путем передачи редаксу т.н. *действия*. Действие содержит *тип действия* и полезную нагрузку *payload*, содержащую новые данные, которые надо встроить в состояние. 

    Чтобы зарегистрировать изменение состояния, мы должны вызвать специальную функцию-*диспетчер*. Ее мы можем получить, вызвав хук `useDispatch` из пакета react-redux. В эту функцию мы как раз и передаем действие.

  * Когда редакс получает от нас действие, он пропускает его через редюсеры, а также передает редюсерам текущее состояние.

  * Редюсеры анализируют тип действия и когда какой-то редюсер видит, что обработать действие - это его задача, то он на основе текущего состояния и данных из действия формирует новый объект состояния и редакс заменяет им старое состояние.

  * Когда изменяется состояние, то реакт перерисовывает компоненты, которые подписаны на эти изменения. Подписка компонента на состояние осуществляется с помощью хука `useSelector(s => s.somePartOfState`) из пакета react-redux. Сам факт использования этого хука в компоненте подписывает компонент на изменение состояния. Причем обычно не на изменение состояния целиком, а какой-то его части - той, что возвращается из переданного колбэка. В данном случае - somePartOfState. P.S. Если в селекторе вернуть состояние целиком, в консоли даже выведется предупреждение, что скорее всего вы ошиблись, браток, подписываться на изменение целого состояния не канонично.

# Структуризация приложения

Есть несколько способов организовать структуру redux-приложения. Воспользуемся вот таким:

```
src
  components
    Display.js
    Name.js
  store
    actions
      index.js
    reducers
      index.js
      nameReducer.js
    store.js
index.js
```

Все файлы, относящиеся к редаксу, будут лежать в директории `src/store`.

## Редюсеры

Сначала оформим редюсеры. Выделим для них директорию `reducers`.

### Редюсеры в отдельных файлах

Каждый редюсер разместим в отдельном файле. С каждым редюсером связано начальное состояние. Внутри редюсера пишем обработку для действий, на которые он должен реагировать. Обычно редюсеров много. TODO: реакт собирает итоговое состояние из начальных состояний, указанных для редюсеров.

```react
// Файл: src/store/reducers/nameReducer.js
const initialState = {
  name: null
}

export const nameReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_NAME':
      return {
        ...state,
        ...action.payload
      }
    default:
      return state;
  }
}
```

### Собираем редюсеры вместе

Создаем в папке с редюсерами файл `index.js`. Он оказывается в директории `src/reducers`. Такое имя файла позволит нам делать импорт из него вот так `import foobar from './src/reducers'`, т.е. не указывать имя файла, а импортировать как бы "из директории", для сокращения пути. Хотя это конечно вкусовщина, но просто полезный трюк.

```react
// Файл: src/store/reducers/index.js
import { combineReducers } from 'redux';

import { nameReducer } from "./nameReducer";  // <-- Импортируем все редюсеры из отдельных файлов

export default combineReducers({  // <-- Собираем кучу редюсеров в единый объект
  nameReducer
  // <-- Тут могло быть больше редюсеров
  // foobar: nameReducer  // <-- Можно задать произвольное имя поля для редюсера
});
```

* Импортируем все редюсеры из отдельных файлов.
* С помощью редаксовой функции `combineReducers` собираем их в единый объект, чтобы разом потом передать в хранилище.
  * Важный момент: при комбинировании мы можем указать произвольное имя для редюсера. Оно повлияет на то, по какому имени мы будем обращаться к фрагменту состояния. Видно в следующем разделе "Создаем хранилище".

## Создаем хранилище

```react
// Файл src/store/store.js
import { createStore } from 'redux';  // <-- Импортируем функцию для создания хранилища
import rootReducer from './reducers';  // <-- Импортируем объект, содержащий все редюсеры

const myStore = createStore(rootReducer);  // <-- Создаем хранилище и передаем ему редюсеры

export default myStore;
```

> Здесь мы пользуемся тем самым трюком "импортирования из директории" `./reducers` (без необходимости писать `./reducers/index`). P.S. Хотелось бы как-то оформить этот трюк в самостоятельном виде, но пока не придумал, куда засунуть, пусть полежит тут.

Передаем в функцию создания хранилища объект, объединивший в себе все редюсеры, и редакс соберет исходное состояние из элементов, указанных в первом параметре редюсеров. TODO: наверное это так работает. Потом поправить, если выясню, что это не так.

В данном случае у нас единственный редюсер nameReducer, первым параметром которого является вот такой объект:

```javascript
const initialState = {
  name: null
}
```

Поэтому итоговое состояние будет представлено таким объектом:

```javascript
{
  nameReducer: {  // <-- Здесь могло быть foobar или любое другое кастомное имя
    name: null
  }
}
```

Обратите внимание, что "кусочки" состояния попадают в итоговый объект состояния под теми именами, которые мы указали в combineReducers, когда собирали редюсеры в единый объект. Если бы мы собрали их вот так:

```javascript
export default combineReducers({
  foobar: nameReducer
});
```

Тогда объект хранилища выглядел бы так:

```react
{
  foobar: {
    name: null
  }
}
```

## Корневой компонент

В корневом компоненте нам понадобятся компоненты, которые мы хотим снабдить доступом к хранилищу, само хранилище и провайдер хранилища:

```react
// Файл src/ReduxBasicDemo.js
import Name from './components/Name';  // <-- Компоненты, которые будут
import Display from './components/Display';  // <-- пользоваться хранилищем

import { Provider } from 'react-redux';  // <-- Провайдер хранилища
import myStore from './store/store';  // <-- Само хранилище

export default function ReduxBasicDemo() {
  return (
    <Provider store={myStore}>
      <Name />
      <Display />
    </Provider>
  );
}
```

Тут все просто: оборачиваем в провайдер все приложение и указываем провайдеру хранилище.

## Действия

Действия складываем в отдельную директорию `store/actions`, в файл index.js, чтобы проще было импортировать.

```react
// Файл store/actions/index.js
export const actionSetName = (name) => {
  return {
    type: 'SET_NAME',
    payload: {
      name: name
    }
  }
}
```

Действие - это обычная функция, параметры которой представляют собой данные, которые мы хотим встроить в состояние. По соглашениям, у действия должно быть два поля:

* `type` - строка с типом действия. По этому полю редюсеры поймут, кто из них должен обработать действие.
* `payload` - объект, содержащий данные, которые нужно встроить в состояние. Обычно, даже если данные представлены единственной переменной, как в этом примере, все равно payload оформляется как объект.

## Компонент, изменяющий состояние

```react
// Файл src/components/Name.js
import { useRef } from 'react';
import { useDispatch } from 'react-redux';  // <-- Хук для получения функции-диспетчера
import { actionSetName } from '../store/actions'  // <-- Действие, которое мы хотим произвести

export default function Name() {
  const fname = useRef();
  const dispatch = useDispatch();  // <-- Получаем функцию-диспетчер

  // <-- Отправляем редаксу запрос на изменение состояния
  const applyName = () => dispatch(actionSetName(fname.current.value));

  return (
    <div>
      <input ref={fname}/>
      <button onClick={applyName}>Задать</button>
    </div>
  );
}
```

Все, что нам нужно для изменения состояния - сформировать нужное действие с данными и отдать его в функцию диспетчеризации. Далее редакс передаст это действие и текущее состояние редюсерам, а они уже разберутся, кому из них надо это действие обработать и как модифицировать состояние.

## Компонент, читающий состояние

```react
// Файл /src/components/Display.js
import { useSelector } from 'react-redux';  // <-- Хук для подписания компонента на изменения хранилища

export default function Display() {
  // <-- Подписываем компонент и извлекаем интересующую нас часть состояния
  const name = useSelector(state => state.nameReducer.name);

  return (
    <div>
      {name ?? "Здесь будет имя"}
    </div>
  );
}
```

Подписка на изменения хранилища осуществляется простым фактом использования в компоненте хука useSelector. Использовали этот хук - значит подписали компонент. На какие именно изменения - определяем в колбэке. В данном случае на изменение поля `nameReducer.name`. Подписываться на изменения всего состояния не рекомендуется. Если написать `state => state`, то в консоли браузера даже выведется сообщение:

> Selectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.

Поэтому выделяем из состояния только нужный нам фрагмент и пользуемся им в компоненте. А как только эта часть изменится, то реакт об этом узнает и перерисует компонент.