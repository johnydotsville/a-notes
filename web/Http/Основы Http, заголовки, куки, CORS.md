# Структура Http

[История](https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP) знает 4 версии протокола Http:

* 0.9 - Примерно 1990 год. Во времена ее использования собственно версии вообще не было, а 0.9 придумали уже потом, после выхода других версий, просто чтобы различать.
* 1.0 - 1996 год.
* 1.1 - 1999 год.
* 2.0 - 2015 год.

Кроме технических улучшений и оптимизаций, в версии 2.0 сам запрос перестал быть обычным текстом и приобрел двоичную форму. Так что теперь его просто так не почитать. Но по сути вот так примерно выглядит формат Http:

<img src="img/image-20220601154902531.png" alt="image-20220601154902531" style="zoom:80%;" />

Итого 4 ключевых элемента:

* "Первая строка"

  В запросе это - глагол, url и версия протокола

  В ответе это - версия протокола, статус-код, статус-сообщение

  Т.е. каждый элемент отделен пробелом

* Заголовки - дополнительная информация, помогающая серверу обработать запрос. Начинаются со второй строки, и до пустой строки. Про заголовки написано отдельно.

* Пустая строка - служит признаком того, что после нее начинается тело (если тип запроса предполагает его наличие. Например, у GET нет тела, а у POST - есть)

* Тело - данные произвольной длины, "нагрузка" (payload) запроса

# Заголовки

О заголовках нужно думать относительно того, кто шлет запрос\ответ. Есть заголовки общие, а есть специфичные для клиента\сервера.

* *Accept* - клиентский, указывает формат данных, который клиент ожидает\предпочитает получить в ответе. Например, json.
* *Content-type* - общий, формат данных, который пересылается ???в теле??? в запросе.
* *Content-Length* - общий, длина данных, расположенных в теле.
* *Set-Cookie* - серверный. Если браузер видит в ответе от сервера этот заголовок, то создает и сохраняет у себя куку с указанным значением и параметрами.
* *Host* - клиентский, нужен, когда в url явно не указан хост (как так может быть - отдельная тема). Если хост в url указан, то этот заголовок игнорируется. Заголовок Host должен быть только один, иначе обычно возвращается код 400 (Bad Request). Если порт не указан, то для Http используется порт 80 по умолчанию, а для Https - 403.

## Заголовки авторизации



# Куки

В основном взято [отсюда](https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies)

## Что такое куки

Куки - это данные (обычно небольшое количество) вспомогательного характера, которые передаются между браузером и сервером. 

## Как куки создаются

Впервые кука создается в браузере. В общих чертах процесс возникновения куки выглядит так:

* Браузер посылает на сервер какой-то запрос

* Сервер возвращает ответ, в котором, среди прочих заголовков, может присутствовать заголовок *Set-Cookie* (или несколько таких заголовков, если надо создать несколько кук). Куки-заголовки в ответе выглядят примерно так:

  ```java
  Set-Cookie: key1=value1; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure
  Set-Cookie: key2="value2"; Max-Age=31449600; Path=/; secure; SameSite=Strict; HttpOnly
  ```

* Видя заголовок Set-cookie в ответе, браузер понимает, что надо создать куку

* Он ее создает и хранит у себя, и отправляет на сервер в заголовке *Cookie* с каждым очередным запросом. Кука отправляется только на тот сервер, который приказал браузеру создать ее. Если кук несколько, все они идут через `;` в одном заголовке. Пример запроса с куки-заголовком, который клиент посылает на сервер:

  ```java
  GET /spec.html HTTP/1.1
  Host: www.example.com
  Cookie: foo=10; bar=20  // <-- Вот они, несколько кук в одном заголовке
  Accept: */*
  ```

## Доступность кук

Куки доступны из JS через document.cookies. Но не все, а только установленные браузером для домена, с которого получена текущая страница. Т.е. на "странице" невозможно получить куки "другого сайта".

## Формат кук

Вот пример заголовка, содержащего куки:

```
Set-Cookie: key1=value1; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure
Set-Cookie: key2="value2"; Max-Age=31449600; Path=/; secure; SameSite=Strict; HttpOnly
```

Куки хранятся в формате ключ-значение, причем значение может быть заключено в кавычки, если надо. После этого идут дополнительные параметры куки - например:

* Max-Age или expires - время жизни куки
* HttpOnly - запрет получать значение куки через Javascript
* sercure - возможность отправлять куку только через Https с использованием SSL

 Параметров довольно много, это отдельная тема.

## Время жизни кук

По времени жизни куки делятся на два вида:

* Permanent cookie ("со сроком годности") - существуют заранее определенный промежуток времени, в течение которого браузер продолжает их хранить и отправлять, а по истечении этого промежутка - удаляет.

  Браузер создает такие куки, когда сервер присылает куку с заголовком *Expires* или *Max-Age*. В первом случае указывается дата и время, по какое существует кука. Во втором - количество секунд.

* Session cookie - существуют и отправляются, пока идет активный обмен между браузером и сервером. Когда активный обмен заканчивается (например, закрыли браузер), такие куки удаляются. Но в браузерах обычно есть опция "восстановления сеанса", при которой куки не удаляются и сеанс длится как бы бесконечно.

# Сессии

Http - это stateless протокол ("протокол без сохранения состояния"). Это значит, что сервер воспринимает каждый запрос как независимую единицу, даже если он приходит от одного и того же клиента. В stateful протоколах (например, FTP) каждый запрос от одного и того же клиента рассматривается именно как часть цепочки запросов.

Тем не менее, в Http конечно же есть средство для связи между запросами, благодаря чему мы можем, например, оставаться авторизованными на сайте в течение долгого времени. Этим механизмом являются *сессии*. Сервер генерирует некоторый идентификатор и отправляет его клиенту в ответе вместе с прочими данными, а клиент при последующих запросах отсылает этот идентификатор серверу.

Есть разные способы реализации сессий: через куки, через передачу в строке запроса (если например куки отключены), возможно еще какие-то. Независимо от способа реализации, *суть сессии* всегда одинакова - уникальный идентификатор, который ходит вместе с запросами и по которому сервер распознает клиента.

# CORS

В 1995 году в браузере Netscape Navigator появилась концепция Same-origin Policy ("политика одного источника"). Если грубо и без деталей, то она про то, что если страница, загруженная с сервера А, захочет как-то взаимодействовать с другой страницей\ресурсом, которая\ый находится другом сервере В, то браузер такой запрос не выполнит (или сервер В этот запрос отклонит). Сделано это для безопасности. Под "как-то взаимодействовать" понимаются самые разные вещи, например, отправка запроса к странице, загрузка файла со стилями, использование картинки, когда все это лежит на другом сервере, нежели страница, на которой этим хотят пользоваться.

Наивный, но наглядный пример: есть какой-нибудь сайт A, требующий авторизации. Пользователь на этом сайте зарегистрирован и авторизован (его браузер сохранил куки). Злоумышленник на своем сайте B размещает страницу, в которой кроме всего прочего есть скрипт, отправляющий запрос на удаление аккаунта на сайте А. Так что как только пользователь заходит на сайт В и страница загружается, то скрипт отправляет запрос удаления аккаунта на сайт А, а браузер автоматически добавляет к запросу нужные куки, потому что делает это при любом обращении к серверу, если для этого сервера есть куки. Все, аккаунта нет.

С политикой одного источника такое невозможно. Однако есть множество случаев, когда такая политика слишком строга. Например, многие сайты собирают новости с других сайтов, показывают картинки\содержимое, которые тоже находятся в других источниках. Поэтому и существует **CORS** (Cross-Origin Resource Sharing), который дает гибкости и позволяет настроить условия взаимодействия между разными ресурсами.

# POST

Есть несколько вариантов передачи данных в теле, кроме привычного json:

* *x-www-form-urlencoded*

  Данные в теле выглядят как обычная url строка с параметрами:

  ```
  source=en&target=ru&text=Hello%20world
  ```

  Все символы, которые не цифры и не латинские буквы, кодируются через percent encoding, поэтому этот способ не подходит для передачи двоичных данных.