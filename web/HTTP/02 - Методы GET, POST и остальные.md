# Метод

Метод запроса (или еще называется глагол) отражает намерение, действие по отношению к ресурсу. Метод *запроса*, как видно из названия, присутствует только в *запросе* (в *ответе* его нет), в первой его строке среди прочей информации.

Технически, методы взаимозаменяемы, поскольку имеют одинаковую структуру. Например, для удаления ресурса можно использовать не DELETE, а POST или даже GET. Однако с логической точки зрения это не правильно и противоречит концепции ReST. Разные методы введены именно с целью добавить запросам логичности и предсказуемости.

# Безопасность, идемпотентность и кэшируемость

Эти три характеристики относятся к методами.

## Безопасность (Safe)

*Безопасный* запрос ([moz](https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP), [rfc](https://httpwg.org/specs/rfc9110.html#safe.methods)) не должен приводить к изменению состояния сервера и не может нагрузить \ повредить сервер. По своей природе безопасный запрос является read-only.

Под изменением состояния сервера понимается создание какого-то нового объекта ресурса. Например, если мы запрашиваем данные о каком-то товаре, то безопасный запрос не должен приводить к созданию нового товара. При этом если сервер, например, логирует каждый пришедший запрос, то это не считается изменением состояния сервера.

Безопасность запроса - это рекомендация. Например, GET или HEAD запросы являются безопасными, согласно спецификации. Однако *реальное* обеспечение этой безопасности лежит на прикладной программе. Причем не на веб-сервере, который лишь принимает и направляет запрос в нужное приложение, а именно на самом приложении, которое непосредственно разбирает запрос и выполняет какие-то действия для его обработки. Т.е. фактически, когда мы пишем веб-приложение, это наша забота писать его так, чтобы запросы, объявленные в спецификации безопасными, не могли положить его и сервер. Т.о. клиенты смогут спокойно использовать безопасные запросы, не боясь ничего повредить.

Все безопасные запросы являются *идемпотентными*.

## Идемпотентность (Idempotent)

Запрос считается *идемпотентным* ([moz](https://developer.mozilla.org/en-US/docs/Glossary/Idempotent), [rfc](https://httpwg.org/specs/rfc9110.html#idempotent.methods)) если выполнение нескольких идентичных запросов оказывает на состояние сервера такое же воздействие, как выполнение только одного такого запроса.

Например, DELETE запрос `/goods/5` на удаление товара с указанным идентификатором является идемпотентным, потому что если мы вызовем его хоть 10 раз подряд, то состояние сервера изменится только один раз - товар 5 удалится, а все последующие вызовы такого же запроса уже ничего не удалят.

А вот DELETE запрос `/goods/last` на удаление последнего товара в БД идемпотентным не является. Предположим, у нас семь товаров в базе. Первый такой запрос удалит седьмой товар, второй запрос удалит шестой товар, третий запрос - пятый товар и т.д. В итоге, хотя запросы идентичные, но каждый из них меняет состояние сервера, следовательно, не является идемпотентным.

К идемпотентности относится только состояние сервера. Если запрос, на первом примере с удалением, вернул 200, а все последующие возвращают 404, то от этого не перестает быть идемпотентным.

Как видно, идемпотентность тоже является рекомендацией и ответственность по ее соблюдению лежит на прикладной программе. Программа может выполнять какие-угодно действия, но это уже ее дело. С точки же зрения клиента, он может спокойно повторить идемпотентный запрос, не боясь наслоения эффектов. Например, он послал запрос на удаление или обновление данных, а связь прервалась и он не знает, отработал запрос или нет. Зная, что запрос идемпотентный, клиент шлет запрос повторно, не боясь наслоения эффектов.

## Кэшируемость

Это возможность для клиента сохранить у себя ответ и воспользоваться им в следующий раз, вместо того чтобы снова слать запрос на сервер ([moz](https://developer.mozilla.org/en-US/docs/Glossary/Cacheable), [rfc](https://httpwg.org/specs/rfc9110.html#cacheable.methods))

Вопрос кэшируемости непростой и требует отдельного рассмотрения.

# Краткая характеристика методов

| Метод   | Описание                                                     | Safe               | Idmpt                 | Cache              | Doc                                                          |
| ------- | ------------------------------------------------------------ | ------------------ | --------------------- | ------------------ | ------------------------------------------------------------ |
| GET     | Получение представления ресурса. Например, получить данные клиента по идентификатору клиента. | :heavy_check_mark: | :heavy_check_mark:    | :heavy_check_mark: | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET), [rfc](https://www.rfc-editor.org/rfc/rfc9110#GET) |
| HEAD    | Работает так же, как в аналогичном случае сработал бы GET, но возвращает только *заголовки*, без тела. Например, может быть использован, чтобы просто проверить, существует ли в базе данных клиент с указанным идентификатором, без возврата непосредственных данных о клиенте. Или если URL предназначен для скачки файла, то с помощью HEAD-запроса можно узнать размер файла, не скачивая его. | :heavy_check_mark: | :heavy_check_mark:    | :heavy_check_mark: | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD), [rfc](https://www.rfc-editor.org/rfc/rfc9110#HEAD) |
| POST    | Отправить сущность на указанный ресурс. Обычно сопровождается изменением состояния сервера и сайд-эффектами. Например, добавить в БД нового клиента. | :x:                | :x:                   | :heavy_plus_sign:  | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST), [rfc](https://www.rfc-editor.org/rfc/rfc9110#POST) |
| PUT     | Предполагает *полную* замену представления ресурса данными из нагрузки запроса. Например, есть представление `{ "name": "John", "surname": "Doe" }`. Если отправить PUT-запрос `{ "surname": "Wick" }`, то ресурс превратится в `{ "surname": "Wick" }`, т.е. поле name у представления вообще исчезнет. Именно это понимается под полной заменой - представление приобретает вид точь-в-точь как в нагрузке. Если представления не существует, в принципе не запрещается создать его. | :x:                | :heavy_check_mark:    | :x:                | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT), [rfc](https://www.rfc-editor.org/rfc/rfc9110#PUT) |
| PATCH   | Предполагает *частичное* изменение представления ресурса данными из нагрузки запроса. Например, есть представление `{ "name": "John", "surname": "Doe" }`. Если отправить PATCH-запрос `{ "surname": "Wick" }`, то ресурс превратится в `{ "name": "John", "surname": "Wick" }`, т.е. поле name останется как было, а значение поля surname изменится на другое. Если представления не существует, в принципе не запрещается создать его. | :x:                | :heavy_check_mark::x: | :heavy_plus_sign:  | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH), [rfc](https://www.rfc-editor.org/rfc/rfc5789) |
| DELETE  | Удалить представление ресурса. Например, удалить клиента из БД. | :x:                | :heavy_check_mark:    | :x:                | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE), [rfc](https://www.rfc-editor.org/rfc/rfc9110#DELETE) |
| CONNECT |                                                              | :x:                | :x:                   | :x:                | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT), [rfc](https://www.rfc-editor.org/rfc/rfc9110#CONNECT) |
| OPTIONS |                                                              | :heavy_check_mark: | :heavy_check_mark:    | :x:                | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS), [rfc](https://www.rfc-editor.org/rfc/rfc9110#OPTIONS) |
| TRACE   |                                                              | :heavy_check_mark: | :heavy_check_mark:    | :x:                | [moz](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE), [rfc](https://www.rfc-editor.org/rfc/rfc9110#TRACE) |

> :heavy_plus_sign: означает "Да, но с нюансами"
>
> :heavy_check_mark::x: означает "Может быть и да, и нет, в зависимости от надобности"

## PUT, PATCH и идемпотентность

Допустим, у нас есть такой ресурс:

```json
{
    "id": 13,
    "name": "John",
    "surname": "Doe",
    "email": "johndoe@gmail.com",
    "office": "Chicago"
}
```

Если мы выполняем PATCH-запрос `/employee/13` с нагрузкой

```json
{
    "office": "Milwaukee"
}
```

То в ответ получаем представление вида:

```json
{
    "id": 13,
    "name": "John",
    "surname": "Doe",
    "email": "johndoe@gmail.com",
    "office": "Milwaukee"  // <-- Офис изменился
}
```

Если кто-то другой выполнит PATCH с нагрузкой

```json
{
    "surname": "Wick"
}
```

То мы, выполнив свой PATCH повторно, получим представление уже с *чужими изменениями*:

```json
{
    "id": 13,
    "name": "John",
    "surname": "Wick",  // <-- Фамилия изменилась
    "email": "johndoe@gmail.com",
    "office": "Milwaukee"
}
```

В данном случае запрос не перестает быть идемпотентным, хотя мы получили *не такой* ответ, как после первого своего патча. Дело в том, что *мы* фамилию не трогали. Мы изменили только офис. Соответственно, в данном случае идемпотентность предполагает ориентацию только по полям, которые сам запрос затрагивает непосредственно.

Запрос PUT всегда идемпотентный, поскольку предполагает полную замену представления на нагрузку.

# Замечания

Поскольку запросы обрабатывают не только json'ы, но и файлы и т.д., то использование тех или иных глаголов в разных случаях может иметь вообще разную окраску и то, что кажется нереалистичным в обработке одного типа данных, может вполне быть логичным для другого типа.

Например, запрос PUT концептуально предполагает полную замену представления нагрузкой. Если у нас есть БД, в которой мы храним информацию о сотруднике в виде `[id, name, surname, email, office]`, а нам приходит PUT, в котором `[name, age]`, то что это значит? Что мы должны дропнуть из таблицы поля id, surname, email, office и добавить новое поле age? Выглядит абсурдно. По крайней мере в сценарии обработки данных. Если это API для управления таблицами БД, тогда уже выглядит более логично. Но вот если мы используем PUT для отправки фотографии, то все как будто бы становится логично - мы просто заменяем старую фотографию на новую. Или редактирование статьи \ поста в блоге. Мы целиком заменяем текст статьи, поэтому PUT хорошо логически подходит для этой операции.

Поэтому когда дело касается выбора метода, то вероятно надо, держа в уме стоящую задачу, перечитать спецификацию по методам и подобрать тот, который логически наиболее подходит под эту задачу.
