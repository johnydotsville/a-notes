# ReST как концепция

Representational State Transfer (передача состояния представления) - это архитектурный стиль. Протоколом не является, это именно стиль, т.е. можно сказать набор *правил \ рекомендаций* организации API, в отличие от SOAP, который является протоколом и вводит свои дополнительные обертки поверх сообщения. Поскольку ReST - это концепция, а не технология, он не привязан к конкретному протоколу, но зачастую применяется для реализации веб-сервисов с использованием HTTP. Опять же, ввиду того, что это лишь концепция, могут встречаться разные реализации, которые не в полной мере соответствуют каноничному ReST.

ReST - это результат размышлений Роя Филдинга в своей диссертации. [Ссылка на диссертацию](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1).

# Определение ресурса

В ReST ключевой абстракцией является ресурс. Ресурс это не конкретная картинка, документ или что-то еще, что можно получить по "ссылке", а сама "ссылка". А вот картинка \ документ - это *представление* ресурса. Рой Филдинг определяет ресурс как функцию, которая в каждый момент времени указывает на набор сущностей. Т.е. сущности - это данные, а ресурс - это "ссылка", которая их позволяет получить.

Понятие ресурса не ограничивается "картинками, документами, данными о клиенте". Ресурсом может быть и бизнес-процесс, например, создание банковского счета для человека.



# ReST-требования

Чтобы удовлетворять принципам ReST, система должна соблюдать следующие правила:

### Клиент-серверная архитектура.

Система должна состоять из клиентов и серверов. Клиенты - шлют запросы для получения ресурсов, а сервера на эти запросы отвечают. Один и тот же компонент может быть как клиентом, так и сервером. Например, приложение запрашивает у сервиса А какой-нибудь отчет, а этот сервис запрашивает данные для этого отчета у сервиса В. Получается, что А выступает и в роли сервера, и в роли клиента.

TODO: какие еще в этом плане бывают альтернативы для К-С архитектуры? Пишут про какие-то события.

### Отсутствие состояния

Клиент и сервер никак не запоминают историю взаимодействия друг с другом. Каждый запрос обрабатывается без оглядки на другие и запросы к ресурсам могут идти в любом порядке. Ни у сервера, ни у клиента нет никаких ожиданий друг друга, что например запросы должны следовать в каком-то порядке, содержать какую-то конкретную информацию. Пример противовеса этому - установление безопасного соединения в TLS, где сообщения должны идти в определенном корректном порядке.

Такие вещи как аутентификация этот принцип не нарушают, поскольку в любом виде так или иначе auth-информация прикрепляется к каждому запросу и запрос в этом плане может быть рассмотрен без привязки к предыдущим запросам.

### Кэшируемость

Сервер обозначает каждый свой ответ как кэшируемый или некэшируемый. Это позволяет сократить объем запросов за счет того, что клиент, получив кэшируемый ответ, сохранит его у себя и в следующий раз возьмет данные из своего кэша, а не будет слать еще один запрос на сервер. Теоретически, кэширование может понизить надежность, потому что данные в кэше могут устареть.

### Многослойность

В системе могут быть не только клиенты и серверы, но и прокси - промежуточные звенья, которые для "первичных" клиентов выступают как серверы, принимают их запросы, а потом ретранслируют их серверам или другим прокси.

### Унифицированный интерфейс

Это понятие включает в себя следующие вещи:

* Идентификатор ресурса.

  У каждого ресурса должен быть постоянный уникальный идентификатор, который не изменяется, а если изменяется, то сервер должен сообщить об этом клиенту. Пример: `http://example.com/users?city=moscow` здесь уникальный идентификатор это сам URL+критерий. Постоянство и неизменяемость для него означает, что:

  1. *Смысл* параметра city не изменится. Если он означал "город, в котором пользователь живет", то он не станет вдруг означать "город, который пользователю больше всего понравился во время путешествий".
  2. Сам параметр city не изменится, например, на place. А если вдруг изменится, то должна остаться и старая версия с city, обращение к которой продолжить работать, но например с сообщением, мол, "city теперь переименован в place, пожалуйста учтите это в работе своих программ, потому что через три месяца city будет удален окончательно".

* Управление ресурсом через представление.

  Это значит, что клиент посылает серверу ресурс в том виде, в каком клиент этот ресурс хочет видеть, а сервер приводит его к этому "видению" (представлению).

* Самодостаточные сообщения.

  Каждое сообщение как от клиента, так и от сервера, должно быть самодостаточным, т.е. и тот, и другой должны иметь возможность понять это сообщение без дополнительной информации (например, без других сообщений). Как пример - возвращаемый клиенту HTML должен быть синтаксически полным, чтобы браузер смог его отобразить.

* Гипермедиа.

  Это данные, которые содержат информацию о том, какие еще запросы может выполнить клиент при работе с запрошенным ресурсом. TODO: уточнить.

# Резюме

ReST - это просто 4 буквы, которые придумал чел для своей философской диссертации по компуктер-саенс. Никто в современном мире не знает, что такое ReST, каждый понимает и реализует по-своему, даже технологические гиганты. Поэтому заморачиваться и пытаться разобраться - бесполезно. Нельзя разобраться в том, что не имеет четкого определения.

Главное просто понимать, что такое ресурс и делать API, исходя из здравой логики, а не следовать догмам вроде "глаголы не использовать".