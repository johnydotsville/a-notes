# Предисловие

Файлы в терминах гита могут находиться в разных состояниях. Некоторые из этих состояний имеют техническое выражение, а некоторые могут являться, так сказать, "логическими" состояниями или статусами, маркерами и т.д., т.е. не иметь реального технического выражения.

Возиться и пытаться раскопать, кто есть кто - как будто бы не практично. На понимание и способность пользоваться это не влияет. Поэтому я просто перечислю все "состояния" кучей.

# Жизненный цикл файла

![file-status-lifecycle.drawio](img/file-status-lifecycle.drawio.svg)

В целом путь файла довольно простой:

* Мы кладем файл в рабочую директорию.
* Затем добавляем его в индекс (стейдж).
* Делаем коммит и таким образом файл попадает в БД гита, грубо говоря.

P.S. Файл может проходить и обратный путь "коммит > индекс > рабочая директория", подробнее в конспекте про движение файла.

Т.о. мы можем выделить три области, через которые проходит файл:

```
Рабочая директория (Working Directory, WD) --> Индекс (Stage, Index) --> Коммит (папка .git)
```

И основная концепция работы такова: сделали что-то с файлом и хотим сохранить это в гит? Тогда добавляем файл в индекс и делаем коммит. Переход между конкретными состояниями при этом на самом деле не столь важен. Важно понимать именно этот переход между областями.

Еще важным замечанием является то, что после коммита индекс очищается, а все файлы в рабочей директории становятся unmodified.

Файлы могу называть так:

* Файл, лежащий в рабочей директории (в "рабочке") - `рабочий` файл.
* В индексе - `индекс`-файл.

Сложность может возникнуть с пониманием удаления файла. Т.е. когда мы создаем новый файл, добавляем его в индекс, а потом коммитим - это понятно. Мы коммитим новый добавленный файл. А когда мы удаляем файл, мы тоже должны добавить это в индекс. Но что - "это"? Ведь файл удален! Что мы добавляем? Мы добавляем как бы "действие" удаления. Об этом я еще напишу в соответствующем конспекте, просто решил здесь упомянуть тоже.

# Состояния файла

* `Untracked` - это файлы в рабочей директории, которые не находятся под надзором гита. Например, если мы создали новый файл в рабочей директории, то гит расценит его как untracked. Либо если мы намеренно скажем гиту перестать отслеживать какой-то файл, то он тоже станет untracked.
* `Tracked` - это файлы, за изменениями над которыми гит следит. Такого состояния или статуса \ маркера нет, это просто логическая группировка. Т.е. все состояния \ статусы \ маркеры, перечисленные ниже, подразумевают что гит за этим файлом следит.
  * `Unmodified` - в файле не было изменений после коммита.
  * `Modified` - в файле были изменения после коммита.
  * `Staged` - в это состояние файл переходит, когда мы помещаем его в индекс. В коммит этот файл попадет именно в том виде, какой был на момент помещения в индекс. Если в файл снова внести какие-то изменения, то они не попадут автоматически в индекс. Файл будет считаться modified и чтобы подготовить новые изменения к коммиту, надо опять добавить файл в индекс.
  * `Committed` - файл сохранен в БД гита.
  * `Unmerged` - файл находится в процессе слияния и в нем есть конфликты.
  * `Copied`, `Deleted`, `Renamed` - это файлы, которые были скопированы, удалены или переименованы. Чтобы файл стал copied или renamed, то надо копировать и переименовывать его командами самого гита, а не, например, средствами файловой системы. Если делать через файловую систему, то например переименование файла приведет как бы к двум логическим действиям - удалению файла со старым именем и добавление файла с новым.

Некоторые из этих "состояний" можно видеть в виде маркеров в выводе команды `git status -s` или в виде словесных описаний в выводе `git status`. Некоторые - невидимые. Допустим, unmodified файлы нет смысла показывать в выводе git status, потому что если их не трогали, то и зачем зашумлять вывод? Некоторые маркеры, вроде `A`, являются действительно именно просто маркерами, а не самостоятельным состоянием.

В общем, в конспектах, посвященных конкретным действиям по управлению файлами, еще будет вся нужная информация. А из этого конспекта главное понять основной принцип перехода файлов между областями и идею смены состояний.
