# Rebase-слияние

Ребейз проходит в два этапа:

* Переходим на ветку, `КОТОРУЮ` хотим перебазировать. Обычно это фичеветка:

  ```
  git checkout feature/f1
  ```

* Указываем ветку, `НА` которую будем перебазировать. Обычно это мастер или другая ветка, изменения из которой мы хотим учесть в своей фичеветке:

  ```
  git rebase master
  ```

# Механика ребейза

## Концепция

Концептуально суть ребейза - это поменять родителя у базового коммита ветки.

Допустим, фичеветка началась от коммита m2 ветки master. Затем в мастер сделали еще два коммита. Тогда ребейз фичеветки на мастер концептуально сведется к тому, что базовым коммитом фичеветки станет m4:

![rebase-concept.drawio](img/rebase-concept.drawio.svg)

Получится эффект, будто бы фичеветку стартовали от последнего коммита мастера. Это позволит при merge сделать fast-forward, т.е. просто переместить указатель master на последний коммит фичеветки. Если постоянно пользоваться ребейзом перед вливанием веток, то получится эффект, будто бы никакого ветвления не было и все коммиты добавлялись в мастер напрямую и он будет выглядеть как ровная цепочка коммитов.

Вот для сравнений механика merge, если не пользоваться ребейзом. При ней всегда образуется новый коммит слияния и история коммитов уже не выглядит как ровная цепочка:

![merge-mechanics.drawio](img/merge-mechanics.drawio.svg)

## Техническая реализация

Технически ребейз конечно не просто изменяет указатель родительского коммита в f1, а создает абсолютно новые коммиты rf1 и rf2. Они содержат код из f1 и f2 с учетом кода из m4. И если будут конфликты между m4 и кодом из новых коммитов, придется их решить.

![rebase-mechanics.drawio](img/rebase-mechanics.drawio.svg)

Поскольку ребейз сам по себе не вливает фичеветку в мастер, все равно придется потом сделать merge фичеветки. Просто после свежего ребейза merge выполнится путем fast-forward, без образования merge-коммита.