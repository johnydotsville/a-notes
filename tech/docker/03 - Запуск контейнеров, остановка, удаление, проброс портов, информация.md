

# Образы

## Скачать образ

```
docker pull bitnami/kafka:latest
```

## Список всех скачанных\созданных образов

```
docker images
```

## Удалить образ

```
docker rmi 23id228322  // или имя вместо id
```

Образ может не удалиться, если есть контейнеры, которые его используют

# Контейнеры

## Список контейнеров

Список контейнеров, которые работают прямо *сейчас*:

```
docker ps
```

* `-a` - показать список всех имеющихся контейнеров, а не только работающих.
* `-q` - выводить только id контейнеров

## Проброс портов

Делается при первичном запуске контейнера с помощью ключа `-p`. Добавил это отдельным разделом, просто чтобы отметить важность. Непосредственный синтаксис - в разделе о запуске контейнера.

## Первичный запуск контейнера

> Здесь для примера используется контейнер с Postgre, но объяснены настройки самой постгри, потому что этот конспект позиционируется как общий. Для более детального описания поднятия и настройки контейнера именно с постргрёй, см конспект в папке postgres.

````
docker run --name pgs -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres
````

Создает и запускает из образа *postgres* контейнер, присваивая ему имя *pgs*.

* `-d` - если есть, запускается в *detached*-режиме (background). Если нету, в *attached* (foreground).

  В attached-режиме консоль, в которой запущена команда run, "связывается" с процессом контейнера, это значит, что вся информация от него в виде логов будет выводиться в эту консоль. Видно ошибки приложения, удобно. В detached-режиме, соответственно, консоль "освобождается" после запуска и ее можно использовать для других целей. При этом никаких сообщений от контейнера не видно.

* `-e` - флаг для установки переменных окружения. Каждую переменную нужно задавать через отдельный ключ -e. В контейнерах уже могут быть какие-то переменные окружения. Этим флагом можно их переназначить, или создать новые. В данном примере переменной POSTGRES_PASSWORD присвоится значение mysecretpassword.

  TZ=Europe/Moscow - пример установки временной зоны.

* `-p` - проброс портов в формате "*порт хоста:порт приложения*" в контейнере. Например, в контейнере работает веб-приложение, которое слушает порт 8080. Поскольку контейнер изолирован, хост (компьютер, на котором запущен докер) ничего не знает об этом порте. Поэтому нужно явно при запуске задать соответствие портов. Можно замапить любой порт хоста на порт приложения. Какие порты слушает приложение, можно узнать командой *docker inspect SomeImageName* (если конечно автор образа указал их через EXPOSE в Dockerfile)

  Полезный пример проброса портов: например, мы поднимаем сервер Postgres в контейнере, а подключаться к нему хотим через pgAdmin, установленный на компьютере. Сервер использует порт 5432, поэтому нам нужно пробросить его, чтобы pgAdmin смог достучаться до сервера, работающего в контейнере. 

* `--name` - имя, которое присвоится разворачиваемому контейнеру. Если запускать с разными именами, получаются разные контейнеры.

* `--rm` - после остановки контейнера (либо если он сам завершит работу) он автоматически удалится

* `-v` - монтирование папки хоста в контейнер "*absolute/host/path/folder/:/usr/src/app/folder/*"  В качестве основы для пути контейнера указываем папку, в которую копировали приложение при сборке образа (как на "точку отсчета" директорий в контейнере влияет WORKDIT из Dockerfile в данном случае, не проверял). Теперь можно менять на хосте, например, содержимое файла, из которого программа в контейнере что-то читает, и программа новые данные увидит.

  Вместо пути хоста можно указывать volume (как создать volume - в отдельном конспекте). *volumeName:/usr/src/app/resources*

## Повторный запуск контейнера

Для запуска контейнера, который уже ранее запускался, есть отдельная команда:

```
docker start -a containterName
```

* `-a` - attach, присоединиться к контейнеру, чтобы в консоль выводилась информация о его работе. То же самое, когда при run не используем -d

## Запуск нескольких связанных контейнеров

Делается с помощью команды `docker-compose`, о которой написано в отдельном конспекте. Там же написано про тонкости, что например каждый контейнер обладает собственными портами, которые не пересекаются с портами других работающих контейнеров и т.д. Запуск нескольких контейнеров вместе необходим, например, для кафки, потому что для ее работы требуются и другие вещи, не только она сама.

## Остановить контейнер

```
docker stop 46286a4fff79  // или имя вместо id
```

Остановленный контейнер сохраняет свое состояние, так что можно например создать в БД таблицу, остановить контейнер, запустить его через start и таблица будет на месте.

## Удалить контейнер

```
docker rm 46286a4fff79  // или имя вместо id
```

# Информация

## Общая информация о докере

Сколько образов, контейнеров, и много чего еще:

```
docker info
```

## О контейнерах, образах

Универсальная команда получения расширенной информации как о контейнерах, так и об образах:

```
docker inspect someContainerOrImageName
```


