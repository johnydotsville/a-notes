

# Образы

## Скачать образ

```
docker pull bitnami/kafka:latest
```

## Список всех скачанных\созданных образов

```
docker images
```

## Удалить образ

```
docker rmi 23id228322  // или имя вместо id
```

Образ может не удалиться, если есть контейнеры, которые его используют

# Контейнеры

## Список контейнеров

Список контейнеров, которые работают прямо *сейчас*:

```
docker ps
```

* -a - показать список всех имеющихся контейнеров, а не только работающих.
* -q - выводить только id контейнеров

## Первичный запуск контейнера

````
docker run --name MyPostgres -e POSTGRES_PASSWORD=mysecretpassword -p 8090:8080 postgres
````

Создает и запускает из образа *postgres* контейнер, присваивая ему имя *MyPostgres*

* -d - если есть, запускается в detached-режиме (background). Если нету, в attached (foreground).

  В attached-режиме консоль, в которой запущена команда run, "связывается" с процессом контейнера, это значит, что вся информация от него в виде логов будет выводиться в эту консоль. Видно ошибки приложения, удобно. В detached-режиме, соответственно, консоль "освобождается" после запуска и ее можно использовать для других целей. При этом никаких сообщений от контейнера не видно.

* -e - флаг для установки переменных окружения. В контейнерах уже могут быть какие-то переменные окружения. Этим флагом можно их переназначить, или создать новые. В данном примере переменной POSTGRES_PASSWORD присвоится значение mysecretpassword.

  TZ=Europe/Moscow - пример установки временной зоны.

* -p - проброс портов в формате "*порт хоста:порт приложения*" в контейнере. Например, в контейнере работает веб-приложение, которое слушает порт 8080. Поскольку контейнер изолирован, хост ничего не знает об этом. Поэтому нужно явно при запуске задать соответствие портов. Можно замапить любой порт хоста на порт приложения. Какие порты слушает приложение, можно узнать командой *docker inspect SomeImageName* (если конечно автор образа указал их через EXPOSE в Dockerfile)

* --name - имя, которое присвоится разворачиваемому контейнеру. Если запускать с разными именами, получаются разные контейнеры.

* --rm - после остановки контейнера (либо если он сам завершит работу) он автоматически удалится

* -v - монтирование папки хоста в контейнер "*absolute/host/path/folder/:/usr/src/app/folder/*"  В качестве основы для пути контейнера указываем папку, в которую копировали приложение при сборке образа (как на "точку отсчета" директорий в контейнере влияет WORKDIT из Dockerfile в данном случае, не проверял). Теперь можно менять на хосте, например, содержимое файла, из которого программа в контейнере что-то читает, и программа новые данные увидит.

  Вместо пути хоста можно указывать volume (как создать volume - в отдельном конспекте). *volumeName:/usr/src/app/resources*

## Повторный запуск контейнера

Для запуска контейнера, который уже ранее запускался, есть отдельная команда:

```
docker start -a containterName
```

* -a - attach, присоединиться к контейнеру, чтобы в консоль выводилась информация о его работе. То же самое, когда при run не используем -d

## Запуск нескольких связанных контейнеров

Делается с помощью команды `docker-compose`, о которой написано в отдельном конспекте. Там же написано про тонкости, что например каждый контейнер обладает собственными портами, которые не пересекаются с портами других работающих контейнеров и т.д. Запуск нескольких контейнеров вместе необходим, например, для кафки, потому что для ее работы требуются и другие вещи, не только она сама.

## Остановить контейнер

```
docker stop 46286a4fff79  // или имя вместо id
```

Остановленный контейнер сохраняет свое состояние, так что можно например создать в БД таблицу, остановить контейнер, запустить его через start и таблица будет на месте.

## Удалить контейнер

```
docker rm 46286a4fff79  // или имя вместо id
```

# Информация

## Общая информация о докере

Сколько образов, контейнеров, и много чего еще:

```
docker info
```

## О контейнерах, образах

Универсальная команда получения расширенной информации как о контейнерах, так и об образах:

```
docker inspect someContainerOrImageName
```



# Важные заметки

* При работе с веб приложениями важно помнить про проброс портов. При старте контейнера надо указать *портХоста:портПриложенияВКонтейнере* чтобы при обращении на хосте по этому порту сообщение доходило до приложения
* Контейнер работает до тех пор, пока работает приложение

# Где докер хранит файлы образов

Очень много ответов и мест, где лежит не понятно что. Одна из версий: *C:\Users\username\AppData\Local\Docker\wsl\data*. По размеру файла примерно похоже. Вероятно, все образы находятся внутри этого виртуального диска. Кажется еще есть два стиля хранения образом - lin и win.

# Полезное

## Отправить команду программе в докере

Если нужно отправить команду программе, работающей в докере, используется `docker exec`. На примере кафки:

* Создать топик:

  ```
  docker exec my-kafka kafka-topics --bootstrap-server my-kafka:29092 --create --topic helloworld
  ```

* Отправить сообщение в тему:

  ```
  docker exec --interactive --tty my-kafka kafka-console-producer --bootstrap-server my-kafka:29092 --topic helloworld
  ```

* Прочитать все сообщения из темы:

  ```
  docker exec --interactive --tty my-kafka kafka-console-consumer --bootstrap-server my-kafka:29092 --topic helloworld --from-beginning
  ```

## Исследовать файловую систему в контейнере

Есть несколько способов. Брал [отсюда](https://stackoverflow.com/questions/20813486/exploring-docker-containers-file-system)

### Локально

Запустить баш в нужном контейнере:

```
docker exec -t -i containerName /bin/bash
```

После этого можно перемещаться по файловой системе стандартными линуксовыми командами.
