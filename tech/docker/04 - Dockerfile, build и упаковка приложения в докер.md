# Упаковка приложения в докер

Запускаем мавен clean + package и в директории target появляется .jar файл, который мы и будем упаковывать.

## Подготовка Dockerfile

Чтобы докер понимал, как это делать, создаем в корне приложения (на одном уровне с .pom) файл Dockerfile (без расширения) с таким содержимым:

```
FROM openjdk:11

WORKDIR /app/
COPY ./target/webclient-demo.jar .
EXPOSE 49080
CMD java -jar webclient-demo.jar
```

* FROM задает образ-основу для нашего собственного образа
* WORKDIR задает "рабочую" директорию, относительно которой будут ориентироваться команды COPY, CMD (и другие, вроде RUN, ADD, ENTRYPOINT). Если директории не существует, она создается автоматически
* COPY копирует *откуда* - *куда*. Откуда в данном случае это папка с программой на нашем компьютере, а . - это директория /app/ внутри будущего образа, которую мы задали через WORKDIR
* EXPOSE указывает, какой порт слушает работающее внутри контейнера приложение. Можно указывать EXPOSE несколько раз, если портов больше одного. Эта команда служит для информационных целей, чтобы  пользователь образа через команду `docker inspect SomeImageName` мог узнать о портах
* CMD задает команду, которая будет выполняться при запуске контейнера. Здесь мы указываем просто имя нашей программы, без полного пути, опять же за счет того, что задали WORKDIR. CMD фактически может быть только одна, потому что если указать их несколько, то выполнится только последняя

## build

Для сборки образа переходим в директорию с этим Dockerfile и набираем

```
docker build -t currency-generator .
```

Здесь через -t задается человекочитаемое имя образа, а `.` - это директория с файлом Dockerfile (в данном случае текущая). После этого в docker desktop появляется этот образ и его можно запустить как обычно.

# Остальные возможности Dockerfile

```java
FROM python:3.6  // Образ, на основе которого мы создаем свой образ
RUN mkdir -p /usr/src/app/  // Создать внутри образа директорию
WORKDIR /usr/src/app/  // Сделать эту директорию рабочей
COPY . .  // Скопировать из текущей директории НАШЕГО компа все содержимое в директорию внутри ОБРАЗА, причем вторая . указывает на /usr/src/app/, т.к. она задана в WORKDIR
RUN pip install --no-cache-dir -r reqs.txt  // Установить зависимости программы, печисленные в файле reqs.txt
EXPOSE 8080  // Сообщаем о порте, который слушает приложение, работающее в контейнере
ENV TZ Europe/Moscow  // Устанавливаем переменную окружения (при запуске можно будет поменять, вроде)
CMD ["python", "hello-docker.py"]  // Выполнить команду "python hello-docker.py", запустив ее в shell
```

reqs.txt выглядит так:

```
flask==1.1.1
```

Дополнение: насчет COPY, директории запуска docker build и положения Dockerfile. В команде COPY отсчет ведется очевидно от директории, в которой лежит Dockerfile. Если положить программу не рядом с Dockerfile, а например в ./prog, тогда нужно будет указать COPY ./prog Если этого не сделать, то в /usr/src/app/ скопируется папка prog, и тогда надо было бы указать в CMD ["python", "**prog**/hello-docker.py"]. В общем, за этими путями надо следить.

## Команды

* RUN выполняет указанную команду *на этапе билда* образа (в отличие от CMD, которая срабатывает уже при запуске контейнера)
* ENV устанавливает переменные окружения
* ENTRYPOINT пока не сталкивался