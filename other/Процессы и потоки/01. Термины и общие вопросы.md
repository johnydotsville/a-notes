# Связанные понятия

Многозадачность

> Это способность системы переключаться между процессами туда-сюда, за счет чего возникает иллюзия их одновременной работы, потому что переключения происходят быстро. Называется еще вытесняющая многозадачность

kernel space (KS) и user space (US)

> Память условно можно разделить на две области - в одну область загружается ядро (KS), а в другую область (US) загружаются все остальные программы, называемые "пользовательскими", хотя реальный пользователь о них может даже не знать, просто они так называются. Все, что не ядро - "пользовательские" программы. Они не имеют доступа к KS. Ядро же к US доступ имеет. Некоторые части ОС, не относящиеся к ядру, тоже могут располагаться в US

Прерывания, вектор прерываний

> ???

Системные вызовы

> ???

Счетчик команд, программный счетчик

> ???

Указатель стека

> ???

Критическая секция (КС)

> Участок кода, в котором фигурирует общая переменная (или любой другой ресурс), которую могут совместно использовать несколько потоков. Например, есть статическая переменная и функция, которая ее увеличивает на единицу. Если запустить такую функцию на исполнение сразу в нескольких потоках, то без организации синхронизации между ними результаты прибавления периодически могут теряться. Строчка функции, в которой выполняется прибавление - и есть критическая секция.

Активное ожидание

> Оно же Busy Wainting. Это когда ожидание входа в критическую секцию реализуется через цикл, который крутится пока не нарушится условие. В противовес этому способу есть усыпление и пробуждение процессов\потоков. У обоих подходов есть свои достоинства и недостатки

Примитивы синхронизации

> Это базовые средства для организации синхронизации работы нескольких потоков. Обычно имеют системную\аппаратную поддержку. К ПС относятся семафоры, мьютексы, фьютексы, мониторы

# Общие вопросы

- [x] Имеет ли смысл процесс без потоков? Или в процессе всегда как минимум один поток?

> Процесс без потока смысла не имеет, поскольку процесс - просто "контейнер" с некоторой служебной информацией, в котором всегда как минимум один поток, который и производит всю работу.

- [x] Что для ОС есть процесс, а что - поток? Как эти вещи организованы технически?

> Для ОС что поток, что процесс технически - просто массив со структурами, размещенный в оперативной памяти, из которых понятно, какое адресное пространство занимает процесс, какой у него ID, приоритет и прочая служебная информация. Где именно они расположены - зависит от конкретной модели реализации в системе.
>
> Логически процесс ассоциируется с запущенной программой, а потоки - с "подзадачами" внутри этой программы, которые могут выполняться "одновременно". Но опять же, техническая реализация может делать грань между процессами и потоками весьма тонкой.

- [x] Как идет обмен данными между потоками и процессами?

> Современные ОС позволяют процессам шарить часть своего адресного пространства как раз для возможности обмена между процессами. А между потоками обмен проще, потому что если они принадлежат одному процессу, то имеют одинаковый доступ к его адресному пространству. Это на бумаге. На практике нужно уже смотреть то, какие средства коммуникации дает конкретная система.

- [x] Что такое контекст применительно к потокам и процессам?

> Контекст - это вся совокупность информации, связанная с выполнением потока\процесса. Сюда входят как вещи, необходимые для приостановки\возобновления работы процесса\потока вроде счетчика команд, указателя стека, содержимое регистров CPU, так и что-либо другое.

- [x] Вроде контекст - это не только состояние памяти, но и регистров CPU. Как сохраняется это все при переключении? И как загружается обратно.

> Когда приходит время приостановить процесс\поток, берутся текущие значения из регистров CPU и сохраняются в адресное пространство процесса\потока. Кто именно этим занимается - ядро или пользовательская программа, опять же, зависит от реализации потоков\процессов в системе.

- [x] Переключается ли CPU между потоками?

> Да, переключается. Вопрос только в том, что переключение реализуется по-разному. Если потоки реализованы целиком в пространстве пользователя, тогда они сами должны передавать управление над CPU своим "товарищам по процессу". Если же они реализованы целиком в пространстве ядра, тогда переключение происходит по таймеру CPU и при участии ядра, так же как и при переключении между процессами.
>
> Насколько я читал, реализация потоков на уровне ОС называется native threads, а реализация на уровне программы - green threads. GT вроде как гораздо легче создавать, но существенный недостаток - они не могут выполняться по-настоящему одновременно. В то время как NT создавать затратнее, но возможно одновременное выполнение (конечно если есть техническая возможность, например, несколько ядер в процессоре)

- [ ] Что такое виртуальная память?
- [x] Какие классические проблемы связаны с потоками?

> Как с потоками, так и с процессами основная проблема - Race Condition, когда процесс\поток не успевают доделать логически единую операцию над общим ресурсом и прерываются, а при возобновлении работы оказывается, что предыдущее значение общего ресурса уже неактуально. Соответственно, дальше работа ведется с заведомо некорректными исходными данными и результат тоже получается некорректный.

- [ ] Могут ли два процесса, выполняющиеся на разных ядрах, одновременно писать и читать в одно и то же место на диске или в памяти? Это физически вообще возможно?
- [ ] Что такое POSIX-совместимая операционная система?
- [ ] Что такое блокирующий системный вызов? Все ли системные вызовы являются блокирующими?
- [ ] Проще ли потоку, реализованному в US, сделать системный вызов, чем потоку, реализованному в KS?
