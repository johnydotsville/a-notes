# Race Condition

Это проблема, возникающая при доступе разных потоков к общим данным. Допустим, есть целочисленная переменная, в которую один процесс A прибавляет 1, а второй B - 2. Поскольку операция присваивания делится как минимум на три операции - считать исходное значение, прибавить и записать результат, то может возникнуть такая ситуация:

* Процесс A считывает значение переменной. Пусть это число 7
* В этот момент у него заканчивается квант времени и начинает работу процесс B
* B тоже считывает 7, делает +2 и записывает в результат 9
* Процесс А возобновляет свою работу с того места, где закончил в прошлый раз: прибавляет 1, но к 7, потому что именно 7 он считал себе в прошлый раз, и записывает в результат 8, хотя должно быть 10

Это и есть Race Condition, возникает, когда процесс не успевает доделать свою работу над ресурсом, которым пользуется кто-то еще помимо него. И в итоге какие-то результаты теряются.

Таким образом, когда больше одного процесса входят в свои критические секции, возникают проблемы.

Есть 4 условия, которые должно соблюдать решение, призванное избежать RC, и при этом считаться хорошим:

1. Два потока не могут одновременно находиться в своих КС
2. Поток, не находящийся в своей КС, не должен блокировать другие потоки
3. Поток не должен вечно ждать своей очереди входа в свою КС
4. Нельзя ориентироваться на скорость CPU или количество CPU

# Способы избежания Race Condition

## Отключить прерывания

Первый вариант решения проблемы RC - отключение прерываний. Причина RC - прерывание от таймера, которое может остановить процесс в неподходящий момент. Соответственно, если дать возможность процессу отключить прерывания перед входом в КС и включить их обратно при выходе из нее, его не прервут в неподходящий момент и проблемы не будет. Но это, во-первых, опасно, потому что он может не включить прерывания обратно, а, во-вторых, неактуально для многоядерных CPU, потому что прерывания отключаются только для того ядра\CPU, на котором выполняется процесс. Соответственно, если какой-то другой процесс, выполняющийся на другом ядре, работает с общим ресурсом, проблема опять появляется.

## Locking Variable

Второй способ - "Locking Variable" заключается в заведении специальной переменной-флага (лок), которую процессы будут устанавливать в 1 при входе в КС и возвращать в 0 при выходе из нее. Тогда другой процесс перед входом в КС смог бы проверять лок и понимать, можно ли ему входить в КС или нельзя. Но это решение само страдает от RC. То есть процесс может считать значение лока, тут у него заканчивается квант и он не успевает проанализировать считанное значение. Когда ему в следующий раз перейдет управление, он начнет с анализа, но считанное в прошлый раз значение может быть уже неактуальным. Если попытаться считать повторно, снова может возникнуть прерывание процесса и так далее. То есть ситуация неразрешимая без аппаратной поддержки (TSL, об этом далее).

> - [ ] Действительно ли ядро может допустить ситуацию, что процесс с низким приоритетом никогда не получит процессорное время, даже если есть процессы с высоким приоритетом?

## Строгое чередование

Это способ, при котором процессы явно указывают, какому другому процессу передать управление. Это тоже делается через общую переменную, но за счет того, что каждый процесс ожидает своего уникального значения, одновременного вхождения в КС не бывает:

```c
#define TRUE 1;
int turn = 0;
// Процесс 1
while (TRUE)
{
    while (turn != 0);
    do_crit();
    turn = 1;
    do_non_crit();
}
// Процесс 2
while (TRUE)
{
    while (turn != 1);
    do_crit();
    turn = 0;
    do_non_crit();
}
```

При такой организации процесс не сможет войти в КС, если не его очередь. Однако может получиться следующая ситуация: если П1 (или П2, не важно) выполняется очень быстро и за отведенный ему квант времени успеет полностью выполнить свой главный цикл, то на вторую "итерацию" уже зайти не сможет, потому что уже перезаписал turn, и повиснет на весь оставшийся квант в цикле, хотя теоретически мог бы успеть сделать 2 итерации или даже больше. Это нарушает принцип "процесс не может вызывать блокировку, если не находится в КС". Так что такой алгоритм может нормально работать только если все процессы выполняются примерно одинаковое время.

## Алгоритм Петерсона

Этот алгоритм тоже использует активное ожидание, но не имеет недостатка в виде самоблокирования:

```c
#define TRUE  1
#define FALSE 0
#define N     2

int turn;
int interested[N];

void enter_CR(int process)
{
    int other = 1 - process;
    interested[process] = TRUE;
    turn = process;
    while(turn == process && interested[other] == TRUE);
}

void leave_CR(int process)
{
    interested[process] = FALSE;
}
```

Смысл в том, что вводится две специальные функции, одну из которых процесс должен запускать непосредственно перед входом в КС, а вторую - сразу же после выхода из КС. Есть массив с номерами процессов, заинтересованных во входе в КС, и переменная, чтобы "застолбить" себе вход.

За счет использования двух переменных, не может получиться ситуации, что два процесса разом окажутся в КС. В общем-то это можно представить и без объяснений, посмотрев на код. Но все равно приведу некоторые из возможных вариантов:

1. Процесс П0 вызывает enter_CR(0). Отмечается в массиве заинтересованных. Например, на этом моменте квант заканчивается и другой процесс, П1, вызывает enter_CR(1) и доходит до while. Оба условия выполняются и П1 начинает активное ожидание. Управление возвращается П0. Он продолжает со строчки turn = process, и перезаписывает turn в 0. Доходит до цикла и тоже начинает активное ожидание. Когда квант заканчивается и управление снова попадает П1, тогда условие while нарушается, потому что turn уже = 0, а не 1, функция завершается и П1 попадает в КС.
2. Процесс П0 вызывает enter_CR(0). Отмечается в массиве заинтересованных. Присваивает turn. Если заинтересованных больше нет, он входит в КС. Если есть, начинается активное ожидание. Дальше все как в первом варианте. Как только другой процесс сменит turn и управление вернется на П0, цикл ожидания прервется и он войдет в КС.

Таким образом получается, что кто первым присвоит turn, тот первым и попадет в КС. Хотя при наличии других заинтересованных конечно выглядит немного странно - для попадания в КС приходится ожидать, пока другой процесс перезапишет turn. Но тем не менее это работает как минимум для двух процессов.

> - [ ] С виду этот алгоритм расчитан только на 2 процесса, как минимум, именно такая реализация. Потому что если N будет 3, то вычисление other в таком виде перестанет работать. Можно ли адаптировать этот алгоритм для нескольких процессов?

## Команды TSL и XCHG

Проблема с "Locking Variable" возникает из-за того, что цепочка "считать-проанализировать-записать" должна выполняться разом, "атомарно". Но без аппаратной поддержки это невозможно. Поэтому в ОС есть специальные команды TSL и XCHG, которые эту аппаратную поддержку обеспечивают. TSL - "Test and Set Lock" выглядит примерно так:

```assembly
TSL REGISTER, LOCK  | Считать значение LOCK в регистр, а в LOCK записать 1
```

Аппаратная поддержка заключается в том, что в момент выполнения команды TSL процессор блокирует шину памяти и поэтому никакой другой процессор (или ядро процессора) не может ничего записать в переменную LOCK. Поскольку это блокирование осуществляется на очень короткое время, оно не оказывает сильного влияния на производительность. Таким образом, после выполнения команды TSL, в переменной LOCK оказывается 1, а ее старое значение оказывается в регистре.

Теперь можно удобно реализовать функции входа и выхода из критических секций:

```assembly
enter_region:
    TSL REGISTER, LOCK
    CMP REGISTER, #0
    JNE enter_region
    
    RET
    
leave_region:
    MOVE LOCK, #0
    RET
```

Как могут развиваться события:

1. Процесс П1 заходит в enter region, выполняет TSL. Допустим, в LOCK был 0. Тогда этот 0 оказывается в регистре, а в LOCK записывается 1. Тут заканчивается квант и управление достается процессу П2. При этом важно помнить, что перед передачей управления П2, значения регистров для П1 сохраняются, чтобы можно было восстановить его работу в будущем.

2. П2 тоже заходит в enter region, выполняет TSL. В регистр из LOCK считывается 1, и в LOCK снова записывается 1. На строчке #3 становится понятно, что в LOCK была 1, поэтому управление снова попадает на строчку #2. Опять в регистр считывается значение LOCK, которое по-прежнему 1, опять проводится проверка и осуществляется переход. То есть получается активное ожидание.

3. Когда управление возвращается к П1, значения его регистров восстанавливается. В пункте 1 мы сказали, что в LOCK изначально был 0. Таким образом, строчка #3 даст true и осуществится возврат из функции, строчка #6. П1 выполнит свою КС, вызовет функцию leave region, которая поместит в LOCK 0. И когда управление вернется П2 и он снова окажется на строчке #2 с TSL, то в регистр попадет 0, а в LOCK запишется 1. Теперь уже строчка #3 для П2 даст true и он сможет войти в КС.

## Усыпление и пробуждение

У команды TSL и алгоритма Петерсона есть недостаток, связанный с тем, что освобождение лока они ожидают через busy waiting. Недостаток в том, что если процесс A с более высоким приоритетом переходит в состояние blocked, а потом процесс B с низким приоритетом входит в КС и занимает лок, то когда процесс А возобновит работу и войдет в цикл ожидания освобождения лока, на этом дело и закончится, потому что процесс В никогда не получит процессорное время из-за своего низкого приоритета, а значит не сможет освободить лок и следовательно процесс А не выйдет из цикла ожидания.

Кроме того, активное ожидание подразумевает то, что процессорное время по сути тратится впустую на прокрутку цикла, и никаких полезных вычислений в это время не производится. Это иногда может быть выгодно, если такое ожидание длится недолго и тогда дешевле получается покрутить цикл, чем переключать контексты процессов. Но не всегда.

Поэтому существует другой способ ожидания, основанный на использовании системных вызовов, которые ***усыпляют*** и ***пробуждают*** процессы. Условно назовем их `sleep` и `wakeup`
