# Проблема поставщика и потребителя

Представим ситуацию, что есть некоторый буфер сообщений и два потока - "поставщик" наполняет этот буфер, а "потребитель" извлекает. Если буфер полностью заполняется, поставщик должен приостановиться и возобновить работу, когда в буфере снова появится хотя бы один слот. Потребитель, аналогично, должен остановиться, когда в буфере нет ни одного сообщения, и восстановиться, когда появится хотя бы одно. Каждый поток, обнаруживая условие остановки, делает системный вызов sleep и таким образом переходит в состояние blocked. Противоположный поток, обнаруживая условие пробуждения, делает вызов wakeup, пробуждая своего "коллегу".

> - [ ] Действительно ли sleep и wakeup являются системными вызовами, а не пользовательскими функциями?

Здесь опять может возникнуть проблема из-за RC. Например, размер буфера 10. Поставщик прочитал заполненность буфера и она оказалась равной 10. В этот момент его квант времени закончился, и он не успел заснуть. Потребитель прочитал сообщение и понял, что буфер был 10, а стал 9, значит пока разбудить поставщика и посылает команду wakeup. 

Но поскольку поставщик еще не спит, то команда не имеет никакого эффекта. Как только поставщик продолжает работу, он анализирует ранее прочитанное сообщение, видит 10 и засыпает. Потребитель продолжает читать сообщения, доходит до 0 и тоже засыпает. Оба потока благополучно уснули.

Пример кода, который демонстрирует решение задачи через sleep и wakeup и описанную проблему:

```c
#define TRUE 1
#define N 100
int count = 0;

void producer()
{
    int item;
    int prev_count;
    
    while (TRUE)
    {
        item = create_item();
        if (count == N) sleep();
        insert_item(item);
        prev_count = count;  // Моя доработка
        count++;
        if (count == 1 && prev_count == 0) wakeup(proc_consumer);
    }
}

void consumer()
{
    int item;
    int prev_count;
    
    while (TRUE)
    {
        if (count == 0) sleep();
        item = get_item();
        prev_count = count;  // Моя доработка
        count--;
        if (count == N - 1 && prev_count == N) wakeup(proc_producer);
        do_some_with_item(item);
    }
}
```

Решение может заключаться в введении ***бита активации*** - специального флага, который при поступлении wakeup устанавливается в 1. Тогда предварительно посмотрев на этот бит поставщик мог бы понять, что ему не нужно засыпать.