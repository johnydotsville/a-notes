# Примитивы синхронизации

## Семафоры

Семафор - это примитив синхронизации, представляющий собой счетчик. Работа с ним основана  на использовании процессами двух *атомарных операций* - `up` и `down`, которые соответственно увеличивают и уменьшают семафор на единицу. Когда операция down применяется к семафору, который уже равен 0, то она не завершается, а вызвавший ее процесс засыпает.

Счетчик реализован в виде глобальной переменной или иным способом так, чтобы он был доступен нескольким процессам.

С помощью семафоров можно организовать как охрану входа в критическую секцию, так и анализировать какие-нибудь другие моменты. Будет показано дальше на примере решения задачи "Поставщика и потребителя".

> - [ ] Кто занимается пробуждением спящих процессов? В ядре есть какой-то функционал, который связывает спящие процессы с неким семафором и их будит ядро?
>
> 

> - [x] Может ли семафор иметь значение больше 1? Судя по разным описаниям с хабра, вроде может. Вроде как он может быть например 3 и тогда три процесса, обратившись к семафору, получат "зеленый свет" на выполнение. Но это как-то абсурдно, ведь задача семафора вроде как блокировать одновременный вход нескольких процессов в КС.
>
> Дело в том, что семафор может использоваться *не только* для предотвращения одновременного вхождения нескольких процессов в КС, но и для некоторой синхронизации. На примере задачи поставщика и потребителя семафоры позволяют благодаря анализу свободных и занятых слотов усыплять и пробуждать процессы, заполняющие и читающие буфер. Соответственно, значение семафора будет 100, если в буфере 100 слотов.
>
> Суть в том, что как только значение семафора становится 0 и какой-то процесс пытается выполнить на нем операцию down, то эта операция не завершается и процесс засыпает. А как только семафор станет >0, то ядро выберет какой-нибудь процесс из тех, которые заснули на этом семафоре, этот процесс продолжит работу, завершит не законченную в прошлый раз операцию down, и войдет в КС.
>
> Если от семафора не требуется синхронизация, а только охрана КС, тогда действительно у него будут значения только 0 и 1. И такой "семафор" уже называется мьютекс.

> - [x] Может ли процесс\поток, находясь в КС, прерваться?
>
> Да, может. КС ничем не отличается от любой другой части кода за исключением того, что перед ней и после нее используются операции охраны КС. Соответственно, она может прерваться, при этом другие потоки просто все еще не смогут войти в КС, пока уже вошедший в нее поток снова не вернется к работе, не выйдет из КС и не выполнит, например, сброс мьютекса.

> - [x] Один семафор объединяет процессы, работающие с одним и тем же общим ресурсом?
>
> Разумеется. На каждую КС используется свой семафор.

## Мьютексы

Мьютекс - это семафор, который может иметь значения только 0 и 1. Ввиду этого используется обычно только для охраны входа в КС. Вот пример реализации мьютекса:

```assembly
mutex_lock:
    TSL REGISTER, MUTEX
    CMP REGISTER, #0
    JZE ok
    
    CALL thread_yield
    JMP mutex_lock
ok:
    RET
    
mutex_unlock:
    MOVE MUTEX, #0
    RET
```

Эти функции похожи на рассмотренные ранее в разделе про команду TSL. Но здесь отличие в том, что вместо активного ожидания используется команда thread_yield, которая усыпляет текущий поток.

## Решение задачи "Поставщика и Потребителя"

Пример решения задачи с использованием семафоров и мьютексов:

```c
#define TRUE 1
#define CAPACITY 100
int sem_busy = 0;  // Занятые слоты
int sem_free = CAPACITY;  // Свободные слоты
int mut_CR = 1;

void producer()
{
    int item;
    
    while (TRUE)
    {
        item = create_item();
        down(sem_free);
        down(mut_CR);
        insert_item(item);
        up(mut_CR);
        up(sem_busy);
    }
}

void consumer()
{
    int item;
    
    while (TRUE)
    {
        down(sem_busy);
        down(mut_CR);
        item = get_item();
        up(mut_CR);
        up(sem_free);
    }
}
```

Мьютекс здесь используется для охраны КС. Каждый раз, как только один из процессов заходит в КС, мьютекс становится 0 и никто другой зайти в КС не может, пока процесс не апнет мьютекс обратно. Семафоры используются для синхронизации помещения и извлечения элементов. Когда семафор  `sem_free` станет 0 (это означает, что свободных мест в буфере нет), то поставщик заснет, когда попробует применить к нему down. Когда потребитель вытащит элемент из буфера, он апнет sem_free и тогда поставщик проснется.

Потребитель может работать быстрее поставщика и за свой квант освободить много слотов. Поэтому он также использует down на семафоре `sem_busy`, чтобы случайно не начать забирать то, чего еще нет. То же самое справедливо и в обратную сторону. Поставщик может работать быстрее потребителя. Поэтому оба процесса используют сразу два семафора.

## Фьютексы

Фьютексы (от fast userspace mutex)

Это примитив синхронизации, который для реализации своей работы комбинирует работу с ядром и с пользовательской библиотекой. На пользовательскую библиотеку возлагается обязанность выполнять down и если оказывается, что блокировка уже есть, то усыплять процесс и помещать его в очередь, расположенную в kernelspace. Если блокировки нет, то down завершается без привлечения ядра. За счет того, что обращение к ядру происходит не каждый раз, а только когда это действительно нужно, фьютексы работают быстрее.

## Некоторые итоги и вопросы

Когда потоки реализуются в US, то их управлением ядро не занимается. Оно о них даже ничего не знает и управление целиком ложится на пользовательские библиотеки. Если в случае с процессами переключение осуществляется за счет CPU-таймера, то US-потоки сами должны отдавать процессор своим братишкам, принадлежащим тому же процессу. В связи в этим US-потоки не могут использовать спин-блокировку (Busy Waiting), потому что если US-поток войдет в такой цикл, то уже из него не выйдет.

Объяснение фьютексов вызывает ряд вопросов:

> - [ ] Является ли операция down системным вызовом?

> - [ ] Все ли системные вызовы являются блокирующими? То есть если поток делает системный вызов, обязательно ли это значит, что управление переходит ядру и, следовательно, все остальные потоки того же процесса блокируются?

Грубо говоря, концепция операции down - это предоставление надежного способа работы с лок-переменными. Эта операция использует команду TSL, а оставшаяся часть реализации может использовать как активное ожидание, так и усыпление потока. Активное ожидание доступно только для KS-потоков, а усыпление, похоже, и для KS, и для US, разница только в том, кто будет реализовывать алгоритм усыпления - ядро или пользовательская библиотека (ПБ). Значит down, получается, может не обращаться к ядру вообще, если усыпление реализовано в ПБ. Либо использовать системный вызов (СВ) для усыпления, если используется реализация ядра. То есть получается сама по себе down либо не является СВ вообще, либо является СВ, который может вызывать (или не вызывать) в себе другой СВ.

Не особо понятно, как реализуется гибридная модель потоков. Когда они или в ядре, или в US, это понятно, а комбинация - нет.

В принципе, я считаю, что самое время начать писать программы, пытаясь использовать эти примитивы. Только мониторы еще разобрать. Потому что из одной теории понятнее не станет уже. Главное что в принципе уже понятно, как и за счет чего работают семафоры и мьютексы, и то что фьютекс - это более эффективный мьютекс. Дальнейшее понимание вполне может прийти через практику.

## Мониторы